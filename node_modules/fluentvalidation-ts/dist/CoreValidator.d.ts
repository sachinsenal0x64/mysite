import { ValidationErrors } from './ValidationErrors';
import { AsyncRuleValidators } from './valueValidator/RuleValidators';
import { RuleValidators } from './valueValidator/RuleValidators';
import { Constrain } from './types/Constrain';
export declare abstract class CoreValidator<TModel, TAsync extends true | false> {
    private _isAsync;
    constructor(isAsync: TAsync);
    private valueValidatorBuildersByPropertyName;
    private asyncValueValidatorBuildersByPropertyName;
    protected _validate: (value: TModel) => ValidationErrors<TModel>;
    protected _validateAsync: (value: TModel) => Promise<ValidationErrors<TModel>>;
    private rebuildValidate;
    private rebuildValidateAsync;
    protected ruleFor: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName]>(propertyName: TPropertyName) => TAsync extends true ? AsyncRuleValidators<TModel, TValue> : RuleValidators<TModel, TValue>;
    protected ruleForTransformed: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName], TTransformedValue extends string | number | boolean | symbol | TValue | null | undefined>(propertyName: TPropertyName, transformValue: (value: TValue) => TTransformedValue extends object ? Constrain<TTransformedValue, TValue> : TTransformedValue) => TAsync extends true ? AsyncRuleValidators<TModel, TTransformedValue> : RuleValidators<TModel, TTransformedValue>;
    protected ruleForEach: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName] extends (infer TEachValue)[] | readonly (infer TEachValue)[] | null | undefined ? (TModel[TPropertyName] & undefined) | (TModel[TPropertyName] & null) | (TModel[TPropertyName] & TEachValue[]) | (TModel[TPropertyName] & readonly TEachValue[]) : never>(propertyName: TModel[TPropertyName] extends unknown[] | readonly unknown[] | null | undefined ? TPropertyName : never) => TValue extends unknown[] | readonly unknown[] ? TAsync extends true ? AsyncRuleValidators<TModel, TValue[0]> : RuleValidators<TModel, TValue[0]> : never;
    protected ruleForEachTransformed: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName] extends (infer TEachValue)[] | readonly (infer TEachValue)[] | null | undefined ? (TModel[TPropertyName] & undefined) | (TModel[TPropertyName] & null) | (TModel[TPropertyName] & TEachValue[]) | (TModel[TPropertyName] & readonly TEachValue[]) : never, TEachTransformedValue extends string | number | boolean | symbol | (TValue extends (infer TEachValue_1)[] ? TEachValue_1 : never) | null | undefined>(propertyName: TModel[TPropertyName] extends unknown[] | readonly unknown[] | null | undefined ? TPropertyName : never, transformValue: (value: TModel[TPropertyName] extends (infer TEachValue_2)[] | readonly (infer TEachValue_2)[] ? TEachValue_2 : never) => TEachTransformedValue extends object ? Constrain<TEachTransformedValue, TModel[TPropertyName] extends (infer TEachValue_3)[] | readonly (infer TEachValue_3)[] ? TEachValue_3 : never> : TEachTransformedValue) => TValue extends unknown[] | readonly unknown[] ? TAsync extends true ? AsyncRuleValidators<TModel, TEachTransformedValue> : RuleValidators<TModel, TEachTransformedValue> : never;
}
export declare class SyncValidator<TModel> extends CoreValidator<TModel, false> {
    validate: (value: TModel) => ValidationErrors<TModel>;
    constructor();
}
export declare class AsyncValidator<TModel> extends CoreValidator<TModel, true> {
    validateAsync: (value: TModel) => Promise<ValidationErrors<TModel>>;
    constructor();
}
