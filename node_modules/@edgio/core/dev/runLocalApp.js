"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const shelljs_1 = __importDefault(require("shelljs"));
const nonWebpackRequire_1 = __importDefault(require("../utils/nonWebpackRequire"));
// we don't bundle chalk because it's large and we only use it in development
const chalk = (0, nonWebpackRequire_1.default)('chalk');
/**
 * Runs the user's app in development mode
 * @param port The port on which to listen
 * @param options Options for running the app
 * @returns A promise that resolves when the app is ready to receive requests.
 */
async function runLocalApp(port, options) {
    const { run, command } = options;
    // If dev server uses a manual run function, skip all command functionality
    if (run) {
        return run(port);
    }
    /* istanbul ignore next */
    if (!command)
        return;
    const label = chalk.grey(options.label || 'app');
    return new Promise((resolve, reject) => {
        var _a, _b, _c, _d;
        try {
            const childProcess = shelljs_1.default.exec(command(port), {
                async: true,
                env: {
                    ...process.env,
                    ...((options === null || options === void 0 ? void 0 : options.env) || {}),
                    PORT: port.toString(),
                    FORCE_COLOR: 'true',
                },
                silent: true,
            }, code => code > 0
                ? reject('Edgio encountered a fatal error while running your application.')
                : resolve());
            // If value is a number, wait that many seconds before resolving, as for
            // some frameworks, the ready regexes is not aviailable.
            if (typeof options.ready === 'number') {
                setTimeout(resolve, options.ready);
                return;
            }
            /* istanbul ignore next */
            (_a = childProcess.stderr) === null || _a === void 0 ? void 0 : _a.on('data', data => process.stderr.write(`${label} ${data}`));
            const ready = (_b = options.ready) !== null && _b !== void 0 ? _b : [];
            const filterOutput = (_c = options.filterOutput) !== null && _c !== void 0 ? _c : ((_line) => true);
            /* istanbul ignore next */
            (_d = childProcess.stdout) === null || _d === void 0 ? void 0 : _d.on('data', data => {
                let matched = false;
                ready.some((pattern, i) => {
                    if (pattern.test(data)) {
                        ready.splice(i, 1);
                        matched = true;
                    }
                });
                ready.length === 0 && resolve();
                if (matched || !filterOutput(data)) {
                    return; // hide the ready line so that the user doesn't see two URLs and get confused.
                }
                process.stdout.write(`${label} ${data}`);
                !data.endsWith('\n') && process.stdout.write('\n');
            });
        }
        catch (e) {
            reject(e);
        }
    });
}
exports.default = runLocalApp;
