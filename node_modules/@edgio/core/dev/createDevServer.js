"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore file */
const constants_1 = require("../constants");
const express_1 = __importDefault(require("express"));
const chalk_1 = __importDefault(require("chalk"));
const timing_1 = require("../timing");
const logo_1 = __importDefault(require("../utils/logo"));
const http_proxy_1 = __importDefault(require("http-proxy"));
const bundle_esbuild_1 = require("../deploy/bundle-esbuild");
const ports_1 = require("../utils/ports");
const RequestHandler_1 = __importDefault(require("../runtime/RequestHandler"));
const runLocalApp_1 = __importDefault(require("./runLocalApp"));
const paths_1 = require("../deploy/paths");
const origins_1 = require("../origins");
const edge_functions_1 = require("../deploy/edge-functions");
const LambdaRequest_1 = __importDefault(require("../runtime/LambdaRequest"));
const readBody_1 = __importDefault(require("../utils/readBody"));
const watch_1 = __importDefault(require("../utils/watch"));
const LambdaResponse_1 = __importDefault(require("../runtime/LambdaResponse"));
const getLambdaRequest = async (request) => {
    // we await the whole body, as is done in lambda
    const body = await (0, readBody_1.default)(request);
    return new LambdaRequest_1.default({
        // we expect this to not change
        url: request._parsedUrl,
        body,
        headers: request.headers,
        method: request.method,
        httpVersion: request.httpVersion,
    });
};
const getLambdaResponse = (response) => {
    const lambdaResponse = new LambdaResponse_1.default(response);
    lambdaResponse.setOnHeaders(() => {
        if (!lambdaResponse.statusMessage) {
            // If there is no statusMessage, you cannot pass in <undefined> as the second argument
            // because the headers will be lost. So we check for it existence before passing it in.
            response.writeHead(lambdaResponse.statusCode, lambdaResponse.getHeaders());
        }
        else {
            response.writeHead(lambdaResponse.statusCode, lambdaResponse.statusMessage, lambdaResponse.getHeaders());
        }
    });
    return lambdaResponse;
};
async function createDevServer(options) {
    var _a, _b;
    process.env[constants_1.EDGIO_ENV_VARIABLES.local] = 'true';
    const handler = new RequestHandler_1.default(paths_1.JS_INTERNAL_DIR, (0, origins_1.getEdgioOrigins)());
    const app = (0, express_1.default)()
        .disable('x-powered-by')
        .use((0, timing_1.withTimings)(async (req, res) => 
    // We map the request and response to LambdaRequest and LambdaResponse, in order to have the same
    // data holder as in production mode without the need for lambda handling / additional middleware.
    handler.handle(await getLambdaRequest(req), getLambdaResponse(res))));
    let routerSrcPath = '';
    const onRebuild = async () => {
        const router = handler.reload();
        await (0, edge_functions_1.watchEdgeFunctions)(router, routerSrcPath);
        console.log('> Recompile of router, config and edge functions... done.');
    };
    // Reload router on change of file in these folders
    (_a = options === null || options === void 0 ? void 0 : options.reloadOnChangeOf) === null || _a === void 0 ? void 0 : _a.forEach(dir => (0, watch_1.default)(dir, {
        ignoreInitial: true,
    }).on('all', async () => handler.reload()));
    const routerReady = (0, bundle_esbuild_1.bundleRouterAndConfig)({ watch: { onRebuild } }).then(onRebuild);
    const appReady = ((_b = options === null || options === void 0 ? void 0 : options.command) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.run) ? (0, runLocalApp_1.default)(ports_1.jsPort, options) : Promise.resolve();
    const serverReady = new Promise((resolve, reject) => {
        try {
            const server = app.listen(ports_1.port, resolve);
            // Proxy websocket requests to the JS backend. Gatsby needs this for example.
            const proxy = http_proxy_1.default.createProxyServer({
                target: {
                    host: constants_1.JS_BACKEND_HOSTNAME,
                    port: ports_1.jsPort,
                },
            });
            server.on('upgrade', function (req, socket, head) {
                proxy.ws(req, socket, head);
            });
            server.on('error', function (error) {
                console.log(error.message);
            });
        }
        catch (e) {
            reject(e);
        }
    });
    return Promise.all([routerReady, appReady, serverReady])
        .then(() => {
        console.log('> ' +
            logo_1.default +
            ' ' +
            chalk_1.default.green(`ready on ${chalk_1.default.bold(chalk_1.default.underline(`http://${ports_1.localhost}:${ports_1.port}\n`))}`));
    })
        .catch(err => {
        console.error(chalk_1.default.red('\n' + err + ' Exiting...'));
        process.exit(1);
    });
}
exports.default = createDevServer;
