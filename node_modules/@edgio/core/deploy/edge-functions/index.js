"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchEdgeFunctions = exports.getEdgeFunctionBytecode = exports.getEdgeFunctionSources = void 0;
const path_1 = require("path");
const edgeFunctionUtils_1 = require("../../utils/edgeFunctionUtils");
const EdgeFunctionsNodeBuilder_1 = __importDefault(require("./EdgeFunctionsNodeBuilder"));
const paths_1 = require("./paths");
const fs_1 = require("fs");
const watch_1 = __importDefault(require("../../utils/watch"));
const paths_2 = require("../paths");
/**
 * Close functions for all files being actively watched for changes
 */
let watchers = [];
/**
 * Returns an object whose names are function paths and whose values are the source code for the function.
 * @returns
 */
function getEdgeFunctionSources() {
    const path = (0, path_1.join)((0, paths_2.getJsInternalPath)(), paths_2.EDGE_FUNCTION_SOURCES_FILENAME);
    if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, 'utf8'));
    }
    else {
        return {};
    }
}
exports.getEdgeFunctionSources = getEdgeFunctionSources;
/**
 * Returns the compiled code for the edge function at the specified source path
 * If there are no edge functions or they have not been generated yet, returns undefined.
 * @returns
 */
function getEdgeFunctionBytecode(rules = []) {
    // Check if there are any edge function features at all.
    if (!(0, edgeFunctionUtils_1.containsEdgeFunctionFeature)(rules))
        return undefined;
    const path = (0, paths_1.getQuickJSBytecodePath)();
    if (!(0, fs_1.existsSync)(path)) {
        // The edge functions have not been generated yet and we cannot invoke the build
        // here which is an asynchronous operation. So we return undefined and the caller
        // will later ensure that the edge function is built.
        return undefined;
    }
    return (0, fs_1.readFileSync)(path);
}
exports.getEdgeFunctionBytecode = getEdgeFunctionBytecode;
/**
 * Watches for changes to all edge functions referenced by the specified rules and compiles them.
 * @param rules The router rules
 * @param routerSrcPath The path to the routes file relative to the root of the app
 */
async function watchEdgeFunctions(router, routerSrcPath) {
    const rules = router.rules;
    const edgeFunctionsBuilder = new EdgeFunctionsNodeBuilder_1.default(router, routerSrcPath);
    clearWatchers();
    // Assemble a list of directories that contain edge functions
    // and watch them for changes to any .js files.
    let watchList = new Set();
    for (let feature of (0, edgeFunctionUtils_1.getEdgeFunctionFeatures)(rules)) {
        const srcPath = feature.edge_function;
        const watchGlob = (0, path_1.join)((0, path_1.resolve)((0, path_1.dirname)(srcPath)), '*.js');
        watchList.add(watchGlob);
    }
    for (let watchGlob of watchList) {
        const watchOptions = {
            atomic: true, // Automatically filters out artifacts that occur when using editors that use "atomic writes" instead of writing directly to the source file.
        };
        const watcher = (0, watch_1.default)(watchGlob, watchOptions);
        watcher.on('change', async () => {
            process.stdout.write(`> Bundling edge functions... `);
            await edgeFunctionsBuilder.build();
            process.stdout.write(`done.\n`);
        });
        watchers.push(watcher);
    }
    process.stdout.write(`> Bundling edge functions... `);
    await edgeFunctionsBuilder.build();
    process.stdout.write(`done.\n`);
}
exports.watchEdgeFunctions = watchEdgeFunctions;
/**
 * Clears all watches for edge function files
 */
function clearWatchers() {
    for (let watcher of watchers) {
        watcher.close();
    }
    watchers = [];
}
