"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionsBuilder_1 = __importDefault(require("./EdgeFunctionsBuilder"));
const fs_1 = require("fs");
const path_1 = require("path");
const esbuild_1 = require("esbuild");
const environment_1 = require("../../environment");
const EdgeFunctionCompiler_1 = require("../../runtime/edge-functions/EdgeFunctionCompiler");
const EdgeFunctionsWorkerManager_1 = __importDefault(require("../../runtime/edge-functions/EdgeFunctionsWorkerManager"));
const paths_1 = require("./paths");
const edgeFunctionUtils_1 = require("../../utils/edgeFunctionUtils");
const paths_2 = require("../paths");
/**
 * The edge functions builder for NodeJS environment.
 * This builder uses esbuild to bundle the index file, so it allows to use imports in edge functions.
 * This builder builds the index file 'edgeFunctionsIndexCodeTemplate' with sdk, edge functions and bundle it.
 * The index file is then compiled to QuickJS bytecode.
 */
class EdgeFunctionsNodeBuilder extends EdgeFunctionsBuilder_1.default {
    /**
     * @param Router The Router
     * @param baseDir The base of the project directory
     */
    constructor(router, baseDir) {
        super(router);
        /**
         * A map of edge function paths to source code to upload for display in console.
         */
        this.sources = {};
        this.baseDir = (0, path_1.isAbsolute)(baseDir) ? baseDir : (0, path_1.join)(process.cwd(), (0, path_1.dirname)(baseDir));
    }
    /**
     * Returns the code with edge function import as string
     * which can later be inserted into edge functions map.
     * @returns
     */
    getFunctionCode(srcPath, isInitScript) {
        // Accumulate the source code for deploys so it can be displayed in the console.
        const funcPath = (0, path_1.join)(this.baseDir, srcPath);
        this.sources[srcPath] = (0, fs_1.readFileSync)(funcPath, 'utf8');
        // Here we use a require('module/path') call instead of import * from 'module/path' to ensure that side effects
        // are only executed if the function is used. This may help reduce unexpected behavior
        // from side-effects caused by poorly written code.
        return `const ${this.functionDefaultExportName} = require(${JSON.stringify((0, path_1.join)(this.baseDir, srcPath))}).${isInitScript ? 'handleHttpInit' : 'handleHttpRequest'};`;
    }
    /**
     * Returns the code of prebuilt the index code template from the file system.
     * @returns
     */
    async getIndexCodeTemplate() {
        return (0, fs_1.readFileSync)((0, path_1.join)(__dirname, this.indexCodeTemplateFilename), 'utf8');
    }
    /**
     * Bundles the generated index code into a single file bundle
     * and returns the bundled code
     * @returns
     */
    async bundleIndexCode(indexFilePath = (0, paths_1.getIndexPath)(), writeLocalFile) {
        const indexCode = await this.getIndexCode();
        (0, fs_1.writeFileSync)(indexFilePath, indexCode);
        // We bundle the index file to a single file bundle
        // so the all imports in edge functions are resolved and added to bundle.
        const { code: bundledIndexCode } = await this.bundle(indexFilePath, writeLocalFile);
        return bundledIndexCode;
    }
    /**
     * Builds all edge functions referenced by the specified rules and compiles them.
     * Returns a Buffer with the compiled bytecode for the edge functions index file
     * or undefined if there are no edge functions.
     * @param options Additional options with custom paths
     * @returns
     */
    async build(options = {}) {
        // Check if there are any edge function features at all.
        if (!(0, edgeFunctionUtils_1.containsEdgeFunctionFeature)(this.router.rules))
            return undefined;
        options.indexFilePath = options.indexFilePath || (0, paths_1.getIndexPath)();
        options.bytecodePath = options.bytecodePath || (0, paths_1.getQuickJSBytecodePath)();
        let bundledIndexCode;
        try {
            bundledIndexCode = await this.bundleIndexCode(options.indexFilePath, (0, environment_1.isLocal)());
        }
        catch (e) {
            // If there is a bundling error, the bundler will display the error for us. So just return
            // undefined here. This prevents the CLI from exiting when edge functions have a bundling error.
            return undefined;
        }
        // Use relative path when compiling so stack traces do not have absolute paths which
        // may otherwise leak information about the developer's machine.
        const relativePath = (0, path_1.relative)(process.cwd(), (0, paths_1.getBundlePath)());
        const bytecode = await (0, EdgeFunctionCompiler_1.compileEdgeFunction)(bundledIndexCode, relativePath);
        (0, fs_1.writeFileSync)(options.bytecodePath, bytecode);
        // On successful build, reset the edge function memory so it will use cold start.
        EdgeFunctionsWorkerManager_1.default.clearWasmInitialMemory();
        return bytecode;
    }
    /**
     * Bundles the edge functions index at the specified path into a single file bundle.
     * @param indexPath
     * @returns
     */
    async bundle(indexPath, writeLocalFile) {
        const esBuildOptions = {
            entryPoints: [indexPath],
            bundle: true,
            minify: (0, environment_1.isProductionBuild)(),
            // format: cjs, with mainFields: [ module, main] gives the same output as
            // platform: node, but without allowing NodeJs builtins like `url` to be imported.
            format: 'cjs',
            platform: 'neutral',
            target: 'es2020',
            mainFields: ['module', 'main'],
            sourcemap: false,
            sourceRoot: (0, environment_1.isCloud)() ? (0, paths_2.getJsInternalPath)() : '',
            write: false, // output to memory instead of writing to disk
        };
        const result = await (0, esbuild_1.build)(esBuildOptions);
        const { TextDecoder } = require('util');
        const textDecoder = new TextDecoder();
        let code = '';
        for (let out of result.outputFiles || []) {
            code += textDecoder.decode(out.contents);
        }
        if (writeLocalFile) {
            (0, fs_1.writeFileSync)((0, paths_1.getBundlePath)(), code);
        }
        return { code };
    }
    /**
     * Converts the edge function into cjs
     * @param code
     * @returns cjs
     */
    async convertToCjs(code) {
        const esTransformOptions = {
            minify: false,
            target: 'node16.0',
            format: 'cjs',
        };
        const result = await (0, esbuild_1.transform)(code, esTransformOptions);
        return result.code;
    }
}
exports.default = EdgeFunctionsNodeBuilder;
