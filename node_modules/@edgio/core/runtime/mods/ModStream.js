"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const RulesVisitor_1 = __importDefault(require("../rules/RulesVisitor"));
const toEdgeRegex_1 = require("../../utils/toEdgeRegex");
const constants_1 = require("../../constants");
/**
 * Simulator-only mod (meaning without sailfish counterpart), which streams content if necessary - eg. if reading response from cache, or if set_response_body was set
 */
class ModStream extends Mod_1.default {
    async execute(phase) {
        if (Phase_1.default.UriClean === phase) {
            this.applyStreamingConfig();
        }
        if (Phase_1.default.HandleResponseDone === phase || Phase_1.default.StreamResponse === phase) {
            await this.stream();
        }
    }
    /**
     * Configures response for streaming
     * by enabling or disabling it on certain conditions.
     */
    applyStreamingConfig() {
        const response = this.context.getResponse();
        const request = this.context.getRequest();
        const statusCodePatterns = this.getCatchStatusCodes();
        response.setIsStreamable(() => {
            var _a;
            let setResponseBodyFeatureFound = false;
            this.context.forEachMatchingRule((features) => {
                var _a;
                if ((_a = features.response) === null || _a === void 0 ? void 0 : _a.set_response_body) {
                    return (setResponseBodyFeatureFound = true);
                }
            });
            // do not stream if set_response_body will be executed
            if (setResponseBodyFeatureFound)
                return false;
            // do not stream if we receive 416 from origin
            if (response.statusCode === 416)
                return false;
            // do not stream if following redirects
            if (response.getHeader('location') && this.context.followRedirects)
                return false;
            // do not stream if we receive the status code from origin that should be caught
            if (statusCodePatterns.find(pattern => pattern.test(response.statusCode.toString()))) {
                return false;
            }
            const hintHeader = (_a = request.getHeader(constants_1.EDGIO_CLOUD_FUNCTIONS_HINT_HEADER)) === null || _a === void 0 ? void 0 : _a.toString();
            // do not stream if we do proxy with transformRequest or transformResponse
            if (hintHeader === null || hintHeader === void 0 ? void 0 : hintHeader.includes(constants_1.EDGIO_CLOUD_FUNCTIONS_HINTS.proxy)) {
                return false;
            }
            // otherwise enable streaming of response
            return true;
        });
    }
    /**
     * Performs streaming
     */
    async stream() {
        // we do not want to stream if we are following redirects
        if (this.context.followRedirects)
            return;
        const response = this.context.getResponse();
        if (!response.isHeadersStreamed && response.chunks.length > 0) {
            await this.context.executeStreamResponse();
        }
        // no matter what, we wait for stream to fully end, to end the simulation processing
        await response.waitForFlush();
    }
    /**
     * Returns the list of regexp status code patterns that we should catch
     */
    getCatchStatusCodes() {
        const statusCodePatterns = [];
        new RulesVisitor_1.default({
            onConditionVisit: (condition, _operator) => {
                const leftSide = condition === null || condition === void 0 ? void 0 : condition[0];
                const rightSide = condition === null || condition === void 0 ? void 0 : condition[1];
                // Nothing to do if the rule is not matching status code
                if (leftSide['response'] !== 'status_code') {
                    return;
                }
                // If status code is matched against a string value, we need to reconstruct the regex pattern
                if (typeof rightSide === 'string') {
                    return statusCodePatterns.push((0, toEdgeRegex_1.fromEdgeRegex)(rightSide));
                }
                // If we have an array of status codes, we need to convert them all to regex patterns
                if (Array.isArray(rightSide)) {
                    return statusCodePatterns.push(...rightSide.map(code => new RegExp(code)));
                }
            },
        }).visit(this.context.rules);
        return statusCodePatterns;
    }
    toString() {
        return 'ModStream';
    }
}
exports.default = ModStream;
