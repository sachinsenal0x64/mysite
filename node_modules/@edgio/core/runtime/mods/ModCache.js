"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const toRegExp_1 = __importDefault(require("../toRegExp"));
const log_1 = __importDefault(require("../../log"));
const interpolate_1 = __importDefault(require("../interpolate"));
const constants_1 = require("../../constants");
const cache_control_parser_1 = require("cache-control-parser");
const toSeconds_1 = require("../../router/converters/toSeconds");
const toTimeUnitAbbrev_1 = require("../../router/converters/toTimeUnitAbbrev");
const log_2 = __importDefault(require("../../log"));
/**
 * Emulation of Sailfish's mod_cache
 */
class ModCache extends Mod_1.default {
    constructor() {
        super(...arguments);
        this.cachingFeatures = { caching: {} };
    }
    async execute(phase) {
        /* istanbul ignore else */
        if (Phase_1.default.UriClean === phase) {
            this.context.forEachMatchingRule(rule => this.applyCacheReadFeatures(rule));
        }
        else if (Phase_1.default.HandleDocRoot === phase) {
            this.readCachedResponse();
        }
        // if we just read from cache, we apply these rules again - we definitely need to apply debug headers, to set whether it was hit or miss,
        // but also - some of the rules could reload, and so the wanted rules could differ
        if (Phase_1.default.HandleResponseHeader === phase ||
            (this.context.useCacheFile && Phase_1.default.HandleDocRoot === phase)) {
            this.context.forEachMatchingRule(rule => this.applyCacheWriteFeatures(rule));
            this.ensureAge();
            this.applyResponseCachingHeaders();
            this.context.forEachMatchingRule(rule => {
                this.applyDebugHeaderFeatures(rule);
                this.applyExternalMaxAge(rule);
            });
            this.maybeApplyAdditionalCachingHeaders();
        }
        else if (Phase_1.default.HandleResponseDone === phase) {
            this.maybeWriteCachedResponse();
        }
    }
    readCachedResponse() {
        const response = this.context.getResponse();
        if (!this.context.cache) {
            return;
        }
        if (this.context.bypassCache || this.context.bypassCacheByHonor) {
            log_1.default.info(() => `[pass] ${this.context.summarize()}`);
            this.setCachingStatus(constants_1.CACHING_STATUS.bypassed);
        }
        else {
            log_1.default.trace(`[ModCache] cache key: ${this.context.cacheKey}`);
            const result = this.context.cache.get(this.context.cacheKey);
            if (result) {
                response.statusCode = result.response.statusCode;
                response.statusMessage = result.response.statusMessage;
                response.chunks = result.response.chunks;
                // Copy over headers from the cached response
                for (let name in result.response.headers) {
                    const value = result.response.headers[name];
                    response.setHeader(name, value);
                }
                this.setCachingStatus(constants_1.CACHING_STATUS.hit);
                // update the age header by adding the time since the response was cached to the responses age header
                let age = parseInt(response.getHeader('age') || '0');
                const timeSinceCached = Math.floor((Date.now() - result.response.cachedAt) / 1000);
                response.setHeader('age', (age + timeSinceCached).toString());
                // there's a possibility a chunk is null, signalling the end of stream
                const contentLength = response.chunks.reduce((value, chunk) => { var _a; return (_a = value + (chunk === null || chunk === void 0 ? void 0 : chunk.byteLength)) !== null && _a !== void 0 ? _a : 0; }, 0);
                // we're adding the header as it could be previously removed during reencoding
                // checking NaN in case we have something else then buffers in there - shouldnt happen tho
                if (!Number.isNaN(contentLength)) {
                    response.setHeader(constants_1.HTTP_HEADERS.contentLength, contentLength);
                    // if we have content length, we dont use transfer encoding
                    response.removeHeader(constants_1.HTTP_HEADERS.transferEncoding);
                }
                // No need to fetch from the origin in-band
                this.context.useCacheFile = true;
                // ensure that cached responses aren't written back to the cache later
                this.context.bypassCache = true;
                if (result.revalidate && !this.context.cache.isRevalidating(this.context.cacheKey)) {
                    // we set global revalidating status in order to avoid every fetch in the stale time range hit origin
                    this.context.cache.setRevalidating(this.context.cacheKey, true);
                    // revalidate out-of-band if the result is stale and was cached with staleWhileRevalidate
                    this.context.revalidate = true;
                }
                else {
                    this.context.revalidate = false;
                }
                if (result.revalidate) {
                    log_1.default.info(() => `[stale]  ${this.context.summarize()}`);
                }
                else {
                    log_1.default.info(() => `[hit]  ${this.context.summarize()}`);
                }
            }
            else {
                log_1.default.info(() => `[miss] ${this.context.summarize()}`);
            }
        }
    }
    // applies 'client-side' max-age, further controlled by cache_control_header_treatment and expires_header_treatment
    // https://docs.edgecast.com/cdn/Content/HRE/F/External-Max-Age.htm
    applyExternalMaxAge(features) {
        var _a, _b, _c;
        if ((_a = features.caching) === null || _a === void 0 ? void 0 : _a.client_max_age) {
            const response = this.context.getResponse();
            const setHeaders = (headerName, treatment, setHeader) => {
                switch (treatment) {
                    case 'pass':
                        // should pass origin's header only, therefore skipping - expected to be in the response already
                        break;
                    case 'if_missing':
                        !response.getHeader(headerName) && setHeader();
                        break;
                    case 'remove':
                        response.removeHeader(headerName);
                        break;
                    // by default, 'overwrite' value is used
                    default:
                        setHeader();
                }
            };
            const maxAgeSeconds = (0, toSeconds_1.toSeconds)(features.caching.client_max_age);
            setHeaders(constants_1.HTTP_HEADERS.cacheControl, (_b = features.caching) === null || _b === void 0 ? void 0 : _b.cache_control_header_treatment, () => this.context.setResponseHeader({
                [constants_1.HTTP_HEADERS.cacheControl]: `max-age=${maxAgeSeconds}`,
            }));
            setHeaders(constants_1.HTTP_HEADERS.expires, (_c = features.caching) === null || _c === void 0 ? void 0 : _c.expires_header_treatment, () => {
                var _a, _b;
                const cacheState = (_b = (_a = this.context.cache) === null || _a === void 0 ? void 0 : _a.get(this.context.cacheKey)) !== null && _b !== void 0 ? _b : {
                    response: { cachedAt: Date.now() },
                };
                this.context.setResponseHeader({
                    [constants_1.HTTP_HEADERS.expires]: new Date(cacheState.response.cachedAt + maxAgeSeconds * 1000).toUTCString(),
                });
            });
        }
    }
    applyCacheReadFeatures(features) {
        var _a, _b;
        const { caching } = features;
        const request = this.context.getRequest();
        if (!caching) {
            return;
        }
        if (caching.bypass_cache) {
            this.context.bypassCache = true;
        }
        // Request is checked only for no-cache option.
        // Learn more: https://docs.edgecast.com/cdn/Content/HRE/F/Honor-No-Cache-Request.htm
        const reqCacheControl = {
            // Legacy header for HTTP/1.0
            ...(0, cache_control_parser_1.parse)(((_a = request.getHeader('pragma')) === null || _a === void 0 ? void 0 : _a.toString()) || ''),
            // Overrides pragma when both are present
            ...(0, cache_control_parser_1.parse)(((_b = request.getHeader('cache-control')) === null || _b === void 0 ? void 0 : _b.toString()) || ''),
        };
        // Allow to bypass the cache and return fresh response by no-cache option of request
        // only in cases when honor_no_cache_request_header is true to mitigate the impact of many intentional no-cache requests sent to origin.
        // The TCP_CLIENT_REFRESH_MISS debug status code is returned in cases when the cache was updated due to this feature.
        // Learn more: https://docs.edgecast.com/cdn/Content/HRE/F/Honor-No-Cache-Request.htm
        if (reqCacheControl['no-cache'] && caching.honor_no_cache_request_header) {
            this.context.bypassCacheByHonor = true;
        }
        if (caching.cache_key_rewrite) {
            // rewrite the pathname based on a regex
            const { source, destination } = caching.cache_key_rewrite;
            const newDestination = destination ? (0, interpolate_1.default)(destination, this.context) : destination;
            if (source && destination) {
                this.context.cacheKey.pathname = this.context.cacheKey.pathname.replace((0, toRegExp_1.default)(source), newDestination);
            }
            else if (destination) {
                this.context.cacheKey.pathname = newDestination;
            }
        }
        if (caching.cache_key_query_string) {
            // include or exclude specific query params from the cache key
            const { include, include_all_except, exclude_all, include_all } = caching.cache_key_query_string;
            if (include_all_except) {
                for (let param of include_all_except) {
                    delete this.context.cacheKey.query[param];
                }
            }
            if (include) {
                const params = new Set(include);
                for (let param in this.context.cacheKey.query) {
                    if (!params.has(param)) {
                        delete this.context.cacheKey.query[param];
                    }
                }
            }
            if (exclude_all) {
                this.context.cacheKey.query = {};
            }
            if (include_all) {
                this.context.cacheKey.resetQueryParams(this.context.getRequest());
            }
        }
        if (caching.cache_key) {
            const { exclude_all_query_params, include_all_query_params_except, include_all_query_params, include_cookies, include_expressions, include_headers, include_query_params, } = caching.cache_key;
            if (include_headers) {
                this.context.cacheKey.headers = include_headers
                    .map(name => `/header_${name}:%{http_${name}}`)
                    .map(value => (0, interpolate_1.default)(value, this.context));
            }
            if (include_cookies) {
                this.context.cacheKey.cookies = include_cookies
                    .map(name => `/cookie_${name}:%{cookie_${name}}`)
                    .map(value => (0, interpolate_1.default)(value, this.context));
            }
            if (include_expressions) {
                const expressions = include_expressions.map(ex => (0, interpolate_1.default)(ex, this.context)).join(';');
                this.context.cacheKey.expressions = expressions;
            }
            if (include_all_query_params_except) {
                for (let param of include_all_query_params_except) {
                    delete this.context.cacheKey.query[param];
                }
            }
            if (include_query_params) {
                const params = new Set(include_query_params);
                for (let param in this.context.cacheKey.query) {
                    if (!params.has(param)) {
                        delete this.context.cacheKey.query[param];
                    }
                }
            }
            if (include_all_query_params) {
                this.context.cacheKey.resetQueryParams(this.context.getRequest());
            }
            if (exclude_all_query_params) {
                this.context.cacheKey.query = {};
            }
        }
    }
    applyCacheWriteFeatures(features) {
        if (features.caching) {
            const { caching } = this.cachingFeatures;
            // @ts-ignore
            Object.assign(caching, features.caching);
        }
    }
    applyResponseCachingHeaders() {
        var _a, _b, _c, _d, _e;
        const request = this.context.getRequest();
        const response = this.context.getResponse();
        const { caching } = this.cachingFeatures;
        if (!caching || !this.context.cache) {
            return;
        }
        // Don't bother writing the response to the cache if the response came from the cache
        // or bypass_cache feature is set to true.
        // The only exception is when the readCachedResponse was skipped with bypassCacheByHonor.
        // See readCachedResponse above.
        if (this.context.bypassCache) {
            return;
        }
        const getMaxAgeFromExpires = () => {
            const expires = response.getHeader('expires');
            if (expires) {
                return Math.round((new Date(expires).getTime() - new Date().getTime()) / 1000);
            }
            return 0;
        };
        // Returned by origin
        const resCacheControl = {
            // Legacy header for HTTP/1.0
            ...(0, cache_control_parser_1.parse)(((_a = response.getHeader('pragma')) === null || _a === void 0 ? void 0 : _a.toString()) || ''),
            // Overrides pragma when both are present
            ...(0, cache_control_parser_1.parse)(((_b = response.getHeader('cache-control')) === null || _b === void 0 ? void 0 : _b.toString()) || ''),
        };
        const staleWhileRevalidate = this.getStaleWhileRevalidate(resCacheControl);
        // we clear revalidation status, allow additional requests to be made to origin
        staleWhileRevalidate && this.context.cache.setRevalidating(this.context.cacheKey, false);
        const noStore = resCacheControl['no-store'];
        const noCache = resCacheControl['no-cache'];
        const method = request.method.toUpperCase();
        const { enable_caching_for_methods = [], cacheable_status_codes = [], ignore_origin_no_cache, } = caching;
        // Check response cache option
        // Learn more: https://docs.edgecast.com/cdn/Content/HRE/F/Ignore-Origin-No-Cache.htm
        if ((resCacheControl.private || noStore || noCache) && !ignore_origin_no_cache) {
            return this.setCachingStatus(constants_1.CACHING_STATUS.private);
        }
        // ignore caching options based on method if this is GET, as GET is always cached
        if (method !== 'GET' && !enable_caching_for_methods.includes(method)) {
            return this.setCachingStatus(constants_1.CACHING_STATUS.method);
        }
        // ignore caching options based on status code if this is 200, as 200 is always cached
        if (response.statusCode !== 200 &&
            !cacheable_status_codes.includes(((_c = response.statusCode) !== null && _c !== void 0 ? _c : 0))) {
            return this.setCachingStatus(constants_1.CACHING_STATUS.code);
        }
        const ttl = caching.max_age
            ? (0, toSeconds_1.toSeconds)(caching.max_age, response.statusCode)
            : (_e = (_d = resCacheControl['s-maxage']) !== null && _d !== void 0 ? _d : resCacheControl['max-age']) !== null && _e !== void 0 ? _e : getMaxAgeFromExpires();
        if (ttl === 0) {
            return this.setCachingStatus(constants_1.CACHING_STATUS.noMaxAge);
        }
        this.setCachingStatus(constants_1.CACHING_STATUS.cached);
        this.context.cacheConfig = {
            ttl,
            staleWhileRevalidate,
        };
    }
    maybeWriteCachedResponse() {
        const response = this.context.getResponse();
        if (!response.isCachable()) {
            // if response is not cachable, client will still think it is -> its ok, as its done only for large payloads we cant hold in memory cache
            return log_2.default.warn('Response payload is too large - caching skipped.');
        }
        // we prepared cacheConfig before we sent headers back to the client (in order to avoid parsing everything again)
        this.context.cacheConfig &&
            response.isCachable() &&
            this.context.cache.put(this.context.cacheKey, response, this.context.cacheConfig);
    }
    // These headers must be applied AFTER we process upstream headers, therefore its split into different function,
    // otherwise we would be taking things like private, no-cache into consideration, and we wouldnt cache anything.
    maybeApplyAdditionalCachingHeaders() {
        const { caching } = this.cachingFeatures;
        if (caching === null || caching === void 0 ? void 0 : caching.bypass_client_cache) {
            this.context
                .getResponse()
                .setHeader(constants_1.HTTP_HEADERS.cacheControl, 'private, no-cache, no-store, must-revalidate');
        }
        if (caching === null || caching === void 0 ? void 0 : caching.service_worker_max_age) {
            const maxAgeSeconds = (0, toSeconds_1.toSeconds)(caching === null || caching === void 0 ? void 0 : caching.service_worker_max_age);
            this.context.getResponse().setHeader(constants_1.HTTP_HEADERS.xSwCacheControl, `max-age=${maxAgeSeconds}`);
        }
    }
    // https://docs.edgecast.com/cdn/Content/Knowledge_Base/X_EC_Debug.htm
    applyDebugHeaderFeatures(features) {
        var _a, _b, _c, _d, _e;
        if ((_a = features.headers) === null || _a === void 0 ? void 0 : _a.debug_header) {
            const request = this.context.getRequest();
            const response = this.context.getResponse();
            const debugHeader = request.headers[constants_1.HTTP_HEADERS.xEcDebug];
            if (typeof debugHeader === 'string') {
                const debugChecks = debugHeader
                    .replace(/ /g, '')
                    .split(',')
                    .reduce((prev, cur) => {
                    prev[cur] = true;
                    return prev;
                }, {});
                const cachingStatus = response.getHeader(constants_1.HTTP_HEADERS.xEdgeCachingStatus);
                if (debugChecks[constants_1.CACHING_DEBUG_HEADERS.cache]) {
                    let statusCode = constants_1.CACHING_DEBUG_STATUS.uncacheable;
                    if (cachingStatus == constants_1.CACHING_STATUS.hit)
                        statusCode = constants_1.CACHING_DEBUG_STATUS.tcpHit;
                    if (cachingStatus == constants_1.CACHING_STATUS.cached && !this.context.bypassCacheByHonor)
                        statusCode = constants_1.CACHING_DEBUG_STATUS.tcpMiss;
                    if (cachingStatus == constants_1.CACHING_STATUS.cached && this.context.bypassCacheByHonor)
                        statusCode = constants_1.CACHING_DEBUG_STATUS.tcpClientRefreshMiss;
                    response.setHeader(constants_1.CACHING_DEBUG_HEADERS.cache, `${statusCode} from SIMULATOR`);
                }
                if (debugChecks[constants_1.CACHING_DEBUG_HEADERS.cacheKey]) {
                    // ideally, we should change the key representation to match the edge one - see docs above
                    response.setHeader(constants_1.CACHING_DEBUG_HEADERS.cacheKey, this.context.cacheKey.toString());
                }
                if (debugChecks[constants_1.CACHING_DEBUG_HEADERS.cacheState]) {
                    const cacheState = (_c = (_b = this.context.cache) === null || _b === void 0 ? void 0 : _b.get(this.context.cacheKey)) !== null && _c !== void 0 ? _c : {
                        // if we are returning debug headers in streamed message (eg. first chunk), we didn't cache yet, so the delta wont be correct
                        response: { cachedAt: Date.now(), ttl: (_e = (_d = this.context.cacheConfig) === null || _d === void 0 ? void 0 : _d.ttl) !== null && _e !== void 0 ? _e : 0 },
                    };
                    const cacheAge = Math.floor((Date.now() - cacheState.response.cachedAt) / 1000);
                    const remainingTtl = Math.floor(cacheState.response.ttl - cacheAge);
                    let outputState = `max-age=${cacheState.response.ttl} (${(0, toTimeUnitAbbrev_1.toTimeUnitAbbrev)(cacheState.response.ttl)}); `;
                    outputState += `cache-ts=${cacheState.response.cachedAt} (${new Date(cacheState.response.cachedAt).toUTCString()}); `;
                    outputState += `cache-age=${cacheAge} (${(0, toTimeUnitAbbrev_1.toTimeUnitAbbrev)(cacheAge)}); `;
                    outputState += `remaining-ttl=${remainingTtl} (${(0, toTimeUnitAbbrev_1.toTimeUnitAbbrev)(remainingTtl)}); `;
                    // TODO: expires functionality is implemnted -> use it here -> or is it just "inverted" remaining-ttl?
                    outputState += `expires-delta=none;`;
                    response.setHeader(constants_1.CACHING_DEBUG_HEADERS.cacheState, outputState);
                }
                if (debugChecks[constants_1.CACHING_DEBUG_HEADERS.checkCacheable]) {
                    response.setHeader(constants_1.CACHING_DEBUG_HEADERS.checkCacheable, !features.caching || cachingStatus === constants_1.CACHING_STATUS.noMaxAge
                        ? constants_1.CACHING_DEBUG_CACHEABLE.no
                        : constants_1.CACHING_DEBUG_CACHEABLE.yes);
                }
            }
        }
    }
    getStaleWhileRevalidate(cacheControl) {
        const { caching } = this.cachingFeatures;
        /* istanbul ignore else */
        if (caching) {
            if (caching.stale_while_revalidate) {
                return (0, toSeconds_1.toSeconds)(caching.stale_while_revalidate);
            }
            else if (cacheControl['stale-while-revalidate']) {
                return cacheControl['stale-while-revalidate'];
            }
        }
    }
    setCachingStatus(status) {
        this.context.getResponse().setHeader(constants_1.HTTP_HEADERS.xEdgeCachingStatus, status);
    }
    ensureAge() {
        const response = this.context.getResponse();
        response.getHeader('age') || response.setHeader('age', '0');
    }
    toString() {
        return 'ModCache';
    }
}
exports.default = ModCache;
