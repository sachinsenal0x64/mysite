"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const OriginFetcher_1 = __importDefault(require("../OriginFetcher"));
const origins_1 = require("../../origins");
const log_1 = __importDefault(require("../../log"));
/**
 * Emulation of Sailfish's mod_proxy_core
 */
class ModProxyCore extends Mod_1.default {
    async execute(phase) {
        /* istanbul ignore else */
        if (Phase_1.default.SendRequestContent === phase) {
            await this.handleSendRequestContent();
        }
    }
    async handleSendRequestContent() {
        const request = this.context.getRequest();
        const response = this.context.getResponse();
        const originName = this.getOriginName();
        try {
            if (this.context.useCacheFile) {
                log_1.default.trace(`[ModProxyCore] using cached response`);
                return;
            }
            else if (originName === origins_1.SERVERLESS_ORIGIN_NAME &&
                (await this.context.executeServerless())) {
                log_1.default.trace(`[ModProxyCore] using response from Edgio Cloud Function`);
                return;
            }
            else {
                log_1.default.trace(`[ModProxyCore] fetching response from origin: ${originName}`);
                const originConfig = this.context.propertyContext.getOrigin(originName);
                if (!originConfig) {
                    throw new Error(`No origin was found with id=${originName}.`);
                }
                /**
                 * We await the whole response before continuing from this mod, so we can cache it.
                 */
                await new OriginFetcher_1.default(this.context.propertyContext).fetch(request, response, {
                    ignoreUnsatisfiableRanges: this.context.ignoreUnsatisfiableRanges,
                }, 
                // This ensures that the first response will be fetched from this origin.
                // When OriginFetcher is following absolute redirects, different origin may be selected later.
                originName);
            }
        }
        finally {
            // Set the origin response status code on the context so that it can be used when matching response.status_code
            // and catch() in EdgeJS
            this.context.originResponseStatus = response.statusCode;
        }
    }
    /**
     * Returns the origin name set by latest matched set_origin feature
     * or origin extracted from the request path in case no set_origin feature was found.
     */
    getOriginName() {
        // Get default origin for the request based on used host header
        // and configured hostnames.
        let originName = this.context.propertyContext.getDefaultOrigin(this.context.getRequest());
        // Allow to override the origin by set_origin feature
        this.context.forEachMatchingRule(rule => {
            var _a;
            if ((_a = rule === null || rule === void 0 ? void 0 : rule.origin) === null || _a === void 0 ? void 0 : _a.set_origin)
                originName = rule.origin.set_origin;
        });
        return originName;
    }
    toString() {
        return 'ModProxyCore';
    }
}
exports.default = ModProxyCore;
