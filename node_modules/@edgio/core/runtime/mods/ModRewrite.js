"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const url_1 = require("../url");
const interpolate_1 = __importDefault(require("../interpolate"));
const path_1 = require("../../router/path");
const log_1 = __importDefault(require("../../log"));
/**
 * Emulation of Sailfish's mod_rewrite
 */
class ModRewrite extends Mod_1.default {
    async execute(phase) {
        if (phase === Phase_1.default.UriRaw) {
            this.context.forLastMatchingRule(rule => this.applyFeatures(rule, phase));
        }
    }
    applyFeatures(features, _phase) {
        var _a;
        if ((_a = features.url) === null || _a === void 0 ? void 0 : _a.url_rewrite) {
            const request = this.context.getRequest();
            for (let { source, destination, syntax } of features.url.url_rewrite) {
                if (!destination) {
                    throw new Error('url.url_rewrite.destination is required but was not provided.');
                }
                log_1.default.debug(`Rewriting ${source} to ${destination} using ${syntax}`);
                const updatedURL = (0, path_1.mapURL)(request.url, source, (0, interpolate_1.default)(destination, this.context), syntax);
                log_1.default.debug(`Rewritten URL: ${updatedURL}`);
                // When updatedURL is null, it means that the rewrite source didn't match the url.
                // We want to skip this url_rewrite feature in this case.
                if (!updatedURL)
                    continue;
                (0, url_1.setURL)(request, updatedURL);
            }
            return true;
        }
        /*
        Uncomment when we support path_rewrite
        if (features.url?.path_rewrite) {
          const request = this.context.getRequest()
    
          for (let { source, destination, syntax } of features.url.path_rewrite) {
            if (!destination) {
              throw new Error('url.path_rewrite.destination is required but was not provided.')
            }
            setURL(
              request,
              mapPath(request.url, source, interpolate(destination, this.context), syntax)
            )
          }
          return true
        }
        */
        return false;
    }
    toString() {
        return 'ModRewrite';
    }
}
exports.default = ModRewrite;
