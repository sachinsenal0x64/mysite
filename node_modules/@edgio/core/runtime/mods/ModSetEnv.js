"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const EarlyReturn_1 = __importDefault(require("../EarlyReturn"));
/**
 * Emulation of Sailfish's mod_set_env
 */
class ModSetEnv extends Mod_1.default {
    async execute(phase) {
        if (Phase_1.default.UriClean === phase) {
            this.context.forEachMatchingRule(rule => {
                var _a;
                // We need to check for set_done before doing any processing in order to avoid
                // issues stemming from having set_response_body before set_done.
                if ((_a = rule.response) === null || _a === void 0 ? void 0 : _a.set_done) {
                    this.context.returnEarly = true;
                }
            });
        }
        if (Phase_1.default.UriClean === phase ||
            Phase_1.default.SendRequestContent === phase ||
            Phase_1.default.HandleResponseDone === phase ||
            Phase_1.default.HandleResponseHeader === phase) {
            // we need to first run upstream features, as they need to be overwritten by normal features
            this.context.forEachMatchingRule(rule => this.applyUpstreamFeatures(rule, phase));
            // we then apply all headers
            this.context.forEachMatchingRule(rule => this.applyHeaders(rule, phase));
            // applying body is a little more complex, hence the matching is done inside
            this.applyBody(phase);
            // if we return early, we need to first apply everything else before throwing the early return error
            if (this.context.returnEarly && phase !== Phase_1.default.HandleResponseHeader) {
                throw new EarlyReturn_1.default('set_done on response is set to true');
            }
        }
    }
    applyUpstreamFeatures(features, _phase) {
        var _a, _b;
        const response = this.context.getResponse();
        // remove origin response headers immediately after fetching response from origin
        if (_phase === Phase_1.default.HandleResponseHeader) {
            // tohle nebude fungovat, protoze musime nejdriv projet removy, a potom pridat ty sety!...udelam timpadem 2 loopy
            (_b = (_a = features.headers) === null || _a === void 0 ? void 0 : _a.remove_origin_response_headers) === null || _b === void 0 ? void 0 : _b.forEach(header => response.removeHeader(header));
        }
    }
    applyHeaders(features, _phase) {
        var _a, _b, _c, _d, _e, _f, _g;
        const response = this.context.getResponse();
        // only process request before sending to origin
        if (_phase === Phase_1.default.UriClean) {
            ((_a = features.headers) === null || _a === void 0 ? void 0 : _a.set_request_headers) &&
                this.context.setRequestHeader(features.headers.set_request_headers);
        }
        // only process features if :
        //    - processing header,
        //    - not making request because of set_done
        //    - not making request because of the use of cached file
        if (_phase === Phase_1.default.HandleResponseHeader ||
            (_phase === Phase_1.default.HandleResponseDone && this.context.followRedirects) ||
            this.context.returnEarly ||
            this.context.useCacheFile) {
            ((_b = features.headers) === null || _b === void 0 ? void 0 : _b.set_response_headers) &&
                this.context.setResponseHeader(features.headers.set_response_headers);
            ((_c = features.headers) === null || _c === void 0 ? void 0 : _c.add_response_headers) &&
                this.context.setResponseHeader((_d = features.headers) === null || _d === void 0 ? void 0 : _d.add_response_headers, true);
            (_f = (_e = features.headers) === null || _e === void 0 ? void 0 : _e.remove_response_headers) === null || _f === void 0 ? void 0 : _f.forEach(header => response.removeHeader(header));
            if ((_g = features.response) === null || _g === void 0 ? void 0 : _g.set_status_code)
                response.statusCode = features.response.set_status_code;
        }
        if (features.set_variables) {
            Object.entries(features.set_variables).forEach(([name, value]) => {
                this.context.variables[name] = value;
            });
        }
    }
    applyBody(_phase) {
        const response = this.context.getResponse();
        // only send response if processing response from origin, or if exiting early through set_done feature
        if (_phase === Phase_1.default.SendRequestContent || this.context.returnEarly) {
            let responseBody;
            // we first find the potential set_response_body
            this.context.forEachMatchingRule(features => {
                var _a, _b;
                if ((_a = features.response) === null || _a === void 0 ? void 0 : _a.set_response_body) {
                    responseBody = (_b = features.response) === null || _b === void 0 ? void 0 : _b.set_response_body;
                }
            });
            if (responseBody) {
                // we replace chunks to be streamed back after the whole chain completes
                response.clear();
                response.write(responseBody);
                response.end();
            }
            else if (_phase !== Phase_1.default.SendRequestContent) {
                // if set_response_body isn't set, we still need to end the response to avoid hanging in case of early return
                response.clear();
                response.end();
            }
        }
    }
    toString() {
        return 'ModSetEnv';
    }
}
exports.default = ModSetEnv;
