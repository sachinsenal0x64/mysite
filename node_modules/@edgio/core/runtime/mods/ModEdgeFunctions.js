"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const environment_1 = require("../../environment");
const Mod_1 = __importDefault(require("./Mod"));
const EdgeFunctionsManager_1 = __importDefault(require("../edge-functions/EdgeFunctionsManager"));
const log_1 = __importDefault(require("../../log"));
const HandlerFinished_1 = __importDefault(require("../HandlerFinished"));
const constants_1 = require("../../constants");
const interpolate_1 = require("../interpolate");
class ModEdgeFunctions extends Mod_1.default {
    async execute(phase) {
        if (this.context.useCacheFile) {
            // Will get here if the response was found in the cache. In this case we should
            // not run any edge functions.
            return;
        }
        const edgeFunctions = [];
        // find all configured edge functions
        this.context.forEachMatchingRule(rule => {
            if (rule.edge_function) {
                edgeFunctions.push(rule.edge_function);
            }
        });
        // run each edge function
        for (let edgeFunction of edgeFunctions) {
            try {
                const result = await this.run(edgeFunction, phase);
                if (result.statusCode) {
                    const response = this.context.getResponse();
                    response.statusCode = result.statusCode;
                    response.statusMessage = result.statusMessage;
                    const headers = result.headers.headers();
                    const keys = Object.keys(headers);
                    for (let i = 0; i < keys.length; i++) {
                        const name = keys[i];
                        const value = headers[name];
                        response.setHeader(name, value);
                    }
                    result.body && response.write(result.body);
                    response.end();
                }
                else {
                    // Where there is an exception or response object was not returned, respond with a 534 "Project Error"
                    this.set534Response('The edge function must return a valid Response object on completion.');
                }
            }
            catch (e) {
                // Unhandled exception in the edge function are caught by quickjs-wasm/quickjs-runtime/src/lib.rs at
                // this point in the CLI there is no additional information. Must match message returned by SailFish.
                this.set534Response(`${e.message}`);
            }
            throw new HandlerFinished_1.default('done with edge function');
        }
    }
    set534Response(msg) {
        const response = this.context.getResponse();
        response.statusCode = 534;
        response.statusMessage = 'Project Error';
        if ((0, environment_1.isCloud)()) {
            // Do not inclide the full stack trace when running in the cloud
            response.write(`Project Error in edge function`);
        }
        else {
            response.write(`Edge function failed: ${msg}`); // must match SailFish)
            log_1.default.error(msg);
        }
        response.end();
    }
    /**
     * Runs the specified edge function.
     * @param edgeFunction
     */
    async run(edgeFunctionPath, phase) {
        var _a;
        const bytecode_base64 = (_a = this.context.edgeFunctions) === null || _a === void 0 ? void 0 : _a.quickjs_bytecode_base64;
        if (!bytecode_base64) {
            throw new Error('Edge function bytecode not found');
        }
        const bytecode = Buffer.from(bytecode_base64, 'base64');
        // Copy the user's 'set_variables:' from the router to the usrVarMap
        let usrVarMap = new Map();
        for (const key in this.context.variables) {
            usrVarMap.set(key, this.context.variables[key]);
        }
        // Set path, bytecode into the sysVarMap
        let sysVarMap = new Map();
        sysVarMap.set(constants_1.EDGIO_EDGE_FUNCTION_ENV_VARIABLES.path, edgeFunctionPath);
        sysVarMap.set(constants_1.EDGIO_EDGE_FUNCTION_ENV_VARIABLES.quickjsBytecodeBase64, bytecode);
        // Set local environmnet variables into envVarMap
        let envVarMap = new Map();
        for (const key in process.env) {
            envVarMap.set(key, process.env[key]);
        }
        // Copy the edgio.config.js `interpolationValues:` into the httpVarMap
        let httpVarMap = new Map();
        let interpolationValues = (0, interpolate_1.extractInterpolationValues)(this.context);
        for (const key in interpolationValues) {
            if (key.startsWith('geo_') || key.startsWith('virt_') || key.startsWith('wurfl_')) {
                httpVarMap.set(key, interpolationValues[key]);
            }
        }
        return await EdgeFunctionsManager_1.default.instance().runEdgeFunction(this.context, edgeFunctionPath, sysVarMap, envVarMap, usrVarMap, httpVarMap, this.context.getRequest().rawBody);
    }
    toString() {
        return 'ModEdgeFunctions';
    }
}
exports.default = ModEdgeFunctions;
