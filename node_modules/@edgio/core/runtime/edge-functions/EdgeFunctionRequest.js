"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionHeaders_1 = __importDefault(require("./EdgeFunctionHeaders"));
const WasmProgram_1 = require("./WasmProgram");
class EdgeFunctionRequest {
    static createFromEdgeFunctionParams(params) {
        const request = params.request;
        const edgeRequest = EdgeFunctionRequest.createFromMethodAndUrl(request.method, request.url);
        edgeRequest.rawBody = request.rawBody;
        edgeRequest.httpVersion = request.httpVersion;
        edgeRequest.headers = new EdgeFunctionHeaders_1.default(request.rawHeaders);
        return edgeRequest;
    }
    static createFromMethodAndUrl(method, url) {
        return new EdgeFunctionRequest(method, url);
    }
    static createFromRequest(request) {
        const clone_request = new EdgeFunctionRequest(request.method, request.url);
        clone_request.headers = new EdgeFunctionHeaders_1.default(request.getHeaders());
        return clone_request;
    }
    /**
     * Creates a new EdgeFunctionRequest out of any object that fulfils basic interface of a generalized Request.
     */
    constructor(method, url) {
        this.method = 'GET';
        this.rawBody = undefined;
        this.protocol = 'http';
        this.headers = new EdgeFunctionHeaders_1.default({});
        this.method = method;
        this.url = url;
        const urlObject = new URL(url);
        this.path = urlObject.pathname;
        // Neither protocol nor creating host header is what Chrome does.
        // TODO: Figure out what do we want to do.
        this.protocol = urlObject.protocol.replace(':', '');
        this.headers = new EdgeFunctionHeaders_1.default({ host: urlObject.hostname });
        this.fetchCalled = false;
        this.fetchTimeout = 0;
    }
    appendHeader(name, value) {
        this.headers.append(name, value);
    }
    getHeader(name) {
        return this.headers.get(name);
    }
    getHeaderNameByIdx(idx) {
        return this.headers.key(idx);
    }
    getHeaders() {
        return this.headers.headers();
    }
    setHeader(name, value) {
        this.headers.set(name, value);
    }
    removeHeader(name) {
        return this.headers.remove(name);
    }
    // Reads the body chunk. Returns an undefined if the data cannot be read.
    readBodyChunk(chunkOffset, maxChunkSize) {
        if (chunkOffset < 0) {
            throw new Error('chunkOffset must be greater than or equal to 0');
        }
        if (maxChunkSize <= 0) {
            throw new Error('maxChunkSize must be greater than 0');
        }
        if (!this.rawBody) {
            return undefined;
        }
        if (chunkOffset >= this.rawBody.byteLength) {
            return undefined;
        }
        const bytesToRead = Math.min(maxChunkSize, this.rawBody.byteLength - chunkOffset);
        const chunk = this.rawBody.slice(chunkOffset, chunkOffset + bytesToRead);
        return chunk;
    }
    // Connascence of algorithm with Sailfish mod_wasm request.cc (impl_req_set_uri).
    static validate_uri(uri) {
        // This value is used by Sailfish to limit the length of the request line (method+path+version)
        // in msghdr_parser. This defaults to 64*1024 in the Sailfish server_config class, but it's
        // configurable via SF config, so this could diverge from the real value used in production Sailfish.
        const MAX_HEADER_BYTES = 64 * 1024;
        if (uri.length > MAX_HEADER_BYTES) {
            // Attempt to match the same URI limit used in Sailfish msghdr_parser::parse_header.
            // This doesn't perfectly reproduce the behavior, as the the msghdr_parser limits the
            // complete request line (HTTP method, path, and version) to be <= max_header_bytes.
            return new WasmProgram_1.WasmError(WasmProgram_1.wasm_status.limit_exceeded, `URI length is too long (length ${uri.length} > ${MAX_HEADER_BYTES})`);
        }
        if (!uri.startsWith('http') && !uri.startsWith('/')) {
            return new WasmProgram_1.WasmError(WasmProgram_1.wasm_status.invalid_argument, 'Invalid request uri');
        }
        return WasmProgram_1.WasmError.ok();
    }
}
exports.default = EdgeFunctionRequest;
