"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Worker_1 = require("./Worker");
const Serializer_1 = require("./Serializer");
const buffer_1 = require("buffer");
const EdgeFunction_1 = __importDefault(require("./EdgeFunction"));
const EdgeFunctionError_1 = __importDefault(require("./EdgeFunctionError"));
class EdgeFunctionParentInterface {
    constructor() {
        this.started = false;
        this.port = Worker_1.parentPort;
        this.workerData = undefined;
    }
    startListening() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.port.onmessage = async (event) => {
            const message = event.data;
            const { command } = message;
            // Here we receive the workerData sent by EdgeFunctionsManager
            if (command === 'init') {
                this.workerData = message.workerData;
                return;
            }
            // Skip all messages until we receive the workerData
            if (!this.workerData)
                return;
            if (command === 'run') {
                // Dedicated worker message channel port cannot be transferred
                // via the workerData, so we have to send it separately.
                this.port = message.port;
                try {
                    const fun = new EdgeFunction_1.default(this, this.workerData.params);
                    const response = await fun.run(message.wasmInitialMemory);
                    if (response === EdgeFunctionError_1.default.ErrorRunning) {
                        // This catches exceptions in the edge function.
                        this.port.postMessage(['done-exception', fun.getPanicString()]);
                    }
                    else {
                        this.port.postMessage(['done-response', response]);
                    }
                }
                catch (e) {
                    // This catches exceptions in the TypeScript.
                    this.port.postMessage(['done-error', e]);
                }
                return;
            }
            throw new Error(`Unknown command: ${command}`);
        };
    }
    fetchAsync(requestId, ...args) {
        this.port.postMessage(['fetch', requestId, ...args]);
    }
    writeToStdout(buffer) {
        this.port.postMessage(['stdout', buffer]);
    }
    writeToStderr(buffer) {
        this.port.postMessage(['stderr', buffer]);
    }
    writeWasmInitialMemory(buffer) {
        this.port.postMessage(['wasmInitialMemory', buffer]);
    }
    clearWasmInitialMemory() {
        this.port.postMessage(['wasmClearMemory']);
    }
    writeToDebugStream(buffer) {
        this.port.postMessage(['debug', buffer]);
    }
    waitNextReadyResponseSync() {
        var _a, _b;
        if (!this.workerData)
            return null;
        const { semaphore, exchangeBuffer, dataLength } = this.workerData;
        // Signal to the parent that we are about to start waiting.
        this.port.postMessage(['waiting']);
        this.writeToDebugStream(buffer_1.Buffer.from('Block until the next response is ready...'));
        // Reset the waited on semaphore so that we are guaranteed a wait.
        // This will give time for the parent to get the message and process it.
        Atomics.store(semaphore, 0, 0);
        // Wait on the semaphore to change through the action of the parent.
        Atomics.wait(semaphore, 0, 0);
        this.writeToDebugStream(buffer_1.Buffer.from('A new response is ready...'));
        // Deserialize the data from the exchange buffer.
        const length = dataLength[0];
        const deserializedData = Serializer_1.Serializer.deserialize(buffer_1.Buffer.from(exchangeBuffer, 0, length));
        // Reinstate the body buffer as a Buffer object.
        if ((_a = deserializedData.response) === null || _a === void 0 ? void 0 : _a.body) {
            deserializedData.response.body = buffer_1.Buffer.from((_b = deserializedData.response) === null || _b === void 0 ? void 0 : _b.body);
        }
        return deserializedData;
    }
    get path() {
        var _a, _b;
        return (_b = (_a = this.workerData) === null || _a === void 0 ? void 0 : _a.params.path) !== null && _b !== void 0 ? _b : 'Unknown';
    }
}
exports.default = EdgeFunctionParentInterface;
