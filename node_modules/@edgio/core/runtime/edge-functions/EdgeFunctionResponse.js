"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionHeaders_1 = __importDefault(require("./EdgeFunctionHeaders"));
const buffer_1 = require("buffer");
class EdgeFunctionResponse {
    /**
     * Creates a new EdgeFunctionResponse out of any object that fulfils basic interface of a generalized Response.
     */
    constructor({ statusCode, statusMessage, body, headers, }) {
        this.statusCode = statusCode || 0; // Connascence of the value in Sailfish. See http_message.h
        this.statusMessage = statusMessage;
        if (buffer_1.Buffer.isBuffer(body) || typeof body === 'string' || body instanceof Uint8Array) {
            // Subtle issue here. We must copy the body because the buffer that the response
            // arrived in is shared by the parent/worker threads and v8.deserialize does shallow copy on buffers.
            // Hence if we don't copy it, this body will be overwritten by the next response that comes in.
            // body can be overwritten by the next response that comes in.
            this.body = buffer_1.Buffer.from(body);
        }
        this.headers = new EdgeFunctionHeaders_1.default(headers);
        this.responseReturned = false;
    }
    // Reads the body chunk. Returns an undefined if the data cannot be read.
    readBodyChunk(chunkOffset, maxChunkSize) {
        if (chunkOffset < 0) {
            throw new Error('chunkOffset must be greater than or equal to 0');
        }
        if (maxChunkSize <= 0) {
            throw new Error('maxChunkSize must be greater than 0');
        }
        if (!this.body) {
            return undefined;
        }
        if (chunkOffset >= this.body.byteLength) {
            return undefined;
        }
        const bytesToRead = Math.min(maxChunkSize, this.body.byteLength - chunkOffset);
        const chunk = this.body.slice(chunkOffset, chunkOffset + bytesToRead);
        return chunk;
    }
    static createFromResponse(response) {
        const clone_response = new EdgeFunctionResponse({
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            body: '',
            headers: response.headers.headers(),
        });
        return clone_response;
    }
}
exports.default = EdgeFunctionResponse;
