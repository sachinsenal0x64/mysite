"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const EdgeFunctionMetrics_1 = __importDefault(require("./EdgeFunctionMetrics"));
const EdgeFunctionReason_1 = __importDefault(require("./EdgeFunctionReason"));
const EdgeFunctionRequest_1 = __importDefault(require("./EdgeFunctionRequest"));
const EdgeFunctionResponse_1 = __importDefault(require("./EdgeFunctionResponse"));
const EdgeFunctionError_1 = __importDefault(require("./EdgeFunctionError"));
const EdgeFunctionHeaders_1 = __importDefault(require("./EdgeFunctionHeaders"));
const EdgeFunctionsWasmManager_1 = __importDefault(require("./EdgeFunctionsWasmManager"));
const EdgeFunctionFetchError_1 = require("./EdgeFunctionFetchError");
const WasmProgram_1 = __importStar(require("./WasmProgram"));
const decodeBase64Validated_1 = __importDefault(require("../../utils/decodeBase64Validated"));
const buffer_1 = require("buffer");
const EdgeFunctionFetchError_2 = __importDefault(require("./EdgeFunctionFetchError"));
// Valid methods supported by Sailfish. A subset of http/http_method.cc
const validMethods = [
    'CONNECT',
    'DELETE',
    'GET',
    'HEAD',
    'OPTIONS',
    'PATCH',
    'POST',
    'PURGE',
    'PUT',
    'TRACE',
];
// Dictionary namespaces used here, in sailfish and sdk.js
const ENV_VAR_NAMESPACE_EDGIO_CONFIG = 'edgio-config';
const ENV_VAR_NAMESPACE_EDGIO_ORIGINS = 'edgio-origins';
const ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR = 'edgio-property-environment-variables';
const ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS = 'edgio-feature-flags';
const ENV_VAR_NAMESPACE_EDGIO_USRVAR = 'edgio-usrvar';
const ENV_VAR_NAMESPACE_EDGIO_GEO = 'edgio-geo';
const ENV_VAR_NAMESPACE_EDGIO_WURFL = 'edgio-wurfl';
const ENV_VAR_NAMESPACE_EDGIO_VIRT = 'edgio-virt';
const SAILFISH_TO_CLI_FEATURE_FLAGS = ['metrics-text-encoding'];
// Constants used to limit the stdout and stderror output from the guest.
const overflow_message = '<truncated>';
const MAX_OUT_BYTES = 2048; // should be same as value in mod_wasm_pconf.cc
const MAX_PANIC_BYTES = 512; // should be same as value in mod_wasm_pconf.cc
const MAX_HEADER_BYTES = 128 * 1024; // should be same as value in mod_wasm_pconf.cc
const HTTP_HEADER_DELIMITER_BYTES = 4; // HTTP headers include ": \r\n" for each header
const MAX_CREATED_REQUESTS = 10; // should be same as value in mod_wasm_pconf.cc
const MAX_CREATED_RESPONSES = 10; // should be same as value in mod_wasm_pconf.cc
const MAX_ISSUED_REQUESTS = 5; // should be same as value in mod_wasm_pconf.cc
// Small helper functions for handling dictionary hostcalls that
// access the http vars and need to be separated into categories.
function isHttpVarNameSpace(ns) {
    return (ns === ENV_VAR_NAMESPACE_EDGIO_GEO ||
        ns === ENV_VAR_NAMESPACE_EDGIO_VIRT ||
        ns === ENV_VAR_NAMESPACE_EDGIO_WURFL);
}
function getHttpVarPrefix(ns) {
    if (ns === ENV_VAR_NAMESPACE_EDGIO_GEO)
        return 'geo_';
    if (ns === ENV_VAR_NAMESPACE_EDGIO_VIRT)
        return 'virt_';
    if (ns === ENV_VAR_NAMESPACE_EDGIO_WURFL)
        return 'wurfl_';
    return '';
}
function httpVarPrefixedKey(ns, key) {
    return getHttpVarPrefix(ns) + key;
}
/// Encapsulates the execution of JavaScript edge functions by leveraging
/// the QuickJS WASM runtime function.
class EdgeFunction extends WasmProgram_1.default {
    /// Constructs a new EdgeFunction instance for the given parent and parameters.
    constructor(parent, params) {
        super();
        this.response = new EdgeFunctionResponse_1.default({});
        this.metrics = new EdgeFunctionMetrics_1.default();
        // In Sailfish, the request and response IDs are used to identify the request and response.
        // In our case here, we only have one downstream request and response objects per EdgeFunction
        // instance so we can use any ID as long as it's stable. Any upstream requests coming out of
        // the edge function will have their own IDs following these "base" IDs.
        this.DOWNSTREAM_REQUEST_ID = 0;
        // TODO: Response ID is returned by edge function, this const should not be necessary
        this.DOWNSTREAM_RESPONSE_ID = 0;
        this.params = params;
        this.parent = parent;
        this.stdout_written_bytes = 0;
        this.stderr_written_bytes = 0;
    }
    /// Singleton function managing the lifetime of the QuickJs Core WASM function
    static async getQuickJsCore() {
        if (!EdgeFunction.QuickJsModule) {
            // Load the WASM QuickJS runtime once per lifetime of the instance.
            // The WASM QuickJS runtime is a WASM module that contains the QuickJS interpreter
            // and our code that implements the JavaScript API available to the end users.
            // It is built from Sailfish repository, mod_wasm sources, and not checked in.
            const wasmBytes = await EdgeFunctionsWasmManager_1.default.getQuickjsRuntimeBytes();
            EdgeFunction.QuickJsModule = new WebAssembly.Module(wasmBytes);
        }
        return EdgeFunction.QuickJsModule;
    }
    getPanicString() {
        return this.panicString || this.guestErrorMessage || 'No stack information available.';
    }
    async run(wasmInitialMemory) {
        const module = await EdgeFunction.getQuickJsCore();
        const importObject = this.getQuickJsImportObject();
        const instance = new WebAssembly.Instance(module, importObject);
        this.setInstance(instance);
        if (wasmInitialMemory === undefined) {
            // On cold start, call the init function and save the initial memory state.
            // @ts-ignore
            this.instance.exports.runtime_init();
            const mem = buffer_1.Buffer.from(this.getGuestMemory().slice(0));
            this.parent.writeWasmInitialMemory(mem);
        }
        else {
            // On warm start, skip the init function, grow the memory if needed
            // and restore the initial memory state.
            const memBytes = this.getGuestMemory().getByteLength();
            if (wasmInitialMemory.byteLength > memBytes) {
                const pagesToAdd = Math.ceil((wasmInitialMemory.byteLength - memBytes) / (64 * 1024));
                // @ts-ignore
                this.instance.exports.memory.grow(pagesToAdd);
            }
            this.restoreGuestMemory(wasmInitialMemory);
        }
        // TODO: Response ID is returned by edge function return statement, the 2nd parameter should not be necessary
        // `run` is the entry point of the WASM module.
        // Please consult the Sailfish repository for the implementation of the `run` function.
        // status = 0 OK, status = 2 exception, see quickjs-wasm/quickjs-runtime/src/lib.rs for values
        // @ts-ignore
        const status = this.instance.exports.run(this.DOWNSTREAM_REQUEST_ID, this.DOWNSTREAM_RESPONSE_ID);
        if (status !== EdgeFunctionError_1.default.Ok) {
            this.funDebug('EdgeFunction.run() threw exception');
            return status;
        }
        this.metrics.write(this.funDebug.bind(this));
        // If the downstream request was a HEAD, remove the body from the response.
        // This is done here (after the edge function has fully executed) in order
        // to match the behavior of mod_wasm.
        if (this.params.request.method == 'HEAD') {
            this.response.body = buffer_1.Buffer.from('');
        }
        this.funDebug('EdgeFunction.run() finished with status code', this.response.statusCode);
        return this.response;
    }
    funDebug(...args) {
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (buffer_1.Buffer.isBuffer(arg)) {
                this.parent.writeToDebugStream(arg);
            }
            else if (typeof (arg === null || arg === void 0 ? void 0 : arg.toString) === 'function') {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(arg.toString()));
            }
            else if (typeof arg === 'undefined') {
                this.parent.writeToDebugStream(buffer_1.Buffer.from('undefined'));
            }
            else {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(`[unhandled type ${typeof arg}]`));
            }
            if (i < args.length - 1) {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(' '));
            }
        }
        this.parent.writeToDebugStream(buffer_1.Buffer.from('\n'));
    }
    /// Creates a buffer of uint32 string lengths to be passed to copyDataToGuestMemory().
    stringLengthsToBuffer(values) {
        const uint32Size = 4;
        const itemCount = values.length;
        const arr = new ArrayBuffer(uint32Size * itemCount);
        const view = new DataView(arr);
        for (let i = 0; i < itemCount; i++) {
            view.setUint32(i * uint32Size, values[i].length, true); // true = little endian for Intel x86
        }
        return buffer_1.Buffer.from(new Uint8Array(arr));
    }
    /// Returns the import object for the QuickJS WASM function which includes both WASI
    /// interface and custom hostcalls as defined in the Sailfish repository.
    getQuickJsImportObject() {
        // Set of all the requests that the edge function has access to.
        let requests = new Map();
        requests.set(this.DOWNSTREAM_REQUEST_ID, EdgeFunctionRequest_1.default.createFromEdgeFunctionParams(this.params));
        // Next upstream request IDs start from the ID after the base "downstream" request ID.
        let nextUpstreamRequestId = this.DOWNSTREAM_REQUEST_ID + 1;
        let requestsIssued = 0;
        let responses = new Map();
        // TODO: Response ID is returned by edge function, this empty response should not be necessary
        responses.set(this.DOWNSTREAM_RESPONSE_ID, this.response);
        // Next response IDs start from the ID after the base "downstream" response ID.
        let nextResponseId = this.DOWNSTREAM_RESPONSE_ID + 1;
        const getRequest = (id) => {
            const request = requests.get(id);
            if (!request) {
                return {
                    status: WasmProgram_1.wasm_status.invalid_id,
                    message: `Invalid response ID provided ${id}`,
                };
            }
            return request;
        };
        const getResponse = (id) => {
            const response = responses.get(id);
            if (!response) {
                return {
                    status: WasmProgram_1.wasm_status.invalid_id,
                    message: `Invalid response ID provided ${id}`,
                };
            }
            return response;
        };
        // Create "constant" timestamp returned by clock_time_get()
        const startTimeNs = BigInt(Date.now() * 1000000);
        const handleWasmError = (error) => {
            this.lastHostErrorMessage = error.message;
            return error.status;
        };
        return {
            env: {
                hostcall_get_last_host_error_message: (message_offset, message_len) => {
                    if (!this.lastHostErrorMessage) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return this.setStringInGuestMemory(message_offset, message_len, this.lastHostErrorMessage);
                },
                hostcall_set_guest_error_message: (message_offset, message_len) => {
                    const memory = this.getGuestMemory();
                    this.guestErrorMessage = this.getStringFromGuestMemoryTruncate(memory, message_offset, message_len);
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_dict_check: (ns_offset, ns_len, name_offset, name_len) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                    if (name instanceof WasmProgram_1.WasmError)
                        return handleWasmError(name);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        if (this.params.usrVars.has(name.toLowerCase()))
                            return WasmProgram_1.wasm_status.ok;
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Handle the edgio-geo, wurfl or virt namespace
                    if (isHttpVarNameSpace(ns)) {
                        if (this.params.httpVars.has(httpVarPrefixedKey(ns, name)))
                            return WasmProgram_1.wasm_status.ok;
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS) {
                        return SAILFISH_TO_CLI_FEATURE_FLAGS.indexOf(name) >= 0
                            ? WasmProgram_1.wasm_status.ok
                            : WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        // Hide quickjsBytecodeBase64 from the users because it is very big.
                        return this.params.sysVars.has(name) &&
                            name !== constants_1.EDGIO_EDGE_FUNCTION_ENV_VARIABLES.quickjsBytecodeBase64
                            ? WasmProgram_1.wasm_status.ok
                            : WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR) {
                        return this.params.envVars.has(name) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_dict_get: (ns_offset, ns_len, name_offset, name_len, value_offset, value_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    let name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                    if (name instanceof WasmProgram_1.WasmError)
                        return handleWasmError(name);
                    let dict;
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        name = name.toLowerCase();
                        dict = this.params.usrVars;
                    }
                    else if (ns === ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS) {
                        if (SAILFISH_TO_CLI_FEATURE_FLAGS.indexOf(name) >= 0) {
                            return this.setStringInGuestMemory(value_offset, value_len_offset, name);
                        }
                        else {
                            return WasmProgram_1.wasm_status.not_found;
                        }
                    }
                    else if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        dict = this.params.sysVars;
                        // hostcall_dict_get(quickjsBytecodeBase64) is necessary for wasm to fetch the bytecode.
                    }
                    else if (ns === ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR) {
                        dict = this.params.envVars;
                    }
                    else if (isHttpVarNameSpace(ns)) {
                        // Handle the edgio-geo, wurfl or virt namespace
                        name = httpVarPrefixedKey(ns, name);
                        dict = this.params.httpVars;
                    }
                    else {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.not_found,
                            message: `Namespace ${ns} does not exist`,
                        });
                    }
                    if (!dict.has(name))
                        return WasmProgram_1.wasm_status.not_found;
                    const value = dict.get(name);
                    if (value instanceof Uint8Array) {
                        return this.copyDataToGuestMemory(value, value_offset, value_len_offset);
                    }
                    else {
                        return this.setStringInGuestMemory(value_offset, value_len_offset, value);
                    }
                },
                hostcall_dict_get_base64_decoded: (ns_offset, ns_len, name_offset, name_len, value_offset, value_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                        if (name instanceof WasmProgram_1.WasmError)
                            return handleWasmError(name);
                        // Hide quickjsBytecodeBase64 from the users because it is very big.
                        if (this.params.sysVars.has(name) &&
                            name !== constants_1.EDGIO_EDGE_FUNCTION_ENV_VARIABLES.quickjsBytecodeBase64) {
                            const sysVarValue = this.params.sysVars.get(name);
                            if (typeof sysVarValue !== 'string') {
                                return handleWasmError({
                                    status: WasmProgram_1.wasm_status.invalid_argument,
                                    message: `Dictionary value must be a string:  ${typeof sysVarValue}`,
                                });
                            }
                            // Attempt to (validate) and decode, then write to guest.
                            try {
                                let decodedValue = (0, decodeBase64Validated_1.default)(sysVarValue);
                                return this.copyDataToGuestMemory(decodedValue, value_offset, value_len_offset);
                            }
                            catch (e) {
                                return handleWasmError({
                                    status: WasmProgram_1.wasm_status.invalid_argument,
                                    message: `Failed to decode value as base64: ${sysVarValue}`,
                                });
                            }
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_dict_get_key_by_idx: (ns_offset, ns_len, idx, key_offset, key_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        const usrVarsCount = Array.from(this.params.usrVars.keys()).length;
                        if (idx < usrVarsCount) {
                            let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, Array.from(this.params.usrVars.keys())[idx]);
                            return writeResult;
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Handle the edgio-geo, wurfl or virt namespace
                    if (isHttpVarNameSpace(ns)) {
                        // Since we split the http_vars into separate categories when we iterate through the
                        //  map, only count the keys with the correct namespace prefix.
                        const prefix = getHttpVarPrefix(ns);
                        for (let [key] of this.params.httpVars.entries()) {
                            if (key.startsWith(prefix)) {
                                if (idx-- === 0) {
                                    const unprefixed_key = key.substring(prefix.length);
                                    let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, unprefixed_key);
                                    return writeResult;
                                }
                            }
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS) {
                        const featureLength = SAILFISH_TO_CLI_FEATURE_FLAGS.length;
                        if (idx < featureLength) {
                            let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, SAILFISH_TO_CLI_FEATURE_FLAGS[idx]);
                            return writeResult;
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        for (let [key] of this.params.sysVars.entries()) {
                            // Hide quickjsBytecodeBase64 from the users because it is very big.
                            if (key !== constants_1.EDGIO_EDGE_FUNCTION_ENV_VARIABLES.quickjsBytecodeBase64) {
                                if (idx-- === 0) {
                                    let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, key);
                                    return writeResult;
                                }
                            }
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR) {
                        const envVarsCount = Array.from(this.params.envVars.keys()).length;
                        if (idx < envVarsCount) {
                            let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, Array.from(this.params.envVars.keys())[idx]);
                            return writeResult;
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_unique_set_check: (ns_offset, ns_len, name_offset, name_len) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    // Connascence of algorithm with the `hostcall_dict_check` function in the Sailfish.
                    if (ns !== ENV_VAR_NAMESPACE_EDGIO_ORIGINS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.not_found,
                            message: `Namespace ${ns} does not exist`,
                        });
                    }
                    const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                    if (name instanceof WasmProgram_1.WasmError)
                        return handleWasmError(name);
                    return this.params.origins.find(x => x.name === name) !== undefined
                        ? WasmProgram_1.wasm_status.ok
                        : WasmProgram_1.wasm_status.not_found;
                },
                hostcall_unique_set_get_key_by_idx: (ns_offset, ns_len, idx, key_offset, key_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns instanceof WasmProgram_1.WasmError)
                        return handleWasmError(ns);
                    // Connascence of algorithm with the `hostcall_unique_set_get_key_by_idx` function in the Sailfish.
                    if (ns !== ENV_VAR_NAMESPACE_EDGIO_ORIGINS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.not_found,
                            message: `Namespace ${ns} does not exist`,
                        });
                    }
                    const origins = this.params.origins;
                    if (idx < origins.length) {
                        let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, origins[idx].name || `Undefined origin name at index ${idx}`);
                        return writeResult;
                    }
                    return WasmProgram_1.wasm_status.not_found;
                },
                // Create a request object
                hostcall_req_create: (method_offset, method_len, url_offset, url_len, req_id_offset) => {
                    // Only allow up to MAX_CREATED_REQUESTS per execution. Since we start counting at 1, we check with >.
                    if (nextUpstreamRequestId > MAX_CREATED_REQUESTS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Maximum number of requests (${MAX_CREATED_REQUESTS}) created per execution exceeded`,
                        });
                    }
                    const memory = this.getGuestMemory();
                    const method = this.getStringFromGuestMemory(memory, method_offset, method_len);
                    if (method instanceof WasmProgram_1.WasmError)
                        return handleWasmError(method);
                    const url = this.getStringFromGuestMemory(memory, url_offset, url_len);
                    if (url instanceof WasmProgram_1.WasmError)
                        return handleWasmError(url);
                    const uri_validate_result = EdgeFunctionRequest_1.default.validate_uri(url);
                    if (uri_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(uri_validate_result);
                    }
                    // Create new request object.
                    const request = EdgeFunctionRequest_1.default.createFromMethodAndUrl(method, url);
                    const id = nextUpstreamRequestId++;
                    memory.setUint32(req_id_offset, id);
                    requests.set(id, request);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Clone request object
                hostcall_req_clone_without_body: (id, clone_id_offset) => {
                    const memory = this.getGuestMemory();
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const clone_request = EdgeFunctionRequest_1.default.createFromRequest(request);
                    const clone_id = nextUpstreamRequestId++;
                    memory.setUint32(clone_id_offset, clone_id);
                    requests.set(clone_id, clone_request);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Create a response object with status code
                hostcall_resp_create: (status, resp_id_offset) => {
                    // Only allow up to MAX_CREATED_RESPONSES per execution. Since we start counting at 1, we check with >.
                    if (nextResponseId > MAX_CREATED_RESPONSES) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Maximum number of responses (${MAX_CREATED_RESPONSES}) created per execution exceeded`,
                        });
                    }
                    // Per https://developer.mozilla.org/en-US/docs/Web/HTTP/Status, status codes are
                    // between 100 and 599.
                    if (status < 100 || status > 599) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid status code ${status}`,
                        });
                    }
                    const response = new EdgeFunctionResponse_1.default({
                        statusCode: status,
                    });
                    const id = nextResponseId++;
                    const memory = this.getGuestMemory();
                    memory.setUint32(resp_id_offset, id);
                    responses.set(id, response);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Clone response object
                hostcall_resp_clone_without_body: (id, clone_id_offset) => {
                    const memory = this.getGuestMemory();
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const clone_response = EdgeFunctionResponse_1.default.createFromResponse(response);
                    const clone_id = nextResponseId++;
                    memory.setUint32(clone_id_offset, clone_id);
                    responses.set(clone_id, clone_response);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Return the response
                hostcall_resp_send_to_client: (id) => {
                    this.funDebug('hostcall_resp_send_to_client()', id);
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.responseReturned) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Outbound response already set',
                        });
                    }
                    response.responseReturned = true;
                    this.response = response;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Initiate an asynchronous fetch
                hostcall_req_fetch_async: (id) => {
                    ++requestsIssued;
                    if (requestsIssued > MAX_ISSUED_REQUESTS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Failed to issue request, max limit of ${MAX_ISSUED_REQUESTS} requests reached!`,
                        });
                    }
                    this.funDebug('hostcall_req_fetch_async()', id, requestsIssued);
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    request.fetchCalled = true;
                    // This is already checked in hostcall_req_set_fetch_origin,
                    // however this must also be checked in this hostcall in case
                    // the other hostcall is not called first (e.g. in third-party wasm functions).
                    // Connascence of algorithm with the `hostcall_req_fetch_async` function in the Sailfish.
                    if (request.fetchOrigin === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: No fetch origin was set`,
                        });
                    }
                    if (!this.params.origins.find(x => x.name === request.fetchOrigin) === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: fetch origin "${request.fetchOrigin}" not found`,
                        });
                    }
                    // Limit fetches to these methods. Must be the same list
                    // as in sailfish/src/modules/wasm/hostcalls/request.cc
                    const METHODS = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT'];
                    if (METHODS.indexOf(request.method) === -1) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: Method '${request.method}' is not supported.`,
                        });
                    }
                    this.parent.fetchAsync(id, request.url, {
                        method: request.method,
                        headers: request.getHeaders(),
                        body: request.rawBody,
                        fetchOrigin: request.fetchOrigin,
                        fetchTimeout: request.fetchTimeout,
                    });
                    return WasmProgram_1.wasm_status.ok;
                },
                // wait for the next response or response error to arrive
                hostcall_resp_await_next: (pending_request_offset, response_or_response_error_code_offset, result_type_offset) => {
                    this.funDebug('hostcall_resp_await_next');
                    // Synchronously waits for the next ready response.
                    const { requestId, ...response } = this.parent.waitNextReadyResponseSync();
                    const memory = this.getGuestMemory();
                    memory.setUint32(pending_request_offset, requestId);
                    if (response.response) {
                        const responseId = nextResponseId++;
                        this.funDebug('hostcall_resp_await_next()', requestId, responseId);
                        memory.setUint32(response_or_response_error_code_offset, responseId);
                        memory.setUint32(result_type_offset, 1); // Response.
                        // Convert to EdgeFunctionResponse for consistency
                        responses.set(responseId, new EdgeFunctionResponse_1.default(response.response));
                    }
                    else {
                        // If the javascript generator has set the error code from mock response definition, convert it to error id.
                        if (!response.error_id && response.error && response.error.code) {
                            response.error_id =
                                EdgeFunctionFetchError_2.default[response.error.code];
                        }
                        // Else, in case of fetch timeout, response.error_id is set to TIMEOUT, otherwise CONNECT_FAILED.
                        this.funDebug('hostcall_resp_await_next() error', requestId, JSON.stringify(response));
                        memory.setUint32(response_or_response_error_code_offset, response.error_id);
                        memory.setUint32(result_type_offset, 0); // Response Error.
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the request uri
                hostcall_req_get_uri: (id, uri_offset, uri_length_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.url);
                    this.funDebug(`hostcall_req_get_uri(${id}) : ${request.url}`);
                    return this.copyDataToGuestMemory(data, uri_offset, uri_length_offset);
                },
                // Get the request path
                hostcall_req_get_path: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.path);
                    this.funDebug(`hostcall_req_get_path(${id}) : ${request.path}`);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Get the request method
                hostcall_req_get_method: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.method);
                    this.funDebug(`hostcall_req_get_method(${id}) : ${request.method}`);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Set the request method
                hostcall_req_set_method: (id, data_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const method = this.getStringFromGuestMemory(memory, data_offset, len);
                    if (method instanceof WasmProgram_1.WasmError)
                        return handleWasmError(method);
                    if (validMethods.indexOf(method) === -1) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid HTTP method provided: "${method}"`,
                        });
                    }
                    request.method = method;
                    this.funDebug('hostcall_req_set_method()', id, method);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Set the request uri
                hostcall_req_set_uri: (id, data_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const uri = this.getStringFromGuestMemory(memory, data_offset, len);
                    if (uri instanceof WasmProgram_1.WasmError)
                        return handleWasmError(uri);
                    const uri_validate_result = EdgeFunctionRequest_1.default.validate_uri(uri);
                    if (uri_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(uri_validate_result);
                    }
                    request.url = uri;
                    this.funDebug('hostcall_req_set_uri()', id, uri);
                    return WasmProgram_1.wasm_status.ok;
                },
                //
                // Set fetch() options
                //
                hostcall_req_set_fetch_bypass_cache: (id, bypassCache) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_bypass_cache not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_cache_key_rewrite: (id, source_offset, source_length, destination_offset, destination_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const src = this.getStringFromGuestMemory(memory, source_offset, source_length);
                    if (src instanceof WasmProgram_1.WasmError)
                        return handleWasmError(src);
                    const dst = this.getStringFromGuestMemory(memory, destination_offset, destination_length);
                    if (dst instanceof WasmProgram_1.WasmError)
                        return handleWasmError(dst);
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_cache_key_rewrite not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_cacheable_status_codes: (id, codes_offset, codes_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_cacheable_status_codes not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_ckqs_exclude_all: (id, exclude_all) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_ckqs_exclude_all not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_ckqs_include: (id, params_offset, params_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const params = this.getStringFromGuestMemory(memory, params_offset, params_length);
                    if (params instanceof WasmProgram_1.WasmError)
                        return handleWasmError(params);
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_ckqs_include not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_ckqs_include_all: (id, include_all) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_ckqs_include not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_ckqs_include_all_except: (id, params_offset, params_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const params = this.getStringFromGuestMemory(memory, params_offset, params_length);
                    if (params instanceof WasmProgram_1.WasmError)
                        return handleWasmError(params);
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_ckqs_include_all_except not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_ignore_origin_no_cache: (id, codes_offset, codes_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_ignore_origin_no_cache not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_max_age: (id, maxage_offset, maxage_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const maxage = this.getStringFromGuestMemory(memory, maxage_offset, maxage_length);
                    if (maxage instanceof WasmProgram_1.WasmError)
                        return handleWasmError(maxage);
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_max_age not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_cache_tags: (id, cache_tags_offset, cache_tags_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const cacheTags = this.getStringFromGuestMemory(memory, cache_tags_offset, cache_tags_length);
                    if (cacheTags instanceof WasmProgram_1.WasmError)
                        return handleWasmError(cacheTags);
                    // TODO(agutekanst): hostcall_req_set_fetch_cache_tags is currently a no-op in
                    // the node/cli/xdn host.
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_origin: (id, origin_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const fetchOrigin = this.getStringFromGuestMemory(memory, origin_offset, len);
                    if (fetchOrigin instanceof WasmProgram_1.WasmError)
                        return handleWasmError(fetchOrigin);
                    const origin = this.params.origins.find(x => x.name === fetchOrigin);
                    if (origin === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Undefined fetch origin "${fetchOrigin}"`,
                        });
                    }
                    request.fetchOrigin = origin;
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_stale_on_error: (id, state_on_error) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_stale_on_error not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_stale_while_revalidate: (id, swr_offset, swr_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const swr = this.getStringFromGuestMemory(memory, swr_offset, swr_length);
                    if (swr instanceof WasmProgram_1.WasmError)
                        return handleWasmError(swr);
                    // We don't support fetch caching in the CLI/emulator.
                    this.funDebug('hostcall_req_set_fetch_stale_while_revalidate not supported in CLI');
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_set_fetch_timeout: (id, timeout) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    request.fetchTimeout = timeout;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Set the request body
                hostcall_req_set_body: (id, data_offset, len) => {
                    if (id === this.DOWNSTREAM_REQUEST_ID) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify the downstream request body',
                        });
                    }
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(data_offset, data_offset + len);
                    request.rawBody = buffer_1.Buffer.from(body);
                    this.funDebug('hostcall_req_set_body()', id, body);
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_append_body: (id, ptr, len) => {
                    this.funDebug('hostcall_req_append_body()', id, ptr, len);
                    if (id === this.DOWNSTREAM_REQUEST_ID) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify the downstream request body',
                        });
                    }
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(ptr, ptr + len);
                    if (request.rawBody === undefined) {
                        request.rawBody = buffer_1.Buffer.from(body);
                    }
                    else {
                        request.rawBody = buffer_1.Buffer.concat([request.rawBody, buffer_1.Buffer.from(body)]);
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_get_body: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    this.funDebug('hostcall_req_get_body()', id);
                    return this.copyDataToGuestMemory(request.rawBody || buffer_1.Buffer.alloc(0), data_offset, len_offset);
                },
                hostcall_req_get_body_chunk: (id, chunk_offset, data_offset, len_offset) => {
                    var _a;
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const len = this.getGuestMemory().getUint32(len_offset);
                    this.funDebug('hostcall_req_get_body_chunk()', id, chunk_offset, len, (_a = request.rawBody) === null || _a === void 0 ? void 0 : _a.byteLength);
                    // We don't currently support full BigInt range for chunk_offset so we cast it to Number.
                    const chunk = request.readBodyChunk(Number(chunk_offset), len);
                    if (chunk === undefined) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return this.copyDataToGuestMemory(chunk, data_offset, len_offset);
                },
                // Set the response http status code
                hostcall_resp_set_status: (id, status) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.responseReturned) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    this.funDebug('hostcall_resp_set_status()', id, status);
                    response.statusCode = status;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response http status code
                hostcall_resp_get_status: (id, status_offset) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    this.funDebug('hostcall_resp_get_status()', id, response.statusCode);
                    const memory = this.getGuestMemory();
                    memory.setUint32(status_offset, response.statusCode);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response http status reason text
                hostcall_resp_get_reason: (id, data_offset, len_offset) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const reason = (0, EdgeFunctionReason_1.default)(response.statusCode);
                    this.funDebug('hostcall_resp_get_reason()', id, reason);
                    const data = new TextEncoder().encode(reason);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Set the response body
                hostcall_resp_set_body: (id, ptr, len) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.responseReturned) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(ptr, ptr + len);
                    response.body = buffer_1.Buffer.from(body);
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_resp_append_body: (id, ptr, len) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.responseReturned) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(ptr, ptr + len);
                    if (response.body === undefined) {
                        response.body = buffer_1.Buffer.from(body);
                    }
                    else {
                        response.body = buffer_1.Buffer.concat([response.body, buffer_1.Buffer.from(body)]);
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                // panic callback
                hostcall_panic_hook: (msg_offset, msg_length) => {
                    const memory = this.getGuestMemory();
                    const msg = this.getStringFromGuestMemoryTruncate(memory, msg_offset, msg_length);
                    this.panicString = msg;
                    // We also write the panic message to stderr. In Sailfish we limit the panic
                    // to 512 bytes, but here we just inject <truncated> into the message so the
                    // user knows it will be truncated in production. Since there can only be one
                    // panic per edge function run, we do not need to accumulate the panic_written_bytes.
                    const msgAsBuf = buffer_1.Buffer.from(msg);
                    if (msg_length + overflow_message.length >= MAX_PANIC_BYTES) {
                        this.parent.writeToStderr(msgAsBuf.slice(0, MAX_PANIC_BYTES));
                        this.parent.writeToStderr(buffer_1.Buffer.from(overflow_message));
                        this.parent.writeToStderr(msgAsBuf.slice(MAX_PANIC_BYTES));
                    }
                    else {
                        this.parent.writeToStderr(msgAsBuf);
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get a request header name by index
                hostcall_req_get_header_name_by_idx: (id, idx_offset, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // The implementation in CLI is different from the Sailfish implementation
                    // because we filter the headers in EdgeFunctionHeaders to only return the
                    // headers that are allowed to be read. Hence we only read the index and
                    // never need to update it.
                    const memory = this.getGuestMemory();
                    const idx = memory.getUint32(idx_offset);
                    const headerName = request.getHeaderNameByIdx(idx);
                    // If there is no header or the header is not allowed to be read, return not found
                    if (!headerName || !EdgeFunctionHeaders_1.default.is_allowed_read_header_name(headerName)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug('hostcall_req_get_header_name_by_idx()', idx, headerName);
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerName), key_offset, key_length);
                },
                // Pass in a header name and return the header's values as string array
                // or an exception if the header name is not found.
                hostcall_req_get_header_values: (id, key_offset, key_length, sizes_offset, // ptr to sizes array
                sizes_length_offset, // ptr to length of sizes array
                values_offset, // ptr to values array
                values_length_offset // ptr to length of values array
                ) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    // We are pretending that non-readable headers do not exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    let headerValues = request.getHeader(key);
                    if (typeof headerValues === 'string') {
                        // Ensure the result is always an array of string
                        headerValues = [headerValues];
                    }
                    if (!Array.isArray(headerValues)) {
                        // If not a string or array, return not found
                        this.funDebug(`hostcall_req_get_header_values() id: ${id} key '${key}' not found`);
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Put all of the lengths into a single buffer so we can call a single copyDataToGuestMemory()
                    let rc = this.copyDataToGuestMemory(this.stringLengthsToBuffer(headerValues), sizes_offset, sizes_length_offset);
                    if (rc !== WasmProgram_1.wasm_status.ok)
                        return rc;
                    // Put all of the strings into a single buffer so we can call a single copyDataToGuestMemory()
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerValues.join('')), values_offset, values_length_offset);
                },
                // Set a request header
                hostcall_req_set_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetchCalled) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        // Our preference is to just allow the user's code to run
                        // rather than force them to do a check for every header they set.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    if (val instanceof WasmProgram_1.WasmError)
                        return handleWasmError(val);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    if (request.headers.get_total_bytes() +
                        key_length +
                        val_length +
                        HTTP_HEADER_DELIMITER_BYTES >
                        MAX_HEADER_BYTES) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Setting request header '${key}: ${val}' exceeds total allowed header bytes of ${MAX_HEADER_BYTES}`,
                        });
                    }
                    this.funDebug(`hostcall_req_set_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    request.setHeader(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Insert/append a request header
                hostcall_req_append_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    if (val instanceof WasmProgram_1.WasmError)
                        return handleWasmError(val);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    if (request.headers.get_total_bytes() +
                        key_length +
                        val_length +
                        HTTP_HEADER_DELIMITER_BYTES >
                        MAX_HEADER_BYTES) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Appending request header '${key}: ${val}' exceeds total allowed header bytes of ${MAX_HEADER_BYTES}`,
                        });
                    }
                    this.funDebug(`hostcall_req_append_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    request.appendHeader(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Remove a request header
                hostcall_req_remove_header: (id, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    this.funDebug(`hostcall_req_remove_header() ${id}, '${key}'`);
                    return request.removeHeader(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Check that a request header exists
                hostcall_req_check_header: (id, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    // Not allowed to be read so treat it as if it doesn't exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    const exists = request.getHeader(key) !== undefined;
                    this.funDebug(`hostcall_req_check_header() ${id}, '${key}' returns: ${exists}`);
                    return exists ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Get a response header name by index
                hostcall_resp_get_header_name_by_idx: (id, idx_offset, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    // The implementation in CLI is different from the Sailfish implementation
                    // because we filter the headers in EdgeFunctionHeaders to only return the
                    // headers that are allowed to be read. Hence we only read the index and
                    // never need to update it.
                    const memory = this.getGuestMemory();
                    const idx = memory.getUint32(idx_offset);
                    const headerName = response.headers.key(idx);
                    if (!headerName || !EdgeFunctionHeaders_1.default.is_allowed_read_header_name(headerName)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug('hostcall_resp_get_header_name_by_idx()', idx, headerName);
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerName), key_offset, key_length);
                },
                // Pass in a header name and return the header's values as string array
                // or an exception if the header name is not found.
                hostcall_resp_get_header_values: (id, key_offset, key_length, sizes_offset, // ptr to sizes array
                sizes_length_offset, // ptr to length of sizes array
                values_offset, // ptr to values array
                values_length_offset // ptr to length of values array
                ) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    // We are pretending that non-readable headers do not exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    let headerValues = response.headers.get(key);
                    if (typeof headerValues === 'string') {
                        // Ensure the result is always an array of string
                        headerValues = [headerValues];
                    }
                    if (!Array.isArray(headerValues)) {
                        // If not a string or array, return not found
                        this.funDebug(`hostcall_resp_get_header_values() id: ${id} key '${key}' not found`);
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Put all of the lengths into a single buffer so we can call a single copyDataToGuestMemory()
                    let rc = this.copyDataToGuestMemory(this.stringLengthsToBuffer(headerValues), sizes_offset, sizes_length_offset);
                    if (rc !== WasmProgram_1.wasm_status.ok)
                        return rc;
                    // Put all of the strings into a single buffer so we can call a single copyDataToGuestMemory()
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerValues.join('')), values_offset, values_length_offset);
                },
                // Set a response header
                hostcall_resp_set_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.responseReturned) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Cannot modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    if (val instanceof WasmProgram_1.WasmError)
                        return handleWasmError(val);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    if (response.headers.get_total_bytes() +
                        key_length +
                        val_length +
                        HTTP_HEADER_DELIMITER_BYTES >
                        MAX_HEADER_BYTES) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Setting response header '${key}: ${val}' exceeds total allowed header bytes of ${MAX_HEADER_BYTES}`,
                        });
                    }
                    this.funDebug(`hostcall_resp_set_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    response.headers.set(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Insert/append a response header
                hostcall_resp_append_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    if (val instanceof WasmProgram_1.WasmError)
                        return handleWasmError(val);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    if (response.headers.get_total_bytes() +
                        key_length +
                        val_length +
                        HTTP_HEADER_DELIMITER_BYTES >
                        MAX_HEADER_BYTES) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.limit_exceeded,
                            message: `Appending response header '${key}: ${val}' exceeds total allowed header bytes of ${MAX_HEADER_BYTES}`,
                        });
                    }
                    this.funDebug(`hostcall_resp_append_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    response.headers.append(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Remove a response header
                hostcall_resp_remove_header: (id, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        // We intentionally and silently ignore headers in the forbidden write list.
                        return WasmProgram_1.wasm_status.ok;
                    }
                    this.funDebug(`hostcall_resp_remove_header() ${id}, '${key}'`);
                    return response.headers.remove(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Check that a response header exists
                hostcall_resp_check_header: (id, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (key instanceof WasmProgram_1.WasmError)
                        return handleWasmError(key);
                    // Not allowed to be read so treat it as if it doesn't exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug(`hostcall_resp_check_header() ${id}, '${key}'`);
                    return response.headers.check(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Get the response body
                hostcall_resp_get_body: (id, data_offset, len_offset) => {
                    var _a;
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    this.funDebug('hostcall_resp_get_body()', id, (_a = response.body) === null || _a === void 0 ? void 0 : _a.length);
                    return this.copyDataToGuestMemory(response.body || buffer_1.Buffer.alloc(0), data_offset, len_offset);
                },
                hostcall_resp_get_body_chunk: (id, chunk_offset, data_offset, len_offset) => {
                    var _a;
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const len = this.getGuestMemory().getUint32(len_offset);
                    this.funDebug('hostcall_resp_get_body_chunk()', id, chunk_offset, len, (_a = response.body) === null || _a === void 0 ? void 0 : _a.byteLength);
                    // We don't currently support full BigInt range for chunk_offset so we cast it to Number.
                    const chunk = response.readBodyChunk(Number(chunk_offset), len);
                    if (chunk === undefined) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return this.copyDataToGuestMemory(chunk, data_offset, len_offset);
                },
                // Write message to debug stream.
                hostcall_debug: (msg_offset, msg_length) => {
                    const memory = this.getGuestMemory();
                    const msg = this.getStringFromGuestMemoryTruncate(memory, msg_offset, msg_length);
                    this.funDebug(msg);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Write quickjs-wasm version to the local context.
                hostcall_set_wasm_version_string: (msg_offset, msg_length) => {
                    const memory = this.getGuestMemory();
                    const msg = this.getStringFromGuestMemoryTruncate(memory, msg_offset, msg_length);
                    this.funDebug(`quickjs-wasm v${msg}`);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response error message
                hostcall_resp_get_error_code_message: (error_code, message_offset, len_offset) => {
                    let errorMessage = (0, EdgeFunctionFetchError_1.getFetchResponseErrorFriendlyMessage)(error_code);
                    if (errorMessage === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid response error code provided: ${error_code}`,
                        });
                    }
                    this.funDebug('hostcall_resp_get_error_code_message()', error_code, errorMessage);
                    return this.copyDataToGuestMemory(new TextEncoder().encode(errorMessage), message_offset, len_offset);
                },
                hostcall_metrics_start_timer: (index) => {
                    this.funDebug('hostcall_metrics_start_timer()', index);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Metric index ${index} must be betwen 0 and 9`,
                        });
                    }
                    if (!this.metrics.startTimer(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Timer for metric index ${index} is already in use.`,
                        });
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_metrics_stop_timer: (index) => {
                    this.funDebug('hostcall_metrics_stop_timer()', index);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Metric index ${index} must be betwen 0 and 9`,
                        });
                    }
                    if (!this.metrics.stopTimer(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `No active timer for metric index ${index} was found.`,
                        });
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_metrics_add: (index, value) => {
                    this.funDebug('hostcall_metrics_add()', index, value);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Metric index ${index} must be betwen 0 and 9`,
                        });
                    }
                    this.metrics.add(index, value);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Clear the wasmInitialMemory cache so the next edge function call will
                // be a cold start and it will call its edge function's init() again.
                hostcall_init_clear: () => {
                    this.funDebug('hostcall_init_clear()');
                    this.parent.clearWasmInitialMemory();
                    return WasmProgram_1.wasm_status.ok;
                },
            },
            wasi_snapshot_preview1: {
                fd_write: (fd, iovs_offset, iovs_length, bw_offset) => {
                    var _a, _b;
                    const STDOUT_FD = 1;
                    const STDERR_FD = 2;
                    // Only accept writes to stdout/stderr
                    if (fd != STDOUT_FD && fd != STDERR_FD) {
                        throw new WebAssembly.RuntimeError('Write not allowed');
                    }
                    const memory = this.getGuestMemory();
                    let bytesWritten = 0;
                    // Write all the buffers as they were given to us.
                    for (let i = 0; i < iovs_length; i++) {
                        const iov_base = memory.getUint32(iovs_offset + WasmProgram_1.SIZEOF_wasi_iovec_t * i);
                        const iov_len = memory.getUint32(iovs_offset + WasmProgram_1.SIZEOF_wasi_iovec_t * i + Uint32Array.BYTES_PER_ELEMENT);
                        const iovs = buffer_1.Buffer.from(memory.slice(iov_base, iov_base + iov_len));
                        switch (fd) {
                            case STDOUT_FD: {
                                let bytes_remaining = MAX_OUT_BYTES - this.stdout_written_bytes;
                                if (bytes_remaining > 0 && iov_len + overflow_message.length >= bytes_remaining) {
                                    this.stdout_written_bytes += bytes_remaining;
                                    this.parent.writeToStdout(iovs.slice(0, bytes_remaining));
                                    this.parent.writeToStdout(buffer_1.Buffer.from(overflow_message));
                                    this.parent.writeToStdout(iovs.slice(bytes_remaining));
                                }
                                else {
                                    // The CLI does not actually truncate stdout,
                                    // it just injects <truncated> at the point where
                                    // production will truncate stdout.
                                    this.stdout_written_bytes += iov_len;
                                    this.parent.writeToStdout(iovs);
                                }
                                if (typeof window === undefined && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.LOG_LEVEL) === 'trace') {
                                    process.stdout.write(iovs);
                                }
                                break;
                            }
                            case STDERR_FD: {
                                let bytes_remaining = MAX_OUT_BYTES - this.stderr_written_bytes;
                                if (bytes_remaining > 0 && iov_len + overflow_message.length >= bytes_remaining) {
                                    this.stderr_written_bytes += bytes_remaining;
                                    this.parent.writeToStderr(iovs.slice(0, bytes_remaining));
                                    this.parent.writeToStderr(buffer_1.Buffer.from(overflow_message));
                                    this.parent.writeToStderr(iovs.slice(bytes_remaining));
                                }
                                else {
                                    // The CLI does not actually truncate stderr,
                                    // it just injects <truncated> at the point where
                                    // production will truncate stderr.
                                    this.stderr_written_bytes += iov_len;
                                    this.parent.writeToStderr(iovs);
                                }
                                if (typeof window === undefined && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.LOG_LEVEL) === 'trace') {
                                    process.stderr.write(iovs);
                                }
                                break;
                            }
                            default:
                                throw new WebAssembly.RuntimeError('Write not allowed');
                        }
                        bytesWritten += iov_len;
                    }
                    memory.setUint32(bw_offset, bytesWritten);
                    return 0;
                },
                environ_get: (...args) => {
                    this.funDebug('environ_get not supported');
                    throw new WebAssembly.RuntimeError('environ_get not supported');
                },
                environ_sizes_get: (environCountPtr, environBufSizePtr) => {
                    const memory = this.getGuestMemory();
                    // environ_sizes_get is supposed to write the number of arguments but we don't have any arguments.
                    memory.setUint32(environCountPtr, 0);
                    memory.setUint32(environBufSizePtr, 0);
                },
                clock_time_get: (_clockId, _precision, tsOffset) => {
                    const memory = this.getGuestMemory();
                    memory.setBigUint64(tsOffset, startTimeNs);
                },
                fd_close: (...args) => {
                    this.funDebug('fd_close not supported');
                    throw new WebAssembly.RuntimeError('fd_close not supported');
                },
                fd_fdstat_get: (...args) => {
                    // this.funDebug('fd_fdstat_get not supported')
                    // throw new WebAssembly.RuntimeError('fd_fdstat_get not supported')
                },
                fd_seek: (...args) => {
                    this.funDebug('fd_seek not supported');
                    throw new WebAssembly.RuntimeError('fd_seek not supported');
                },
                fd_prestat_get: (...args) => {
                    this.funDebug('fd_prestat_get not supported');
                    throw new WebAssembly.RuntimeError('fd_prestat_get not supported');
                },
                fd_prestat_dir_name: (...args) => {
                    this.funDebug('fd_prestat_dir_name not supported');
                    throw new WebAssembly.RuntimeError('fd_prestat_dir_name not supported');
                },
                proc_exit1: (...args) => {
                    this.funDebug('proc_exit1 not supported');
                    throw new WebAssembly.RuntimeError('proc_exit1 not supported');
                },
                proc_exit: (...args) => {
                    this.funDebug('proc_exit not supported', args);
                    throw new WebAssembly.RuntimeError('proc_exit not supported');
                },
                random_get: (...args) => {
                    // this.funDebug('random_get not supported', args)
                    // throw new WebAssembly.RuntimeError('random_get not supported')
                },
            },
        };
    }
}
exports.default = EdgeFunction;
