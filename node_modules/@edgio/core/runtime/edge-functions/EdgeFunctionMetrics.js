"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class EdgeFunctionMetrics {
    constructor() {
        // Sailfish only allows one active timer per id, we use activeTimers to enforce this.
        this.activeTimers = {};
        this.values = {};
        // Connascence of value with Sailfish. See wasm_metrics.h
        this.USER_CUSTOM_METRIC_FIRST_INDEX = 0;
        this.USER_CUSTOM_METRIC_LAST_INDEX = 9;
        this.WASM_METRIC_JSON_FIRST_INDEX = 1000;
        this.WASM_METRIC_JSON_LAST_INDEX = 1007;
    }
    microseconds() {
        // Browser environment has a performance.now() function that returns a high resolution
        // milliseconds with floating point precision.
        if (performance) {
            return performance.now() * 1000;
        }
        // In Node environment we can use a process.hrtime() function
        const hrTime = process.hrtime();
        return hrTime[0] * 1000000 + hrTime[1] / 1000;
    }
    isValidIndex(index) {
        if (index >= this.USER_CUSTOM_METRIC_FIRST_INDEX && index <= this.USER_CUSTOM_METRIC_LAST_INDEX)
            return true;
        if (index >= this.WASM_METRIC_JSON_FIRST_INDEX && index <= this.WASM_METRIC_JSON_LAST_INDEX)
            return true;
        return false;
    }
    isActiveIndex(index) {
        return !!this.activeTimers[index];
    }
    startTimer(index) {
        if (this.isActiveIndex(index)) {
            return false;
        }
        this.activeTimers[index] = this.microseconds();
        return true;
    }
    // NOTE: In Sailfish, it is critical for security that we do not
    // allow the user to access the time or delta times from their
    // EdgeFunction. But in the CLI, this is not a concern.
    stopTimer(index) {
        if (!this.isActiveIndex(index)) {
            return false;
        }
        const startTime = this.activeTimers[index];
        this.add(index, this.microseconds() - startTime);
        delete this.activeTimers[index];
        return true;
    }
    add(index, value) {
        this.values[index] = (this.values[index] || 0) + value;
    }
    write(log) {
        const keys = Object.keys(this.values);
        for (let i = 0; i < keys.length; i++) {
            const index = parseInt(keys[i]);
            const value = this.values[index];
            if (value) {
                log(`Metrics: index:${index} value:${value}`);
            }
        }
    }
}
exports.default = EdgeFunctionMetrics;
