"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/runtime/edge-functions/sdk/consts.js
var require_consts = __commonJS({
  "src/runtime/edge-functions/sdk/consts.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      STDOUT_FD: 1,
      STDERR_FD: 2,
      ENV_VAR_NAMESPACE_EDGIO_CONFIG: "edgio-config",
      ENV_VAR_NAMESPACE_EDGIO_ORIGINS: "edgio-origins",
      ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR: "edgio-property-environment-variables",
      ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS: "edgio-feature-flags",
      ENV_VAR_NAMESPACE_EDGIO_USRVAR: "edgio-usrvar",
      ENV_VAR_NAMESPACE_EDGIO_GEO: "edgio-geo",
      ENV_VAR_NAMESPACE_EDGIO_WURFL: "edgio-wurfl",
      ENV_VAR_NAMESPACE_EDGIO_VIRT: "edgio-virt",
      UTF_8: "utf-8",
      WASM_METRIC_JSON_PARSE_INVOCATION_TOTAL: 1e3,
      WASM_METRIC_JSON_STRINGIFY_INVOCATION_TOTAL: 1001,
      WASM_METRIC_JSON_PARSE_MICROSECONDS_TOTAL: 1002,
      WASM_METRIC_JSON_STRINGIFY_MICROSECONDS_TOTAL: 1003,
      WASM_METRIC_TEXT_ENCODE_INVOCATION_TOTAL: 1004,
      WASM_METRIC_TEXT_DECODE_INVOCATION_TOTAL: 1005,
      WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL: 1006,
      WASM_METRIC_TEXT_DECODE_MICROSECONDS_TOTAL: 1007,
      INTERNAL_ERROR_PREFIX: "Internal Error: "
    };
  }
});

// src/runtime/edge-functions/sdk/symbols.js
var require_symbols = __commonJS({
  "src/runtime/edge-functions/sdk/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      AppendFn: Symbol("append-fn"),
      Body: Symbol("body"),
      BodyOnHost: Symbol("body-on-host"),
      BodyReadOffset: Symbol("body-read-offset"),
      BodyUsed: Symbol("body-used"),
      CheckFn: Symbol("check-fn"),
      Chunks: Symbol("Chunks"),
      Controller: Symbol("Controller"),
      Done: Symbol("Done"),
      EdgioId: Symbol("edgio-id"),
      Encoding: Symbol("encoding"),
      ErrorCode: Symbol("error-code"),
      ErrorState: Symbol("error-state"),
      GetBodyChunkFn: Symbol("get-body-chunk-fn"),
      GetFn: Symbol("get-fn"),
      KeysFn: Symbol("keys-fn"),
      MoveBodyToHost: Symbol("move-body-to-host"),
      Namespace: Symbol("namespace"),
      Options: Symbol("options"),
      Origins: Symbol("edgio-origins"),
      PendingNextPromise: Symbol("PendingNextPromise"),
      PendingNextPromiseReject: Symbol("PendingNextPromiseReject"),
      PendingNextPromiseResolve: Symbol("PendingNextPromiseResolve"),
      QueuingStrategy: Symbol("QueuingStrategy"),
      Redirected: Symbol("redirected"),
      RemoveFn: Symbol("remove-fn"),
      ReqOrRespObject: Symbol("req-or-resp-object"),
      ReqRespHeaders: Symbol("req-resp-headers"),
      RequestObject: Symbol("request-object"),
      ResponseObject: Symbol("response-object"),
      SendToClient: Symbol("send-to-client"),
      SetFn: Symbol("set-fn"),
      Stream: Symbol("Stream"),
      UnderlyingSource: Symbol("UnderlyingSource"),
      Url: Symbol("url")
    };
  }
});

// src/runtime/edge-functions/bundled-object-inspect.js
var require_bundled_object_inspect = __commonJS({
  "src/runtime/edge-functions/bundled-object-inspect.js"(exports2, module2) {
    "use strict";
    var Et = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var et = Et(() => {
    });
    var U = typeof Map == "function" && Map.prototype;
    var N = Object.getOwnPropertyDescriptor && U ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var I = U && N && typeof N.get == "function" ? N.get : null;
    var rt = U && Map.prototype.forEach;
    var K = typeof Set == "function" && Set.prototype;
    var C = Object.getOwnPropertyDescriptor && K ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var L = K && C && typeof C.get == "function" ? C.get : null;
    var nt = K && Set.prototype.forEach;
    var $t = typeof WeakMap == "function" && WeakMap.prototype;
    var w = $t ? WeakMap.prototype.has : null;
    var Mt = typeof WeakSet == "function" && WeakSet.prototype;
    var E = Mt ? WeakSet.prototype.has : null;
    var Wt = typeof WeakRef == "function" && WeakRef.prototype;
    var at = Wt ? WeakRef.prototype.deref : null;
    var It = Boolean.prototype.valueOf;
    var Lt = Object.prototype.toString;
    var _t = Function.prototype.toString;
    var Rt = String.prototype.match;
    var Q = String.prototype.slice;
    var s = String.prototype.replace;
    var kt = String.prototype.toUpperCase;
    var it = String.prototype.toLowerCase;
    var gt = RegExp.prototype.test;
    var ot = Array.prototype.concat;
    var u = Array.prototype.join;
    var qt = Array.prototype.slice;
    var ft = Math.floor;
    var z = typeof BigInt == "function" ? BigInt.prototype.valueOf : null;
    var B = Object.getOwnPropertySymbols;
    var F = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null;
    var m = typeof Symbol == "function" && typeof Symbol.iterator == "object";
    var o = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === m ? "object" : "symbol") ? Symbol.toStringTag : null;
    var vt = Object.prototype.propertyIsEnumerable;
    var lt = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
      return t.__proto__;
    } : null);
    function ut(t, e) {
      if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || gt.call(/e/, e))
        return e;
      var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof t == "number") {
        var a = t < 0 ? -ft(-t) : ft(t);
        if (a !== t) {
          var i = String(a), r = Q.call(e, i.length + 1);
          return s.call(i, n, "$&_") + "." + s.call(s.call(r, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return s.call(e, n, "$&_");
    }
    var H = et();
    var ct = H.custom;
    var pt = ht(ct) ? ct : null;
    module2.exports = function t(e, n, a, i) {
      var r = n || {};
      if (y(r, "quoteStyle") && r.quoteStyle !== "single" && r.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (y(r, "maxStringLength") && (typeof r.maxStringLength == "number" ? r.maxStringLength < 0 && r.maxStringLength !== 1 / 0 : r.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      var c = y(r, "customInspect") ? r.customInspect : true;
      if (typeof c != "boolean" && c !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      if (y(r, "indent") && r.indent !== null && r.indent !== "	" && !(parseInt(r.indent, 10) === r.indent && r.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      if (y(r, "numericSeparator") && typeof r.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      var v = r.numericSeparator;
      if (typeof e > "u")
        return "undefined";
      if (e === null)
        return "null";
      if (typeof e == "boolean")
        return e ? "true" : "false";
      if (typeof e == "string")
        return dt(e, r);
      if (typeof e == "number") {
        if (e === 0)
          return 1 / 0 / e > 0 ? "0" : "-0";
        var f = String(e);
        return v ? ut(e, f) : f;
      }
      if (typeof e == "bigint") {
        var p = String(e) + "n";
        return v ? ut(e, p) : p;
      }
      var _ = typeof r.depth > "u" ? 5 : r.depth;
      if (typeof a > "u" && (a = 0), a >= _ && _ > 0 && typeof e == "object")
        return V(e) ? "[Array]" : "[Object]";
      var S = Yt(r, a);
      if (typeof i > "u")
        i = [];
      else if (mt(i, e) >= 0)
        return "[Circular]";
      function l(h, M, wt) {
        if (M && (i = qt.call(i), i.push(M)), wt) {
          var tt = { depth: r.depth };
          return y(r, "quoteStyle") && (tt.quoteStyle = r.quoteStyle), t(h, tt, a + 1, i);
        }
        return t(h, r, a + 1, i);
      }
      if (typeof e == "function" && !yt(e)) {
        var G = Ft(e), X = W(e, l);
        return "[Function" + (G ? ": " + G : " (anonymous)") + "]" + (X.length > 0 ? " { " + u.call(X, ", ") + " }" : "");
      }
      if (ht(e)) {
        var Y = m ? s.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : F.call(e);
        return typeof e == "object" && !m ? O(Y) : Y;
      }
      if (Qt(e)) {
        for (var d = "<" + it.call(String(e.nodeName)), R = e.attributes || [], $ = 0; $ < R.length; $++)
          d += " " + R[$].name + "=" + St(At(R[$].value), "double", r);
        return d += ">", e.childNodes && e.childNodes.length && (d += "..."), d += "</" + it.call(String(e.nodeName)) + ">", d;
      }
      if (V(e)) {
        if (e.length === 0)
          return "[]";
        var k = W(e, l);
        return S && !Xt(k) ? "[" + J(k, S) + "]" : "[ " + u.call(k, ", ") + " ]";
      }
      if (Dt(e)) {
        var q = W(e, l);
        return !("cause" in Error.prototype) && "cause" in e && !vt.call(e, "cause") ? "{ [" + String(e) + "] " + u.call(ot.call("[cause]: " + l(e.cause), q), ", ") + " }" : q.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + u.call(q, ", ") + " }";
      }
      if (typeof e == "object" && c) {
        if (pt && typeof e[pt] == "function" && H)
          return H(e, { depth: _ - a });
        if (c !== "symbol" && typeof e.inspect == "function")
          return e.inspect();
      }
      if (Ht(e)) {
        var Z = [];
        return rt && rt.call(e, function(h, M) {
          Z.push(l(M, e, true) + " => " + l(h, e));
        }), st("Map", I.call(e), Z, S);
      }
      if (Ut(e)) {
        var x = [];
        return nt && nt.call(e, function(h) {
          x.push(l(h, e));
        }), st("Set", L.call(e), x, S);
      }
      if (Vt(e))
        return P("WeakMap");
      if (Kt(e))
        return P("WeakSet");
      if (Jt(e))
        return P("WeakRef");
      if (Ct(e))
        return O(l(Number(e)));
      if (Pt(e))
        return O(l(z.call(e)));
      if (Bt(e))
        return O(It.call(e));
      if (Nt(e))
        return O(l(String(e)));
      if (!Tt(e) && !yt(e)) {
        var A = W(e, l), b = lt ? lt(e) === Object.prototype : e instanceof Object || e.constructor === Object, T = e instanceof Object ? "" : "null prototype", j = !b && o && Object(e) === e && o in e ? Q.call(g(e), 8, -1) : T ? "Object" : "", Ot = b || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", D = Ot + (j || T ? "[" + u.call(ot.call([], j || [], T || []), ": ") + "] " : "");
        return A.length === 0 ? D + "{}" : S ? D + "{" + J(A, S) + "}" : D + "{ " + u.call(A, ", ") + " }";
      }
      return String(e);
    };
    function St(t, e, n) {
      var a = (n.quoteStyle || e) === "double" ? '"' : "'";
      return a + t + a;
    }
    function At(t) {
      return s.call(String(t), /"/g, "&quot;");
    }
    function V(t) {
      return g(t) === "[object Array]" && (!o || !(typeof t == "object" && o in t));
    }
    function Tt(t) {
      return g(t) === "[object Date]" && (!o || !(typeof t == "object" && o in t));
    }
    function yt(t) {
      return g(t) === "[object RegExp]" && (!o || !(typeof t == "object" && o in t));
    }
    function Dt(t) {
      return g(t) === "[object Error]" && (!o || !(typeof t == "object" && o in t));
    }
    function Nt(t) {
      return g(t) === "[object String]" && (!o || !(typeof t == "object" && o in t));
    }
    function Ct(t) {
      return g(t) === "[object Number]" && (!o || !(typeof t == "object" && o in t));
    }
    function Bt(t) {
      return g(t) === "[object Boolean]" && (!o || !(typeof t == "object" && o in t));
    }
    function ht(t) {
      if (m)
        return t && typeof t == "object" && t instanceof Symbol;
      if (typeof t == "symbol")
        return true;
      if (!t || typeof t != "object" || !F)
        return false;
      try {
        return F.call(t), true;
      } catch {
      }
      return false;
    }
    function Pt(t) {
      if (!t || typeof t != "object" || !z)
        return false;
      try {
        return z.call(t), true;
      } catch {
      }
      return false;
    }
    var zt = Object.prototype.hasOwnProperty || function(t) {
      return t in this;
    };
    function y(t, e) {
      return zt.call(t, e);
    }
    function g(t) {
      return Lt.call(t);
    }
    function Ft(t) {
      if (t.name)
        return t.name;
      var e = Rt.call(_t.call(t), /^function\s*([\w$]+)/);
      return e ? e[1] : null;
    }
    function mt(t, e) {
      if (t.indexOf)
        return t.indexOf(e);
      for (var n = 0, a = t.length; n < a; n++)
        if (t[n] === e)
          return n;
      return -1;
    }
    function Ht(t) {
      if (!I || !t || typeof t != "object")
        return false;
      try {
        I.call(t);
        try {
          L.call(t);
        } catch {
          return true;
        }
        return t instanceof Map;
      } catch {
      }
      return false;
    }
    function Vt(t) {
      if (!w || !t || typeof t != "object")
        return false;
      try {
        w.call(t, w);
        try {
          E.call(t, E);
        } catch {
          return true;
        }
        return t instanceof WeakMap;
      } catch {
      }
      return false;
    }
    function Jt(t) {
      if (!at || !t || typeof t != "object")
        return false;
      try {
        return at.call(t), true;
      } catch {
      }
      return false;
    }
    function Ut(t) {
      if (!L || !t || typeof t != "object")
        return false;
      try {
        L.call(t);
        try {
          I.call(t);
        } catch {
          return true;
        }
        return t instanceof Set;
      } catch {
      }
      return false;
    }
    function Kt(t) {
      if (!E || !t || typeof t != "object")
        return false;
      try {
        E.call(t, E);
        try {
          w.call(t, w);
        } catch {
          return true;
        }
        return t instanceof WeakSet;
      } catch {
      }
      return false;
    }
    function Qt(t) {
      return !t || typeof t != "object" ? false : typeof HTMLElement < "u" && t instanceof HTMLElement ? true : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
    }
    function dt(t, e) {
      if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength, a = "... " + n + " more character" + (n > 1 ? "s" : "");
        return dt(Q.call(t, 0, e.maxStringLength), e) + a;
      }
      var i = s.call(s.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Gt);
      return St(i, "single", e);
    }
    function Gt(t) {
      var e = t.charCodeAt(0), n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
      return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + kt.call(e.toString(16));
    }
    function O(t) {
      return "Object(" + t + ")";
    }
    function P(t) {
      return t + " { ? }";
    }
    function st(t, e, n, a) {
      var i = a ? J(n, a) : u.call(n, ", ");
      return t + " (" + e + ") {" + i + "}";
    }
    function Xt(t) {
      for (var e = 0; e < t.length; e++)
        if (mt(t[e], `
`) >= 0)
          return false;
      return true;
    }
    function Yt(t, e) {
      var n;
      if (t.indent === "	")
        n = "	";
      else if (typeof t.indent == "number" && t.indent > 0)
        n = u.call(Array(t.indent + 1), " ");
      else
        return null;
      return { base: n, prev: u.call(Array(e + 1), n) };
    }
    function J(t, e) {
      if (t.length === 0)
        return "";
      var n = `
` + e.prev + e.base;
      return n + u.call(t, "," + n) + `
` + e.prev;
    }
    function W(t, e) {
      var n = V(t), a = [];
      if (n) {
        a.length = t.length;
        for (var i = 0; i < t.length; i++)
          a[i] = y(t, i) ? e(t[i], t) : "";
      }
      var r = typeof B == "function" ? B(t) : [], c;
      if (m) {
        c = {};
        for (var v = 0; v < r.length; v++)
          c["$" + r[v]] = r[v];
      }
      for (var f in t)
        !y(t, f) || n && String(Number(f)) === f && f < t.length || m && c["$" + f] instanceof Symbol || (gt.call(/[^\w$]/, f) ? a.push(e(f, t) + ": " + e(t[f], t)) : a.push(f + ": " + e(t[f], t)));
      if (typeof B == "function")
        for (var p = 0; p < r.length; p++)
          vt.call(t, r[p]) && a.push("[" + e(r[p]) + "]: " + e(t[r[p]], t));
      return a;
    }
  }
});

// src/runtime/edge-functions/sdk/readable-stream.js
var require_readable_stream = __commonJS({
  "src/runtime/edge-functions/sdk/readable-stream.js"(exports2, module2) {
    "use strict";
    var {
      Chunks,
      Controller,
      Done,
      ErrorState,
      PendingNextPromise,
      PendingNextPromiseReject,
      PendingNextPromiseResolve,
      QueuingStrategy,
      Stream,
      UnderlyingSource
    } = require_symbols();
    var promisify = (fn) => (...args) => {
      return new Promise((resolve, reject) => {
        try {
          resolve(fn(...args));
        } catch (err) {
          reject(err);
        }
      });
    };
    var ReadableStreamDefaultController = class {
      constructor(stream) {
        this[Stream] = stream;
      }
      enqueue(data) {
        this[Stream].push(data);
      }
      close() {
        this[Stream].push();
      }
      error(error) {
        this[Stream].push(error);
      }
    };
    var ReadableByteStreamController = class {
      constructor(stream) {
        this[Stream] = stream;
      }
      enqueue(data) {
        this[Stream].push(data);
      }
      close() {
        this[Stream].push();
      }
      error(error) {
        this[Stream].push(error);
      }
    };
    var ReadableStream = class {
      constructor(underlyingSource, queuingStrategy) {
        this[UnderlyingSource] = underlyingSource;
        this[QueuingStrategy] = queuingStrategy;
        if (underlyingSource?.type === "bytes") {
          this[Controller] = new ReadableByteStreamController(this);
        } else {
          this[Controller] = new ReadableStreamDefaultController(this);
        }
        this[Chunks] = [];
        this[Done] = false;
        this[ErrorState] = null;
        if (underlyingSource?.start) {
          promisify(underlyingSource.start)(this[Controller]).catch((err) => {
            this[Controller].error(err);
          });
        }
      }
      get locked() {
        return false;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async next() {
        if (this[PendingNextPromise]) {
          throw new Error(
            "Cannot call next() while a promise is pending from the previous call to next()"
          );
        }
        if (this[ErrorState]) {
          throw this[ErrorState];
        }
        if (this[Chunks].length > 0) {
          const nextChunk = this[Chunks].shift();
          if (nextChunk.error) {
            this[ErrorState] = nextChunk.error;
            throw nextChunk.error;
          }
          return nextChunk;
        }
        this[PendingNextPromise] = new Promise((resolve, reject) => {
          this[PendingNextPromiseResolve] = resolve;
          this[PendingNextPromiseReject] = reject;
        });
        return this[PendingNextPromise];
      }
      push(data) {
        if (this[Done]) {
          return;
        }
        if (data === void 0) {
          this[Chunks].push({ done: true });
          this[Done] = true;
        } else if (data instanceof Error) {
          this[Chunks].push({ error: data, done: true });
          this[Done] = true;
        } else {
          this[Chunks].push({ value: data, done: false });
        }
        if (this[PendingNextPromise]) {
          this[PendingNextPromise] = null;
          const resolve = this[PendingNextPromiseResolve];
          this[PendingNextPromiseResolve] = null;
          const reject = this[PendingNextPromiseReject];
          this[PendingNextPromiseReject] = null;
          const nextValue = this[Chunks].shift();
          if (nextValue.error) {
            this[ErrorState] = nextValue.error;
            reject(nextValue.error);
          } else {
            resolve(nextValue);
          }
        }
      }
    };
    module2.exports = {
      ReadableStream
    };
  }
});

// src/runtime/edge-functions/sdk/edgio-readable-stream-reader.js
var require_edgio_readable_stream_reader = __commonJS({
  "src/runtime/edge-functions/sdk/edgio-readable-stream-reader.js"(exports2, module2) {
    "use strict";
    var {
      BodyReadOffset,
      Done,
      EdgioId,
      GetBody,
      GetBodyChunkFn,
      MoveBodyToHost,
      ReqOrRespObject,
      BodyUsed
    } = require_symbols();
    var { INTERNAL_ERROR_PREFIX } = require_consts();
    function getEdgioReadableStreamReader({ host, feature_flags }) {
      let EdgioReadableResponseStreamReader;
      let EdgioReadableRequestStreamReader;
      const supportsBodyChunkHostcalls = feature_flags && feature_flags["body-chunk-hostcalls"];
      if (supportsBodyChunkHostcalls) {
        const _EdgioReadableStreamReader = class {
          constructor(reqOrRespObject, getBodyChunkFn) {
            if (this.constructor == _EdgioReadableStreamReader) {
              throw new Error(
                `${INTERNAL_ERROR_PREFIX}EdgioReadableStreamReader Abstract class cannot be instantiated directly.`
              );
            }
            this[ReqOrRespObject] = reqOrRespObject;
            this[GetBodyChunkFn] = getBodyChunkFn;
            this[Done] = false;
            this[BodyReadOffset] = 0;
          }
          async read() {
            if (this[Done]) {
              return { value: void 0, done: true };
            }
            await this[ReqOrRespObject][MoveBodyToHost]();
            this[ReqOrRespObject][BodyUsed] = true;
            const rawChunk = this[GetBodyChunkFn](
              this[ReqOrRespObject].edgioId,
              this[BodyReadOffset],
              _EdgioReadableStreamReader.MAX_CHUNK_SIZE
            );
            if (rawChunk === void 0) {
              this[Done] = true;
              return { value: void 0, done: true };
            }
            this[BodyReadOffset] += rawChunk.byteLength;
            const chunk = new Uint8Array(rawChunk);
            return { value: chunk, done: false };
          }
        };
        let EdgioReadableStreamReader = _EdgioReadableStreamReader;
        __publicField(EdgioReadableStreamReader, "MAX_CHUNK_SIZE", 64 * 1024);
        EdgioReadableResponseStreamReader = class EdgioReadableResponseStreamReader extends EdgioReadableStreamReader {
          constructor(response) {
            super(response, host.hostcall_resp_get_body_chunk);
          }
        };
        EdgioReadableRequestStreamReader = class EdgioReadableRequestStreamReader extends EdgioReadableStreamReader {
          constructor(request) {
            super(request, host.hostcall_req_get_body_chunk);
          }
        };
        return {
          EdgioReadableStreamReader,
          EdgioReadableResponseStreamReader,
          EdgioReadableRequestStreamReader
        };
      } else {
        const _EdgioReadableStreamReader = class {
          constructor(id, getBodyFn) {
            if (this.constructor == _EdgioReadableStreamReader) {
              throw new Error(
                `${INTERNAL_ERROR_PREFIX}EdgioReadableStreamReader Abstract class cannot be instantiated directly.`
              );
            }
            this[EdgioId] = id;
            this[GetBody] = getBodyFn;
            this[Done] = false;
          }
          async read() {
            const body = new Uint8Array(this[GetBody](this[EdgioId]));
            this[Done] = true;
            return { value: body };
          }
        };
        let EdgioReadableStreamReader = _EdgioReadableStreamReader;
        __publicField(EdgioReadableStreamReader, "BUFFER_SIZE", 1024);
        EdgioReadableResponseStreamReader = class EdgioReadableResponseStreamReader extends EdgioReadableStreamReader {
          constructor(response) {
            super(response, host.hostcall_resp_get_body);
          }
        };
        EdgioReadableRequestStreamReader = class EdgioReadableRequestStreamReader extends EdgioReadableStreamReader {
          constructor(request) {
            super(request, host.hostcall_req_get_body);
          }
        };
      }
      return {
        EdgioReadableResponseStreamReader,
        EdgioReadableRequestStreamReader
      };
    }
    module2.exports = getEdgioReadableStreamReader;
  }
});

// src/runtime/edge-functions/sdk.js
module.exports = function(runtime, edgeFunctions) {
  const { host, utility, feature_flags } = runtime;
  const {
    STDOUT_FD,
    STDERR_FD,
    ENV_VAR_NAMESPACE_EDGIO_CONFIG,
    ENV_VAR_NAMESPACE_EDGIO_ORIGINS,
    ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR,
    ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS,
    ENV_VAR_NAMESPACE_EDGIO_USRVAR,
    ENV_VAR_NAMESPACE_EDGIO_GEO,
    ENV_VAR_NAMESPACE_EDGIO_WURFL,
    ENV_VAR_NAMESPACE_EDGIO_VIRT,
    UTF_8,
    WASM_METRIC_JSON_PARSE_INVOCATION_TOTAL,
    WASM_METRIC_JSON_STRINGIFY_INVOCATION_TOTAL,
    WASM_METRIC_JSON_PARSE_MICROSECONDS_TOTAL,
    WASM_METRIC_JSON_STRINGIFY_MICROSECONDS_TOTAL,
    WASM_METRIC_TEXT_ENCODE_INVOCATION_TOTAL,
    WASM_METRIC_TEXT_DECODE_INVOCATION_TOTAL,
    WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL,
    WASM_METRIC_TEXT_DECODE_MICROSECONDS_TOTAL,
    INTERNAL_ERROR_PREFIX
  } = require_consts();
  const {
    AppendFn,
    Body,
    BodyOnHost,
    BodyUsed,
    CheckFn,
    EdgioId,
    Encoding,
    ErrorCode,
    GetFn,
    KeysFn,
    MoveBodyToHost,
    Namespace,
    Options,
    Origins,
    Redirected,
    RemoveFn,
    ReqRespHeaders,
    RequestObject,
    ResponseObject,
    SendToClient,
    SetFn,
    Url
  } = require_symbols();
  const supportsBodyChunkHostcalls = feature_flags && feature_flags["body-chunk-hostcalls"];
  const supportsEapps409FetchOptions = feature_flags && feature_flags["eapps-409-fetch-options"];
  const supportsInitClearHostCall = feature_flags && feature_flags["eapps-533-init-clear-hostcall"];
  const supportsEapps563FetchTagUpsert = feature_flags && feature_flags["eapps-563-fetch-tag-upsert"];
  const supportsHtmlTransformer = feature_flags && feature_flags["eapps-552-html-transformer"];
  const sailfishFeatureFlags = EdgioDict(ENV_VAR_NAMESPACE_EDGIO_FEATURE_FLAGS);
  let supportsMetricsOnTextEncoding = false;
  try {
    supportsMetricsOnTextEncoding = sailfishFeatureFlags.has("metrics-text-encoding");
  } catch (_e) {
  }
  const inspect = require_bundled_object_inspect();
  let consoleGroupIndentDepth = 0;
  const CONSOLE_GROUP_INDENT_STEP = 2;
  const getConsoleIndent = () => " ".repeat(consoleGroupIndentDepth);
  function wrappedConsoleWrite(fdWrite, ...args) {
    fdWrite(getConsoleIndent());
    if (args.length > 0) {
      let firstArg = args[0];
      if (typeof firstArg === "string") {
        args.shift();
        firstArg = firstArg.replace(/%[oOdisf]/g, (match) => {
          if (args.length === 0) {
            return match;
          }
          const arg = args.shift();
          switch (match) {
            case "%o":
            case "%O":
              return inspect(arg);
            case "%d":
            case "%i":
              return parseInt(arg, 10).toString();
            case "%s":
              return arg.toString();
            case "%f":
              return parseFloat(arg).toString();
            default:
              return match;
          }
        });
        args.unshift(firstArg);
      }
    }
    for (let i = 0; i < args.length; i++) {
      if (i !== 0) {
        fdWrite(" ");
      }
      const arg = args[i];
      const type = typeof arg;
      switch (type) {
        case "string":
          fdWrite(arg);
          break;
        case "number":
        case "function":
          fdWrite(arg.toString());
          break;
        case "boolean":
          fdWrite(arg ? "true" : "false");
          break;
        case "undefined":
          fdWrite(type);
          break;
        default:
          if (arg === null) {
            fdWrite("null");
          } else {
            fdWrite(inspect(arg));
          }
          break;
      }
    }
    fdWrite("\n");
  }
  function consoleWrite(fd, ...args) {
    const fdWrite = utility.stream_write_all.bind(this, fd);
    try {
      return wrappedConsoleWrite(fdWrite, ...args);
    } catch (e) {
      fdWrite("Exception during console output: ");
      fdWrite(e.toString());
      fdWrite("\n");
    }
  }
  const consoleCounters = /* @__PURE__ */ new Map();
  globalThis.console = {
    assert: function(condition, ...args) {
      if (!condition) {
        consoleWrite(STDERR_FD, "Assertion failed:", ...args);
      }
    },
    clear: function() {
    },
    count: function(label) {
      consoleCounters.set(label, (consoleCounters.get(label) || 0) + 1);
      globalThis.console.log(`${label}: ${consoleCounters.get(label)}`);
    },
    countReset: function(label) {
      consoleCounters.set(label, 0);
    },
    debug: consoleWrite.bind(globalThis.console, STDOUT_FD),
    dir: function(...args) {
      return globalThis.console.log(...args);
    },
    dirxml: function(...args) {
      return globalThis.console.log(...args);
    },
    error: consoleWrite.bind(globalThis.console, STDERR_FD),
    group: function(...args) {
      if (args !== void 0) {
        globalThis.console.log(...args);
      }
      consoleGroupIndentDepth += CONSOLE_GROUP_INDENT_STEP;
    },
    groupCollapsed: function(...args) {
      return globalThis.console.group(...args);
    },
    groupEnd: function() {
      consoleGroupIndentDepth = Math.max(consoleGroupIndentDepth - CONSOLE_GROUP_INDENT_STEP, 0);
    },
    info: consoleWrite.bind(globalThis.console, STDOUT_FD),
    log: consoleWrite.bind(globalThis.console, STDOUT_FD),
    profile: function() {
    },
    table: function(data, columns) {
      return globalThis.console.warn("table not implemented", data, columns);
    },
    time: function() {
    },
    timeEnd: function(label) {
      return globalThis.console.warn("timeEnd not implemented", label);
    },
    timeLog: function(label) {
      return globalThis.console.warn("timeLog not implemented", label);
    },
    timeStamp: function() {
    },
    trace: consoleWrite.bind(globalThis.console, STDOUT_FD),
    warn: consoleWrite.bind(globalThis.console, STDERR_FD)
  };
  const { ReadableStream } = require_readable_stream();
  globalThis.ReadableStream = ReadableStream;
  const { EdgioReadableResponseStreamReader, EdgioReadableRequestStreamReader } = require_edgio_readable_stream_reader()(runtime);
  class EdgioReadableResponseStream {
    constructor(response) {
      this[ResponseObject] = response;
    }
    getReader() {
      return new EdgioReadableResponseStreamReader(this[ResponseObject]);
    }
  }
  class EdgioReadableRequestStream {
    constructor(request) {
      this[RequestObject] = request;
    }
    getReader() {
      return new EdgioReadableRequestStreamReader(this[RequestObject]);
    }
  }
  class EdgioHeaders {
    constructor(id, headers, { appendFn, checkFn, getFn, keysFn, removeFn, setFn }) {
      if (this.constructor == EdgioHeaders) {
        throw new Error(
          `${INTERNAL_ERROR_PREFIX}Headers Abstract class cannot be instantiated directly.`
        );
      }
      this[EdgioId] = id;
      this[AppendFn] = appendFn;
      this[CheckFn] = checkFn;
      this[GetFn] = getFn;
      this[KeysFn] = keysFn;
      this[RemoveFn] = removeFn;
      this[SetFn] = setFn;
      if (Array.isArray(headers)) {
        headers.forEach((h) => {
          if (!Array.isArray(h)) {
            throw new Error(
              `When passing an array of headers, each array element must be an array of length = 2. '${h}' is type '${typeof h}' not type array.`
            );
          }
          if (h.length !== 2) {
            throw new Error(
              `When passing an array of headers, each array element must be an array of length = 2. '${h}' is array of length ${h.length}.`
            );
          }
          host.hostcall_debug(`.append(${h})`);
          this.append(h[0], h[1]);
        });
      } else if (headers && headers instanceof Headers) {
        const rawHeaders = headers.getRaw();
        Object.keys(rawHeaders).forEach((name) => {
          rawHeaders[name].forEach((value) => {
            this.append(name, value);
          });
        });
      } else if (headers && headers instanceof EdgioHeaders) {
        for (const key of headers.keys()) {
          for (const value of headers._getValuesForKey(key)) {
            this.append(key, value);
          }
        }
      } else if (headers && Function.prototype.toString.call(headers.constructor).match(/class.*/)) {
        throw new Error(
          `'headers' must be a 'Headers' instance, dictionary, or an array of array pairs. Found ${Function.prototype.toString.call(
            headers.constructor
          )}`
        );
      } else if (typeof headers === "object") {
        Object.keys(headers).forEach((name) => {
          this.append(name, headers[name]);
        });
      } else if (headers !== void 0) {
        throw new Error(
          `'headers' must be a dictionary or an array of array pairs. Found type ${typeof headers}.`
        );
      }
    }
    _validateName(name) {
      if (name === void 0) {
        throw new Error("The 'name' argument is required, but was not present.");
      }
      if (typeof name !== "string") {
        throw new Error(`The 'name' argument must be a 'string' type, not a '${typeof name}' type.`);
      }
      return name;
    }
    _validateValue(value) {
      if (value === void 0) {
        throw new Error("The 'value' argument is required, but was not present.");
      }
      if (typeof value !== "string" && !Array.isArray(value)) {
        throw new Error(
          `The 'value' argument must be a 'string' or 'array' type, not a '${typeof value}' type.`
        );
      }
      return value;
    }
    append(name, value) {
      if (value === null || value === void 0) {
        return;
      }
      if (Array.isArray(value)) {
        for (const v of value) {
          this[AppendFn](this[EdgioId], this._validateName(name), this._validateValue(v));
        }
      } else {
        this[AppendFn](this[EdgioId], this._validateName(name), this._validateValue(value));
      }
    }
    delete(name) {
      this[RemoveFn](this[EdgioId], this._validateName(name));
    }
    entries() {
      const entries = [];
      for (const key of this.keys()) {
        entries.push([key, this.get(key)]);
      }
      return entries;
    }
    forEach(callback) {
      for (const key of this.keys()) {
        callback(this.get(key), key);
      }
    }
    get(name) {
      const headers = this[GetFn](this[EdgioId], this._validateName(name));
      if (Array.isArray(headers))
        return headers.join(", ");
      return headers === void 0 ? null : headers;
    }
    _getValuesForKey(key) {
      const headers = this[GetFn](this[EdgioId], this._validateName(key));
      if (headers === void 0 || headers === null) {
        return [];
      }
      return headers;
    }
    getSetCookie() {
      return this._getValuesForKey("set-cookie");
    }
    has(name) {
      return this[CheckFn](this[EdgioId], this._validateName(name));
    }
    keys() {
      return this[KeysFn](this[EdgioId]);
    }
    set(name, value) {
      if (value === null || value === void 0) {
        return;
      }
      this[SetFn](this[EdgioId], this._validateName(name), this._validateValue(value));
    }
    values() {
      const values = [];
      for (const key of this.keys()) {
        values.push(this.get(key));
      }
      return values;
    }
    toJSON() {
      const json = {};
      for (const key of this.keys()) {
        json[key] = this.get(key);
      }
      return json;
    }
  }
  class EdgioResponseHeaders extends EdgioHeaders {
    constructor(responseId, headers) {
      super(responseId, headers, {
        appendFn: host.hostcall_resp_append_header,
        checkFn: host.hostcall_resp_check_header,
        getFn: host.hostcall_resp_get_header_values,
        keysFn: utility.resp_get_header_names,
        removeFn: host.hostcall_resp_remove_header,
        setFn: host.hostcall_resp_set_header
      });
    }
  }
  class EdgioRequestHeaders extends EdgioHeaders {
    constructor(requestId, headers) {
      super(requestId, headers, {
        appendFn: host.hostcall_req_append_header,
        checkFn: host.hostcall_req_check_header,
        getFn: host.hostcall_req_get_header_values,
        keysFn: utility.req_get_header_names,
        removeFn: host.hostcall_req_remove_header,
        setFn: host.hostcall_req_set_header
      });
    }
  }
  class HeadersInternal {
    constructor() {
      __publicField(this, "appendFn", (_requestId, key, value) => {
        if (!this._headers[key])
          this._headers[key] = [];
        this._headers[key].push(value);
      });
      __publicField(this, "checkFn", (_requestId, key) => {
        return !!this._headers[key];
      });
      __publicField(this, "getFn", (_requestId, key) => {
        if (!this._headers[key])
          return null;
        return this._headers[key];
      });
      __publicField(this, "getRawFn", () => {
        return this._headers;
      });
      __publicField(this, "keysFn", (_requestId) => {
        return Object.keys(this._headers);
      });
      __publicField(this, "removeFn", (_requestId, key) => {
        delete this._headers[key];
      });
      __publicField(this, "setFn", (_requestId, key, value) => {
        this._headers[key] = [value];
      });
      this._headers = {};
    }
  }
  globalThis.Headers = class Headers extends EdgioHeaders {
    constructor(headers) {
      const _headersInstance = new HeadersInternal();
      super(0, headers, {
        appendFn: _headersInstance.appendFn.bind(_headersInstance),
        checkFn: _headersInstance.checkFn.bind(_headersInstance),
        getFn: _headersInstance.getFn.bind(_headersInstance),
        keysFn: _headersInstance.keysFn.bind(_headersInstance),
        removeFn: _headersInstance.removeFn.bind(_headersInstance),
        setFn: _headersInstance.setFn.bind(_headersInstance)
      });
      __publicField(this, "getRaw", () => {
        return this._headersInstance.getRawFn();
      });
      this._headersInstance = _headersInstance;
    }
  };
  globalThis.Request = class {
    constructor(input, options) {
      this[Options] = options || {};
      this[BodyUsed] = false;
      if (typeof options?.edgio?.id === "number") {
        this[EdgioId] = options?.edgio?.id;
        this[ReqRespHeaders] = new EdgioRequestHeaders(this[EdgioId]);
        this[BodyOnHost] = true;
        return;
      }
      if (typeof input !== "string") {
        throw new Error(`"string" type is accepted for the input parameter, not '${typeof input}'`);
      }
      const url = input;
      if (this[Options].method !== void 0 && typeof this[Options].method !== "string") {
        throw new Error(
          `options.method must be type 'undefined' or 'string', not '${typeof this[Options].method}'`
        );
      }
      const method = this[Options].method || "GET";
      this[EdgioId] = host.hostcall_req_create(method, url);
      this[ReqRespHeaders] = new EdgioRequestHeaders(this[EdgioId], this[Options]?.headers || {});
      const body = this[Options].body;
      delete this[Options].body;
      this[BodyUsed] = false;
      if (body) {
        this[Body] = body;
      }
      this[BodyOnHost] = false;
    }
    blob() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'blob' method is not supported by the Request class.`
      );
    }
    get body() {
      const method = this.method;
      if (method === "GET" || method === "HEAD") {
        return null;
      }
      return new EdgioReadableRequestStream(this);
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    get cache() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'cache' property is not supported by the Request class.`
      );
    }
    get credentials() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'credentials' property is not supported by the Request class.`
      );
    }
    clone() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'clone' method is not supported by the Request class.`
      );
    }
    get destination() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'destination' property is not supported by the Request class.`
      );
    }
    formData() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'formData' method is not supported by the Request class.`
      );
    }
    get headers() {
      return this[ReqRespHeaders];
    }
    get integrity() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'integrity' property is not supported by the Request class.`
      );
    }
    get method() {
      const method = host.hostcall_req_get_method(this[EdgioId]);
      return method;
    }
    set method(method) {
      return host.hostcall_req_set_method(this[EdgioId], method);
    }
    get mode() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'mode' property is not supported by the Request class.`
      );
    }
    get redirect() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'redirect' property is not supported by the Request class.`
      );
    }
    get referrer() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'referrer' property is not supported by the Request class.`
      );
    }
    get referrerPolicy() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'referrerPolicy' property is not supported by the Request class.`
      );
    }
    get signal() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'signal' property is not supported by the Request class.`
      );
    }
    async arrayBuffer() {
      await this[MoveBodyToHost]();
      this[BodyUsed] = true;
      return host.hostcall_req_get_body(this[EdgioId]);
    }
    async text() {
      const buffer = await this.arrayBuffer();
      if (buffer.byteLength === 0) {
        return "";
      }
      return new TextDecoder(UTF_8).decode(buffer);
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get url() {
      return host.hostcall_req_get_uri(this[EdgioId]);
    }
    set url(uri) {
      return host.hostcall_req_set_uri(this[EdgioId], uri);
    }
    get path() {
      return host.hostcall_req_get_path(this[EdgioId]);
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        method: this.method,
        url: this.url,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_req_clone_without_body(this[EdgioId]);
      const req = new Request(null, {
        edgio: {
          id: clone_id
        }
      });
      this[ReqRespHeaders] = new EdgioRequestHeaders(clone_id);
      return req;
    }
    async [MoveBodyToHost]() {
      if (this[BodyOnHost]) {
        return;
      }
      const body = this[Body];
      if (body) {
        if (this.method === "GET" || this.method === "HEAD") {
          throw new Error("Request with GET/HEAD method cannot have body.");
        }
        const edgioId = this[EdgioId];
        if (typeof body === "string") {
          host.hostcall_debug(`new Request(${edgioId}, string: ${body})`);
          host.hostcall_req_set_body_from_string(edgioId, body);
        } else if (body instanceof ArrayBuffer) {
          host.hostcall_debug(`new Request(ArrayBuffer: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(edgioId, body);
        } else if (ArrayBuffer.isView(body)) {
          host.hostcall_debug(`new Request(TypedArray: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(edgioId, body.buffer);
        } else if (body instanceof ReadableStream) {
          host.hostcall_debug(`new Request(ReadableStream)`);
          for await (const chunk of body) {
            if (typeof chunk === "string") {
              host.hostcall_req_append_body_from_string(edgioId, chunk);
            } else if (chunk instanceof ArrayBuffer) {
              host.hostcall_req_append_body_from_array_buffer(edgioId, chunk);
            } else if (ArrayBuffer.isView(chunk)) {
              host.hostcall_req_append_body_from_array_buffer(edgioId, chunk.buffer);
            } else {
              const text = chunk?.toString();
              if (text) {
                host.hostcall_req_append_body_from_string(edgioId, chunk.toString());
              } else {
                throw new Error("new Request(ReadableStream: chunk is not string or ArrayBuffer)");
              }
            }
          }
        } else {
          host.hostcall_debug(`new Request(other: ${body.toString()})`);
          host.hostcall_req_set_body_from_string(edgioId, body.toString());
        }
      }
      this[Body] = null;
      this[BodyOnHost] = true;
    }
  };
  globalThis.Response = class {
    constructor(body, optionsOrResponse) {
      this[BodyUsed] = false;
      this[BodyOnHost] = false;
      this[Redirected] = false;
      this[Url] = null;
      if (typeof optionsOrResponse?.edgio?.id === "number") {
        this[EdgioId] = optionsOrResponse?.edgio?.id;
        this[ReqRespHeaders] = new EdgioResponseHeaders(this[EdgioId]);
        host.hostcall_debug(`_edgioNew Response: ${this[EdgioId]}`);
        this[BodyOnHost] = true;
        return;
      }
      if (optionsOrResponse instanceof Response) {
        const clone = optionsOrResponse.cloneWithoutBody();
        this[EdgioId] = clone[EdgioId];
        this[ReqRespHeaders] = clone[ReqRespHeaders];
        this[Redirected] = clone[Redirected];
        this[Url] = clone[Url];
      } else {
        this[Options] = optionsOrResponse || {};
        if (isNaN(this[Options].status))
          this[Options].status = 200;
        if (this[Options].status < 200 || this[Options].status > 599 || this[Options].status === 204 || this[Options].status === 304) {
          throw new Error(
            `The status provided ${this[Options].status} must be >= 200 and <= 599, and not 204 or 304.`
          );
        }
        this[EdgioId] = host.hostcall_resp_create(this[Options].status);
        this[ReqRespHeaders] = new EdgioResponseHeaders(this[EdgioId], this[Options]?.headers || {});
      }
      if (body) {
        this[Body] = body;
      }
    }
    blob() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'blob' method is not supported by the Response class.`
      );
    }
    get body() {
      if (this[BodyOnHost] || this[Body]) {
        return new EdgioReadableResponseStream(this);
      }
      return null;
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    clone() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'clone' method is not supported by the Response class.`
      );
    }
    formData() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'formData' method is not supported by the Response class.`
      );
    }
    get headers() {
      return this[ReqRespHeaders];
    }
    async arrayBuffer() {
      await this[MoveBodyToHost]();
      this[BodyUsed] = true;
      return host.hostcall_resp_get_body(this[EdgioId]);
    }
    async text() {
      const buffer = await this.arrayBuffer();
      if (buffer.byteLength === 0) {
        return "";
      }
      return new TextDecoder(UTF_8).decode(buffer);
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get ok() {
      let status = this.status;
      return status >= 200 && status < 300;
    }
    static redirect(url, status) {
      return new Response(void 0, { headers: { location: url }, status: status || 302 });
    }
    set redirected(newRedirected) {
      this[Redirected] = newRedirected;
    }
    get redirected() {
      return this[Redirected];
    }
    get status() {
      return host.hostcall_resp_get_status(this[EdgioId]);
    }
    get statusText() {
      return host.hostcall_resp_get_reason(this[EdgioId]);
    }
    get type() {
      throw new Error(
        `${INTERNAL_ERROR_PREFIX}The 'type' property is not supported by the Response class.`
      );
    }
    get url() {
      return this[Url];
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_resp_clone_without_body(this[EdgioId]);
      const resp = new Response(null, {
        edgio: {
          id: clone_id
        }
      });
      resp[Url] = this[Url];
      resp[Redirected] = this[Redirected];
      resp[ReqRespHeaders] = new EdgioResponseHeaders(clone_id);
      return resp;
    }
    async [SendToClient]() {
      await this[MoveBodyToHost]();
      host.hostcall_resp_send_to_client(this.edgioId);
    }
    async [MoveBodyToHost]() {
      if (this[BodyOnHost]) {
        return;
      }
      const body = this[Body];
      if (body === null || body === void 0) {
        return;
      }
      const edgioId = this[EdgioId];
      if (typeof body === "string") {
        host.hostcall_debug(`new Response(string: ${body})`);
        host.hostcall_resp_set_body_from_string(edgioId, body);
      } else if (body instanceof ArrayBuffer) {
        host.hostcall_debug(`new Response(ArrayBuffer: len=${body.byteLength})`);
        host.hostcall_resp_set_body_from_array_buffer(edgioId, body);
      } else if (ArrayBuffer.isView(body)) {
        host.hostcall_debug(`new Response(TypedArray: len=${body.byteLength})`);
        host.hostcall_resp_set_body_from_array_buffer(edgioId, body.buffer);
      } else if (body instanceof ReadableStream) {
        if (!supportsBodyChunkHostcalls) {
          throw new Error("ReadableStream is not supported by the Response class.");
        }
        host.hostcall_debug("new Response(ReadableStream)");
        for await (const chunk of body) {
          if (typeof chunk === "string") {
            host.hostcall_resp_append_body_from_string(edgioId, chunk);
          } else if (chunk instanceof ArrayBuffer) {
            host.hostcall_resp_append_body_from_array_buffer(edgioId, chunk);
          } else if (ArrayBuffer.isView(chunk)) {
            host.hostcall_resp_append_body_from_array_buffer(edgioId, chunk.buffer);
          } else {
            const text = chunk?.toString();
            if (text) {
              host.hostcall_resp_append_body_from_string(edgioId, chunk.toString());
            } else {
              throw new Error("new Response(ReadableStream: chunk is not string or ArrayBuffer)");
            }
          }
        }
      } else {
        host.hostcall_debug(`new Response(other: ${body.toString()})`);
        host.hostcall_resp_set_body_from_string(edgioId, body.toString());
      }
      this[Body] = null;
      this[BodyOnHost] = true;
    }
  };
  class ResponseError extends Error {
    constructor(responseErrorCode) {
      super();
      this[ErrorCode] = responseErrorCode;
    }
    get code() {
      return this[ErrorCode];
    }
    get message() {
      return host.hostcall_resp_get_error_code_message(this[ErrorCode]);
    }
    toString() {
      return `${this.message} (code: ${this.code})`;
    }
  }
  function EdgioDict(namespace) {
    const namespaces = { namespace };
    const dictProxy = new Proxy(namespaces, {
      get(target, property) {
        if (property === "get") {
          return function(key) {
            return host.hostcall_dict_get(target.namespace, key);
          };
        }
        if (property === "getBase64Decoded") {
          return function(key) {
            return new Uint8Array(host.hostcall_dict_get_base64_decoded(target.namespace, key));
          };
        }
        if (property === "has") {
          return function(key) {
            return host.hostcall_dict_check(target.namespace, key);
          };
        }
        if (property === "keys") {
          return function() {
            return utility.dict_get_keys(target.namespace);
          };
        }
        return host.hostcall_dict_get(target.namespace, property);
      },
      getOwnPropertyDescriptor(target, property) {
        return {
          value: host.hostcall_dict_get(target.namespace, property),
          writable: false,
          enumerable: true,
          configurable: true
        };
      },
      defineProperty(_target, _key, _descriptor) {
        return false;
      },
      deleteProperty(_target, _property) {
        return false;
      },
      has(target, property) {
        return host.hostcall_dict_check(target.namespace, property);
      },
      ownKeys(target) {
        return utility.dict_get_keys(target.namespace);
      }
    });
    return dictProxy;
  }
  class EdgioSet {
    constructor(namespace) {
      this[Namespace] = namespace;
    }
    has(key) {
      return host.hostcall_unique_set_check(this[Namespace], key);
    }
    keys() {
      return utility.unique_set_get_keys(this[Namespace]);
    }
    toJSON() {
      return this.keys();
    }
  }
  class EdgioMetrics {
    startTimer(index) {
      return host.hostcall_metrics_start_timer(index);
    }
    stopTimer(index) {
      return host.hostcall_metrics_stop_timer(index);
    }
    add(index, value) {
      return host.hostcall_metrics_add(index, value);
    }
  }
  function wrapFunctionCallWithMetrics(invocationCountId, microsecondTimerId, fn, ...args) {
    host.hostcall_metrics_add(invocationCountId, 1);
    host.hostcall_metrics_start_timer(microsecondTimerId);
    try {
      return fn(...args);
    } finally {
      host.hostcall_metrics_stop_timer(microsecondTimerId);
    }
  }
  const originalJSONparse = JSON.parse;
  const originalJSONstringify = JSON.stringify;
  globalThis.JSON = {
    parse: (...args) => {
      return wrapFunctionCallWithMetrics(
        WASM_METRIC_JSON_PARSE_INVOCATION_TOTAL,
        WASM_METRIC_JSON_PARSE_MICROSECONDS_TOTAL,
        originalJSONparse,
        ...args
      );
    },
    stringify: (...args) => {
      return wrapFunctionCallWithMetrics(
        WASM_METRIC_JSON_STRINGIFY_INVOCATION_TOTAL,
        WASM_METRIC_JSON_STRINGIFY_MICROSECONDS_TOTAL,
        originalJSONstringify,
        ...args
      );
    }
  };
  globalThis.module = {};
  globalThis.__dirname = "/";
  globalThis.__filename = "/index.js";
  globalThis.global = globalThis;
  globalThis.require = (moduleName) => {
    throw new Error(
      `The Node.js function "require('${moduleName}')" is not supported in edge-functions. Please refer to https://docs.edg.io/guides/v7/edge-functions#polyfills for more information.`
    );
  };
  if (supportsHtmlTransformer) {
    globalThis.HtmlTransformer = class HtmlTransformer {
      constructor(definitions, output_callback) {
        this[EdgioId] = utility.html_transformer_new(
          HtmlTransformer.hook_callbacks(definitions),
          output_callback
        );
      }
      async write(chunk) {
        return new Promise((resolve, reject) => {
          try {
            resolve(utility.html_transformer_write(this[EdgioId], chunk));
          } catch (e) {
            reject(e);
          }
        });
      }
      async end() {
        return new Promise((resolve, reject) => {
          try {
            resolve(utility.html_transformer_end(this[EdgioId]));
          } catch (e) {
            reject(e);
          }
        });
      }
      static hook_callbacks(definitions) {
        function makeProxy(className, rawPtr) {
          return new Proxy(
            { rawPtr },
            {
              get(target, property) {
                return (...args) => {
                  let proxyResults = utility.html_transformer_proxy(
                    className,
                    property.toString(),
                    target.rawPtr,
                    args
                  );
                  if (property === "start_tag") {
                    proxyResults = makeProxy("start_tag", proxyResults);
                  }
                  if (property === "attributes") {
                    for (let i = 0; i < proxyResults.length; i++) {
                      proxyResults[i] = makeProxy("attribute", proxyResults[i]);
                    }
                  }
                  return proxyResults;
                };
              }
            }
          );
        }
        if (definitions && Array.isArray(definitions)) {
          for (let i = 0; i < definitions.length; i++) {
            if (definitions[i].comment) {
              let originFn = definitions[i].comment;
              definitions[i].comment = (ptr) => {
                return originFn(makeProxy("comment", ptr));
              };
            }
            if (definitions[i].element) {
              let originFn = definitions[i].element;
              definitions[i].element = (ptr) => {
                return originFn(makeProxy("element", ptr));
              };
            }
            if (definitions[i].text) {
              let originFn = definitions[i].text;
              definitions[i].text = (ptr) => {
                return originFn(makeProxy("text", ptr));
              };
            }
            if (definitions[i].doc_comment) {
              let originFn = definitions[i].doc_comment;
              definitions[i].doc_comment = (ptr) => {
                return originFn(makeProxy("comment", ptr));
              };
            }
            if (definitions[i].doc_text) {
              let originFn = definitions[i].doc_text;
              definitions[i].doc_text = (ptr) => {
                return originFn(makeProxy("text", ptr));
              };
            }
            if (definitions[i].doc_type) {
              let originFn = definitions[i].doc_type;
              definitions[i].doc_type = (ptr) => {
                return originFn(makeProxy("doc_type", ptr));
              };
            }
            if (definitions[i].doc_end) {
              let originFn = definitions[i].doc_end;
              definitions[i].doc_end = (ptr) => {
                return originFn(makeProxy("doc_end", ptr));
              };
            }
          }
        }
        return definitions;
      }
    };
  }
  globalThis.TextDecoder = class TextDecoder {
    constructor(encoding) {
      this[Encoding] = encoding || UTF_8;
    }
    get fatal() {
      return false;
    }
    set fatal(value) {
      if (value) {
        throw new Error("TextDecoder.fatal is not supported");
      }
    }
    decode(buffer) {
      try {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_add(WASM_METRIC_TEXT_DECODE_INVOCATION_TOTAL, 1);
          host.hostcall_metrics_start_timer(WASM_METRIC_TEXT_DECODE_MICROSECONDS_TOTAL);
        }
        if (!buffer) {
          return "";
        }
        const array_buffer = ArrayBuffer.isView(buffer) ? buffer.buffer : buffer;
        if (!(array_buffer instanceof ArrayBuffer)) {
          throw new Error(
            `Decoding supported for ArrayBuffer, TypedArray and DataView, not ${typeof buffer}`
          );
        }
        return utility.text_decoder_decode(this[Encoding], array_buffer);
      } finally {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_stop_timer(WASM_METRIC_TEXT_DECODE_MICROSECONDS_TOTAL);
        }
      }
    }
  };
  function encode_value_to_string(value) {
    switch (typeof value) {
      case "undefined":
        return "";
      case "string":
        return value;
      default: {
        if (value === null) {
          return "null";
        }
        return value.toString();
      }
    }
  }
  globalThis.TextEncoder = class TextEncoder {
    constructor() {
    }
    encode(str) {
      try {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_add(WASM_METRIC_TEXT_ENCODE_INVOCATION_TOTAL, 1);
          host.hostcall_metrics_start_timer(WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL);
        }
        const value = encode_value_to_string(str);
        if (typeof value !== "string") {
          return new Uint8Array(0);
        }
        return new Uint8Array(utility.text_encoder_encode(value));
      } finally {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_stop_timer(WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL);
        }
      }
    }
    encodeInto(str, array) {
      try {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_add(WASM_METRIC_TEXT_ENCODE_INVOCATION_TOTAL, 1);
          host.hostcall_metrics_start_timer(WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL);
        }
        if (!(array instanceof Uint8Array)) {
          throw new Error("TextEncoder.encodeInto requires an Uint8Array");
        }
        const value = encode_value_to_string(str);
        if (array.byteLength === 0 || typeof value !== "string") {
          return {
            read: 0,
            written: 0
          };
        }
        return utility.text_encoder_encode_into(value, array);
      } finally {
        if (supportsMetricsOnTextEncoding) {
          host.hostcall_metrics_stop_timer(WASM_METRIC_TEXT_ENCODE_MICROSECONDS_TOTAL);
        }
      }
    }
    get encoding() {
      return UTF_8;
    }
  };
  let unhandled_rejection = null;
  let pending_fetches = /* @__PURE__ */ new Map();
  let wait_until_used_counter = 0;
  let wait_until_finished_counter = 0;
  function expect_number_of_args(args, expected) {
    if (args.length !== expected) {
      throw new Error(`Expected ${expected} arguments, got ${args.length}`);
    }
  }
  function expect_min_number_of_args(args, expected) {
    if (args.length < expected) {
      throw new Error(`Expected at least ${expected} arguments, got ${args.length}`);
    }
  }
  function create_context() {
    globalThis[Origins] = new EdgioSet(ENV_VAR_NAMESPACE_EDGIO_ORIGINS);
    globalThis.pump = (p) => {
      return manage_main_loop(p, true);
    };
    let context = {
      systemVars: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_CONFIG),
      environmentVars: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_PROPENVVAR),
      origins: globalThis[Origins],
      requestVars: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_USRVAR),
      geo: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_GEO),
      device: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_WURFL),
      client: EdgioDict(ENV_VAR_NAMESPACE_EDGIO_VIRT),
      metrics: new EdgioMetrics(),
      respondWith: function() {
        throw new Error(
          "respondWith() has been replaced with `return <response>` from the edge function itself."
        );
      },
      waitUntil: function(promise) {
        expect_number_of_args(arguments, 1);
        ++wait_until_used_counter;
        Promise.resolve(promise).finally(() => {
          ++wait_until_finished_counter;
        });
      }
    };
    if (supportsInitClearHostCall) {
      context.initClear = function() {
        host.hostcall_init_clear();
      };
    }
    return context;
  }
  function parseCookie(cookie) {
    const parts = cookie.split("=");
    const key = parts[0].trim();
    const value = parts[1];
    return { key, value };
  }
  function processSetCookies(options, response) {
    let deduplicatedCookies = {};
    const existingCookies = options.headers.cookie;
    if (existingCookies) {
      const individualCookies = existingCookies.split(";");
      for (let i = 0; i < individualCookies.length; i++) {
        const { key, value } = parseCookie(individualCookies[i]);
        deduplicatedCookies[key] = value;
      }
    }
    let setCookies = response.headers.get("set-cookie") || [];
    if (!Array.isArray(setCookies)) {
      setCookies = [setCookies];
    }
    for (let i = 0; i < setCookies.length; i++) {
      const { key, value } = parseCookie(setCookies[i].split(";")[0]);
      deduplicatedCookies[key] = value;
    }
    const keys = Object.keys(deduplicatedCookies);
    if (keys.length > 0) {
      options.headers.cookie = "";
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = deduplicatedCookies[key];
        options.headers.cookie += `${key}=${value}${i < keys.length - 1 ? "; " : ""}`;
      }
    }
  }
  async function handleRedirect(originalUrl, options, redirectedCount, response) {
    const location = response.headers.get("location");
    if ([301, 302, 303, 307, 308].indexOf(response.status) < 0 || !location) {
      response[Url] = originalUrl;
      response.redirected = redirectedCount > 0;
      return response;
    }
    const redirect = options.redirect;
    if (redirect === "error") {
      throw new Error("redirect");
    }
    if (redirect === "manual") {
      return response;
    }
    ++redirectedCount;
    processSetCookies(options, response);
    const newResponse = await issueFetch(location, options, redirectedCount);
    return newResponse;
  }
  async function issueFetch(urlOrRequest, options, redirectedCount) {
    let req;
    if (urlOrRequest instanceof Request) {
      req = urlOrRequest;
    } else {
      if (typeof urlOrRequest !== "string") {
        if (typeof urlOrRequest.toString !== "function" || urlOrRequest.toString() === "[object Object]") {
          throw new Error(
            'Invalid "url" argument in fetch() function. The "url" argument must be a string, a Request object, or an object where toString() returns the url.'
          );
        }
        urlOrRequest = urlOrRequest.toString();
      }
      req = new Request(urlOrRequest, options);
    }
    if (!options.edgio || !options.edgio.origin) {
      throw new Error(`edgio.origin must be included in the fetch options for ${urlOrRequest}`);
    }
    await req[MoveBodyToHost]();
    const origin = options.edgio.origin;
    try {
      host.hostcall_req_set_fetch_origin(req.edgioId, origin);
    } catch {
      throw new Error(
        `Invalid edgio.origin: "${origin}". Must be one of: ${globalThis[Origins].keys().join(
          ", "
        )}`
      );
    }
    function getOptionInt(options2, field, msg) {
      const value = options2[field];
      if (value !== void 0) {
        const iValue = parseInt(value);
        if (isNaN(iValue)) {
          throw new Error(`Invalid '${field}' value '${value}' specified. ${msg}`);
        }
        return iValue;
      }
    }
    const timeout = getOptionInt(
      options.edgio,
      "timeout",
      "Expected timeout in milliseconds as an integer."
    );
    if (timeout !== void 0) {
      try {
        host.hostcall_req_set_fetch_timeout(req.edgioId, timeout);
      } catch {
        throw new Error(`Failed to set fetch timeout on request.`);
      }
    }
    const caching = options.edgio.caching;
    if (supportsEapps409FetchOptions && caching) {
      const bypass_cache = caching.bypass_cache;
      if (bypass_cache !== void 0) {
        host.hostcall_req_set_fetch_bypass_cache(req.edgioId, !!bypass_cache);
      }
      if (caching.cache_key_query_string) {
        const exclude_all = caching.cache_key_query_string.exclude_all;
        if (exclude_all !== void 0) {
          host.hostcall_req_set_fetch_ckqs_exclude_all(req.edgioId, !!exclude_all);
        }
        const include_all = caching.cache_key_query_string.include_all;
        if (include_all !== void 0) {
          host.hostcall_req_set_fetch_ckqs_include_all(req.edgioId, !!include_all);
        }
      }
      if (caching.max_age !== void 0) {
        host.hostcall_req_set_fetch_max_age(req.edgioId, caching.max_age.toString());
      }
      if (supportsEapps563FetchTagUpsert) {
        if (caching.tags !== void 0) {
          host.hostcall_req_set_fetch_cache_tags(req.edgioId, caching.tags.toString());
        }
      }
      if (caching.stale_while_revalidate !== void 0) {
        host.hostcall_req_set_fetch_stale_while_revalidate(
          req.edgioId,
          caching.stale_while_revalidate.toString()
        );
      }
    }
    host.hostcall_req_fetch_async(req.edgioId);
    let resolve;
    let reject;
    const promise = new Promise((promise_resolve, promise_reject) => {
      resolve = promise_resolve;
      reject = promise_reject;
    });
    pending_fetches.set(req.edgioId, {
      promise,
      resolve,
      reject
    });
    const request_url = req.url;
    const response = await promise;
    return handleRedirect(request_url, options, redirectedCount, response);
  }
  globalThis.fetch = async function(urlOrRequest, options) {
    expect_min_number_of_args(arguments, 1);
    options = options || {};
    if (!options.redirect) {
      options.redirect = "follow";
    }
    if (!options.headers) {
      options.headers = {};
    }
    if (!options.edgio) {
      options.edgio = {};
    }
    const validRedirects = ["error", "follow", "manual"];
    if (validRedirects.indexOf(options.redirect) < 0) {
      throw new Error(
        `redirect must be one of "${validRedirects.join(", ")}", not "${options.redirect}"`
      );
    }
    if (!options.edgio.origin) {
      throw new Error(
        `edgio.origin must be specified as a fetch option. Must be one of: ${globalThis[Origins].keys().join(",")}`
      );
    }
    return issueFetch(urlOrRequest, options, 0);
  };
  const getEdgeFunction = edgeFunctions.get("__edge_function_init_script__");
  if (getEdgeFunction) {
    const edgeInitFunction = getEdgeFunction();
    if (typeof edgeInitFunction !== "function") {
      throw new Error(
        'Edge Initialization Function specified by Router option "edge_function_init_script" must have a named export "handleHttpInit". See https://docs.edg.io/guides/v7/edge-functions#defining-edge-functions for more information.'
      );
    }
    const context = create_context();
    const init_promise = Promise.resolve(edgeInitFunction.bind(globalThis)(context));
    manage_main_loop(init_promise, true);
  }
  return function main(edgioRequestId) {
    const context = create_context();
    const path = context.systemVars["__EDGE_FUNCTION_PATH__"];
    const getEdgeFunction2 = edgeFunctions.get(path);
    if (!getEdgeFunction2) {
      throw new Error(`No edge function found for path: ${path}`);
    }
    const edgeFunction = getEdgeFunction2();
    if (typeof edgeFunction !== "function") {
      throw new Error(
        'Edge Function must have a named export "handleHttpRequest". See https://docs.edg.io/guides/v7/edge-functions#defining-edge-functions for more information.'
      );
    }
    const req = new Request(null, {
      edgio: {
        id: edgioRequestId
      }
    });
    const main_promise = Promise.resolve(edgeFunction.bind(globalThis)(req, context));
    manage_main_loop(main_promise, false);
  };
  function manage_main_loop(main_promise, is_init_function) {
    let waiting_on_main_promise = true;
    const logPrefix = `sdk.js(${is_init_function ? "handleHttpInit" : "handleHttpRequest"}): `;
    host.hostcall_debug(`${logPrefix}start main loop`);
    main_promise.then(async (response) => {
      if (is_init_function) {
        if (response !== void 0) {
          host.hostcall_debug(`${logPrefix}return with non-undefined value, throwing exception`);
          throw new Error(
            `The handleHttpInit function must not return a value or a Promise (got ${typeof response})`
          );
        }
        host.hostcall_debug(`${logPrefix}return with undefined (as expected)`);
      } else {
        if (!(response instanceof Response)) {
          host.hostcall_debug(`${logPrefix}return with non-Response object, throwing exception`);
          throw new Error(
            `The handleHttpRequest function must return a Response or a Promise resolving to a Response (got ${typeof response})`
          );
        }
        host.hostcall_debug(`${logPrefix}return with response object, sending it to client`);
        await response[SendToClient]();
      }
    }).catch((err) => {
      unhandled_rejection = err;
    }).finally(() => {
      waiting_on_main_promise = false;
    });
    function jobs_are_pending() {
      return waiting_on_main_promise || wait_until_finished_counter < wait_until_used_counter;
    }
    while (jobs_are_pending()) {
      host.hostcall_debug(`${logPrefix}Executing pending jobs...`);
      utility.execute_pending();
      if (unhandled_rejection) {
        const err = unhandled_rejection;
        unhandled_rejection = null;
        throw err;
      }
      if (pending_fetches.size > 0) {
        const [is_response, req_id, resp_id_or_err_code] = host.hostcall_resp_await_next();
        host.hostcall_debug(
          `${logPrefix}hostcall_resp_await_next: is_response(${is_response}), req_id(${req_id}), resp_id_or_err_code(${resp_id_or_err_code})`
        );
        const pending_fetch = pending_fetches.get(req_id);
        if (!pending_fetch) {
          throw new Error(`${logPrefix}No pending fetch for ID ${req_id}`);
        }
        pending_fetches.delete(req_id);
        const { resolve, reject } = pending_fetch;
        if (is_response) {
          host.hostcall_debug(`${logPrefix}creating Response`);
          const resp = new Response(null, {
            edgio: {
              id: resp_id_or_err_code
            }
          });
          resolve(resp);
        } else {
          host.hostcall_debug(`${logPrefix}creating ResponseError`);
          const err = new ResponseError(resp_id_or_err_code);
          reject(err);
        }
      }
    }
    host.hostcall_debug(`${logPrefix}no more pending jobs`);
  }
};
//# sourceMappingURL=sdk.js.map
