"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Origin_1 = __importDefault(require("./Origin"));
const constants_1 = require("../constants");
/**
 * Helper class for fetching from origins
 * which allows to follow redirects to different origin.
 *
 * All redirect locations need to be configured in the edgio.config.js with exact hostname in
 * hostnames section otherwise the default origin will be used.
 *
 */
class OriginFetcher {
    constructor(propertyContext) {
        this.propertyContext = propertyContext;
    }
    /**
     * Fetches a response from the origin and follows redirects based on provided options.
     * @param req The request
     * @param res The response
     * @param options Additional options for this single fetch request
     * @param providedOriginName The origin name to be used. If not provided, the origin name will be extracted from the request.
     */
    async fetch(req, res, options, providedOriginName) {
        options = options || {};
        const originName = providedOriginName || this.propertyContext.getDefaultOrigin(req);
        const originConfig = this.propertyContext.getOrigin(originName);
        if (!originConfig) {
            throw new Error(`No origin was found with id=${originName}.`);
        }
        try {
            await new Origin_1.default(originConfig).fetch(req, res, options);
        }
        catch (e) {
            console.error(`Error fetching from origin ${originName}`, e);
            convertErrorToResponse(e, res);
        }
        // if we get 416, we're out of range -> we refetch full asset if ignoreUnsatisfiableRanges
        if (res.statusCode === 416 && options.ignoreUnsatisfiableRanges) {
            req.removeHeader(constants_1.HTTP_HEADERS.range);
            res.clear();
            return this.fetch(req, res, options);
        }
    }
    /**
     * Removes sensitive headers from the request.
     * @param req
     */
    removeSensitiveHeaders(req) {
        req.removeHeader('authorization');
        req.removeHeader('cookie');
    }
}
exports.default = OriginFetcher;
function convertErrorToResponse(e, res) {
    var _a;
    if (e instanceof Error) {
        res.setHeader(constants_1.HTTP_HEADERS.xEdgServerlessError, e.message);
        // @ts-ignore
        if (((_a = e.cause) === null || _a === void 0 ? void 0 : _a.code) === 'ETIMEDOUT') {
            res.statusCode = 504;
            res.statusMessage = 'Gateway Timeout';
            res.body = '504 - Gateway Timeout';
            return;
        }
        else {
            res.statusCode = 502;
            res.statusMessage = 'Bad Gateway';
            res.body = '502 - Bad Gateway';
            return;
        }
    }
    else {
        res.setHeader(constants_1.HTTP_HEADERS.xEdgServerlessError, e.toString());
    }
}
