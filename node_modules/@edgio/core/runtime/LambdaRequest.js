"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const qs_1 = require("qs");
const environment_1 = require("../environment");
const constants_1 = require("../constants");
/**
 * Data holder for lambda request.

 * Useful for cases when request needs to be created for:
 *    - lambda invocation / reqResMapper
 *    - findMatchingRules invocation
 *    - fiddle RequestContext invocation
 *    - tests (mainly ones invoking RequestContext directly)
 */
class LambdaRequest {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.url = '/';
        this.path = '/';
        this.rawHeaders = [];
        this.query = {};
        this.method = 'GET';
        this.protocol = 'http';
        this.secure = true;
        this.socket = { remoteAddress: '127.0.0.1', encrypted: true };
        this.connection = { encrypted: true };
        this.httpVersion = '1.1';
        this.port = '';
        this.options = options;
        this.url = options.url.pathname + ((_a = options.url.search) !== null && _a !== void 0 ? _a : '');
        this.query = (0, qs_1.parse)((_b = options.url.search) !== null && _b !== void 0 ? _b : '', { ignoreQueryPrefix: true });
        this.path = options.url.pathname;
        this.method = (_c = options.method) !== null && _c !== void 0 ? _c : this.method;
        // Compatibility with https://nodejs.org/api/all.html#http_message_headers
        // Header names *are* lower-cased to maintain Node compatibility.
        this.headers = normalizeHeaders((_d = options.headers) !== null && _d !== void 0 ? _d : {});
        options.url.host && this.setHeader('host', options.url.host);
        for (const key of Object.keys(this.headers)) {
            // Compatibility with https://nodejs.org/api/all.html#http_message_rawheaders
            // Header names are not lower-cased to maintain Node compatibility.
            const header = this.headers[key];
            for (const value of Array.isArray(header) ? header : [header]) {
                this.rawHeaders.push(key);
                this.rawHeaders.push(value);
            }
        }
        this.port = (_e = options.url.port) !== null && _e !== void 0 ? _e : this.port;
        this.httpVersion = (_f = options.httpVersion) !== null && _f !== void 0 ? _f : this.httpVersion;
        // TODO: make sure we have the right format here to match Sailfish. The value from lambda looks like: "x-edg-client-ip": "::ffff:54.152.158.42",
        // INFO: the header is not being sent from the edge, but by the lambda wrapper, therefore we can use it in permalink also
        // This is needed for matching on request.client_ip
        // For legacy reasons, we also support x-0-client-ip
        this.socket.remoteAddress = (this.getHeader(constants_1.HTTP_HEADERS.xEdgeClientIp) ||
            this.getHeader(constants_1.HTTP_HEADERS.x0ClientIp) ||
            this.socket.remoteAddress);
        if (options.url.protocol) {
            // protocol trails with ':', which is expected to be removed
            this.protocol = (_g = options.url.protocol) === null || _g === void 0 ? void 0 : _g.replace(':', '');
        }
        else if (!(0, environment_1.isLocal)()) {
            this.protocol = (this.getHeader(constants_1.HTTP_HEADERS.xEdgeProtocol) ||
                this.getHeader(constants_1.HTTP_HEADERS.x0Protocol) ||
                'https');
        }
        // req.secure is ExpressJS extension, set to false only when the app is running locally or the protocol is HTTP
        // (so the default remains HTTPS which has historically been the only protocol we allowed)
        this.secure = this.protocol === 'https';
        // Depending on the version req.socket.encrypted is set to true by NodeJS when the protocol is HTTPS.
        this.socket.encrypted = this.secure;
        // Depending on the version req.connection.encrypted is set to true by NodeJS when the protocol is HTTPS.
        this.connection.encrypted = this.secure;
        this.rawBody = Buffer.from((_h = options.body) !== null && _h !== void 0 ? _h : '');
    }
    /**
     * Returns a clone of the original request, before any properties were altered.
     */
    cloneOriginal() {
        return new LambdaRequest(this.options);
    }
    setHeader(name, value) {
        this.headers[name.toLowerCase()] = value;
    }
    getHeader(name) {
        return this.headers[name.toLowerCase()];
    }
    getHeaders() {
        return this.headers;
    }
    removeHeader(name) {
        delete this.headers[name.toLowerCase()];
    }
    get body() {
        return this.rawBody.toString('utf8');
    }
}
exports.default = LambdaRequest;
// sets all headers to lowercase names, and 'flattens' the array values if they contain only one element
function normalizeHeaders(headers) {
    let result = {};
    for (let name in headers) {
        const header = headers[name];
        result[name.toLowerCase()] =
            Array.isArray(header) && header.length === 1 ? header[0] : header;
    }
    return result;
}
