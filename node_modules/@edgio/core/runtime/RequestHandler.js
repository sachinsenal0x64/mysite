"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const config_1 = require("../config");
const Router_1 = __importDefault(require("../router/Router"));
const Cache_1 = __importStar(require("./Cache"));
const PropertyContext_1 = __importDefault(require("./PropertyContext"));
const RequestContext_1 = __importDefault(require("./RequestContext"));
const environment_1 = require("../environment");
const paths_1 = require("../deploy/paths");
const createEdgeConfig_1 = __importDefault(require("./createEdgeConfig"));
const edge_functions_1 = require("../deploy/edge-functions");
const constants_1 = require("../constants");
const log_1 = __importDefault(require("../log"));
const REDIRECT_STATUS_CODES = new Set([301, 302, 303, 307, 308]);
class RequestHandler {
    constructor(basedir, injectOrigins = []) {
        this.basedir = basedir;
        this.injectOrigins = injectOrigins;
        this.config = {};
        if ((0, Cache_1.isCacheEnabled)()) {
            this.cache = new Cache_1.default();
        }
        if ((0, environment_1.isProductionBuild)()) {
            // Load the config and router immediately if we are running a production build
            // We don't need to wait for a build like we do in dev mode.
            this.reload();
        }
    }
    reload(router, propertyContext) {
        var _a, _b;
        this.config = this.withOrigins((0, config_1.getConfig)(!(0, environment_1.isProductionBuild)()));
        const routerPath = (0, path_1.resolve)((0, path_1.join)(this.basedir, paths_1.ROUTES_FILE_NAME));
        this.router = router !== null && router !== void 0 ? router : Router_1.default.load(routerPath);
        this.propertyContext =
            propertyContext !== null && propertyContext !== void 0 ? propertyContext : new PropertyContext_1.default({
                ...this.config,
                edge_functions: {
                    quickjs_bytecode_base64: (_a = (0, edge_functions_1.getEdgeFunctionBytecode)(this.router.rules)) === null || _a === void 0 ? void 0 : _a.toString('base64'),
                },
            });
        delete require.cache[routerPath];
        (_b = this.cache) === null || _b === void 0 ? void 0 : _b.clear();
        return this.router;
    }
    withOrigins(config) {
        var _a;
        return {
            ...config,
            origins: [...((_a = config.origins) !== null && _a !== void 0 ? _a : []), ...this.injectOrigins],
        };
    }
    async handle(request, response) {
        try {
            if (this.router && this.propertyContext) {
                const serverlessHint = request.getHeader(constants_1.EDGIO_CLOUD_FUNCTIONS_HINT_HEADER);
                const context = this.createRequestContext(request, response);
                log_1.default.debug(`[RequestHandler] ${request.method} ${request.url}`);
                if (serverlessHint) {
                    // TODO: call when streaming from lambda is possible
                    // response.setDirectStream(true)
                    await context.executeServerless();
                }
                else {
                    await context.executeSimulator();
                }
                log_1.default.debug(`[RequestHandler] response status: ${response.statusCode} ${response.statusMessage || ''}`);
                if (context.followRedirects && REDIRECT_STATUS_CODES.has(response.statusCode)) {
                    context.followRedirects = false;
                    await this.handleRedirects(request, response);
                    // Sailfish only allows a single redirect. If the user attempts a second, it will throw a 500 error.
                    if (context.followRedirects && REDIRECT_STATUS_CODES.has(response.statusCode)) {
                        throw new Error('Too many internal redirects');
                    }
                }
            }
            else {
                throw new Error('Server not yet initialized.');
            }
        }
        catch (e) {
            // we clear any current chunks (could be there if error happens during proxy, computes, and other stuff that doesnt stream)
            response.clear();
            response.statusCode = 500;
            response.statusMessage = 'Internal Server Error';
            response.write(JSON.stringify({ error: e.stack }));
            response.end();
            response.stream();
            await response.waitForFlush();
        }
    }
    createRequestContext(request, response) {
        var _a;
        return new RequestContext_1.default({
            request,
            response,
            propertyContext: this.propertyContext,
            rules: this.router.rules,
            edgeFunctions: {
                quickjs_bytecode_base64: (_a = (0, edge_functions_1.getEdgeFunctionBytecode)(this.router.rules)) === null || _a === void 0 ? void 0 : _a.toString('base64'),
            },
            cache: this.cache,
            functions: this.router.functions,
            interpolationValues: this.config.interpolationValues,
        });
    }
    /**
     * Simulates the Sailfish front end behavior of following redirects.
     * This is needed to implement retry.
     * @param request
     * @param response
     */
    async handleRedirects(request, response) {
        const location = response.getHeader('location');
        const url = new URL(location);
        log_1.default.debug(`[RequestHandler] Following redirect to ${location}`);
        // Clone the request and use the redirect location as the URL
        const clone = request.cloneOriginal();
        clone.url = url.pathname + url.search;
        clone.path = url.pathname;
        // Undo any changes to the response made by the original request
        response.clear();
        response.statusCode = 200;
        response.statusMessage = 'OK';
        response.body = '';
        Object.keys(response.getHeaders()).forEach(header => response.removeHeader(header));
        await this.handle(clone, response);
    }
    createEdgeConfig() {
        if (this.router && this.propertyContext) {
            return (0, createEdgeConfig_1.default)(this.propertyContext, this.router);
        }
        else {
            throw new Error('Not yet initialized.');
        }
    }
    createPreloadConfig() {
        if (!this.router) {
            throw new Error('Not yet initialized.');
        }
        return this.router.preloadRequests.getPreloadConfig();
    }
}
exports.default = RequestHandler;
