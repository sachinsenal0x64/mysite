/// <reference types="node" />
import CacheKey from './CacheKey';
import LRU from 'lru-cache';
import RequestContext from './RequestContext';
import Response from './Response';
import LambdaResponse from './LambdaResponse';
/**
 * We store the responses in the cache differently from their actual
 * representation because they are different classes in different
 * execution environments.
 */
export interface CachedResponse {
    /**
     * The HTTP status code
     */
    statusCode: number;
    /**
     * The HTTP status message
     */
    statusMessage?: string;
    /**
     * The response body as a array of chunks - done this way in order to replicate the behaviour
     * of the initial, non-cached response.
     */
    chunks: Buffer[];
    /**
     * The response HTTP headers
     */
    headers: {
        [key: string]: string | string[];
    };
    /**
     * The time the response was put in the cache
     */
    cachedAt: number;
    /**
     * The time to live of the response
     */
    ttl: number;
    /**
     * True if the response should be returned stale and revalidated
     */
    serveStaleUntil?: number;
}
export interface CacheLookupResult {
    response: CachedResponse;
    revalidate: boolean;
}
export interface AddToCacheOptions {
    response: Response;
    cacheKey: CacheKey;
    context: RequestContext;
}
export interface CacheConfig {
    ttl: number;
    staleWhileRevalidate?: number;
}
/**
 * Must have the EDGIO_LOCAL_CACHE environment variable set.
 */
export declare function isCacheEnabled(): boolean;
/**
 * Local simulation of Edgio's edge cache
 */
export default class Cache {
    private cache;
    private revalidationCache;
    /**
     * Evicts all entries from the cache
     */
    clear(): void;
    /**
     * Returns the cached response for the specified key
     * @param key The cache key
     */
    get(key: CacheKey): CacheLookupResult | undefined;
    /**
     * Stores a response in the cache
     * @param cacheKey
     * @param response
     * @param maxAge
     */
    put(cacheKey: CacheKey, response: LambdaResponse, { ttl, staleWhileRevalidate }: {
        ttl: number;
        staleWhileRevalidate?: number;
    }): void;
    isRevalidating(cacheKey: CacheKey): boolean;
    setRevalidating(cacheKey: CacheKey, value: boolean): void;
    dump(): [string, LRU.Entry<CachedResponse>][];
}
