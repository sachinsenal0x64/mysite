"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RulesVisitor_1 = __importDefault(require("./RulesVisitor"));
/**
 * Formatter that allows to format the rules for edge-control.
 */
class RulesFormatter {
    constructor() {
        this.rulesVisitor = new RulesVisitor_1.default({
            onFeaturesVisit: (features) => {
                this.formatResponseSetResponseBody(features);
                this.formatCachingMaxAge(features);
            },
        });
    }
    /**
     * Formats the rules for edge-control.
     * The rules are deep-cloned by default before we format them.
     * @param rules
     * @param clone
     */
    format(rules, clone = true) {
        // Deep-clone the rules by default to get rid of any references to the original.
        const changedRules = clone ? JSON.parse(JSON.stringify(rules)) : rules;
        this.rulesVisitor.visit(changedRules);
        return changedRules;
    }
    /**
     * Transforms set_response_body property by encoding it to base64.
     * @param features
     */
    formatResponseSetResponseBody(features) {
        const { response } = features;
        if (response === null || response === void 0 ? void 0 : response.set_response_body) {
            // set_response_body is expected to be in base64
            response.set_response_body = Buffer.from(response.set_response_body).toString('base64');
        }
    }
    /**
     * Transforms max_age property with string value by converting it
     * to equivalent object notation with status codes as keys and time interval as values.
     * @param features
     */
    formatCachingMaxAge(features) {
        const { caching } = features;
        if ((caching === null || caching === void 0 ? void 0 : caching.max_age) && typeof (caching === null || caching === void 0 ? void 0 : caching.max_age) === 'string') {
            // when notation with status codes is used we need add
            // time interval to each status code from cacheable_status_codes array
            // to preserve the same behavior
            const statusCodes = [200, ...((caching === null || caching === void 0 ? void 0 : caching.cacheable_status_codes) || [])];
            const timeInterval = caching.max_age;
            caching.max_age = {};
            statusCodes.forEach(statusCode => (caching.max_age = {
                ...caching.max_age,
                [statusCode.toString()]: timeInterval,
            }));
        }
    }
}
exports.default = RulesFormatter;
