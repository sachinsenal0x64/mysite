"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.operatorsMap = void 0;
const RulesVisitor_1 = __importDefault(require("./RulesVisitor"));
const constants_1 = require("./constants");
const toRegExp_1 = __importDefault(require("../toRegExp"));
const toPathRegexp_1 = __importDefault(require("../../utils/toPathRegexp"));
/**
 * This operator map provides the functions which are used to evaluate the conditionals.
 * The key is the operator name, the value is the function which accepts two operands (left and right side of condition).
 */
exports.operatorsMap = {
    [constants_1.EQUALS]: (l, r) => l === r,
    [constants_1.NOT_EQUALS]: (l, r) => l !== r,
    [constants_1.EQUALS_EXPRESS]: (l, r) => { var _a; return (0, toPathRegexp_1.default)(r).test((_a = l === null || l === void 0 ? void 0 : l.toString()) !== null && _a !== void 0 ? _a : ''); },
    [constants_1.NOT_EQUALS_EXPRESS]: (l, r) => { var _a; return !(0, toPathRegexp_1.default)(r).test((_a = l === null || l === void 0 ? void 0 : l.toString()) !== null && _a !== void 0 ? _a : ''); },
    [constants_1.LESS_THAN]: (l, r) => Number(l) < Number(r),
    [constants_1.LESS_THAN_OR_EQUALS]: (l, r) => Number(l) <= Number(r),
    [constants_1.GREATER_THAN]: (l, r) => Number(l) > Number(r),
    [constants_1.GREATER_THAN_OR_EQUALS]: (l, r) => Number(l) >= Number(r),
    [constants_1.MATCHES]: (l, r) => { var _a; return (0, toRegExp_1.default)(r).test((_a = l === null || l === void 0 ? void 0 : l.toString()) !== null && _a !== void 0 ? _a : ''); },
    [constants_1.NOT_MATCHES]: (l, r) => { var _a; return !(0, toRegExp_1.default)(r).test((_a = l === null || l === void 0 ? void 0 : l.toString()) !== null && _a !== void 0 ? _a : ''); },
    [constants_1.IN]: (l, r) => r === null || r === void 0 ? void 0 : r.some((item) => (l === null || l === void 0 ? void 0 : l.toString()) === (item === null || item === void 0 ? void 0 : item.toString())),
    [constants_1.NOT_IN]: (l, r) => !(r === null || r === void 0 ? void 0 : r.some((item) => (l === null || l === void 0 ? void 0 : l.toString()) === (item === null || item === void 0 ? void 0 : item.toString()))),
};
/**
 * Visitor for the Rules which visits each node of the Rules structure
 * and call callbacks for each node type only if the Rule's condition is evaluated to true.
 */
class RulesConditionalVisitor extends RulesVisitor_1.default {
    constructor(evalVariableCallback, callbacks = {}) {
        super(callbacks);
        this.evalVariableCallback = evalVariableCallback;
    }
    /**
     * This method is called when we visit Matches node.
     * It calls visitFeatures/visitRules if the Matches condition is evaluated to true.
     * @param matches
     * @param ruleIndex
     */
    visitMatches(matches, ruleIndex) {
        var _a, _b;
        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onMatchesVisit) === null || _b === void 0 ? void 0 : _b.call(_a, matches, ruleIndex);
        const ifStatement = matches === null || matches === void 0 ? void 0 : matches.if;
        if (!ifStatement)
            return;
        let conditionIndex = 0;
        while (conditionIndex < matches.if.length) {
            const ifIndex = conditionIndex;
            const thenIndex = conditionIndex + 1;
            const elseIndex = conditionIndex + 2;
            const isLastCondition = elseIndex === matches.if.length - 1;
            const condition = ifStatement[ifIndex];
            let conditionResult = false;
            // Evaluate the condition by evaluating the nested nodes
            if (this.isConditionals(condition)) {
                conditionResult = this.evalConditionals(condition, ruleIndex);
            }
            else if (this.isBoolean(condition)) {
                conditionResult = this.evalBoolean(condition, ruleIndex);
            }
            else {
                throw new Error(`Unsupported operator "${Object.keys(condition).pop()}".`);
            }
            // If the condition is met, we visit the 'then' Features,
            // otherwise we visit the last 'else' Features.
            if (conditionResult) {
                this.visitFeaturesOrRules(ifStatement[thenIndex], ruleIndex);
            }
            else if (isLastCondition) {
                this.visitFeaturesOrRules(ifStatement[elseIndex], ruleIndex);
            }
            // We're done if this is the last Condition in Rule
            if (isLastCondition) {
                break;
            }
            // If the condition isn't last, we have an 'else-if' statement.
            // We update the index to point to the 'if' statement of it, and redo the loop.
            conditionIndex += 2;
        }
    }
    /**
     * Returns true if provided Boolean is evaluated to true.
     * @param boolean
     * @param ruleIndex
     * @example
     * evalConditionals({
     *   "and": [
     *     {
     *       "==": [
     *         {
     *           "request": "path"
     *         },
     *         "/:path"
     *       ]
     *     },
     *     {
     *       "or": [
     *           {
     *              "==": [
     *                {
     *                  "request": "path"
     *                },
     *                "/:path"
     *              ]
     *           }
     *       ]
     *     }
     *   ]
     * }) => true
     */
    evalBoolean(boolean, ruleIndex) {
        var _a, _b;
        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onBooleanVisit) === null || _b === void 0 ? void 0 : _b.call(_a, boolean, ruleIndex);
        const booleanItemHandler = (item) => {
            if (this.isBoolean(item))
                return this.evalBoolean(item, ruleIndex);
            return this.evalConditionals(item, ruleIndex);
        };
        if (boolean[constants_1.AND]) {
            return boolean[constants_1.AND].every(booleanItemHandler);
        }
        if (boolean[constants_1.OR]) {
            return boolean[constants_1.OR].some(booleanItemHandler);
        }
        return false;
    }
    /**
     * Returns true if provided Conditionals is met, false otherwise.
     * @param conditionals
     * @param ruleIndex
     * @example
     * evalConditionals({
     *     "==": [
     *        {
     *          "request": "path"
     *        },
     *        "/:path"
     *     ]
     * }) => true
     */
    evalConditionals(conditionals, ruleIndex) {
        var _a, _b;
        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onConditionalsVisit) === null || _b === void 0 ? void 0 : _b.call(_a, conditionals, ruleIndex);
        const operators = Object.keys(conditionals);
        if (operators.length !== 1) {
            throw new Error(`Conditional statements must contain a single operator. The following operators were found: ${operators.join(', ')}`);
        }
        const [operator, condition] = Object.entries(conditionals)[0];
        return this.evalCondition(condition, operator, ruleIndex);
    }
    /**
     * Returns true if provided Condition is met, false otherwise.
     * @param condition
     * @param operator
     * @param ruleIndex
     * @example
     * evalCondition([
     *     {
     *          "request": "path"
     *     },
     *     "/:path"
     * ], "==") => true
     */
    evalCondition(condition, operator, ruleIndex) {
        var _a, _b, _c;
        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onConditionVisit) === null || _b === void 0 ? void 0 : _b.call(_a, condition, operator, ruleIndex);
        const [left, right] = condition.map((operand) => this.evalOperand(operand));
        return (_c = exports.operatorsMap === null || exports.operatorsMap === void 0 ? void 0 : exports.operatorsMap[operator]) === null || _c === void 0 ? void 0 : _c.call(exports.operatorsMap, left, right);
    }
    /**
     * Evaluates an operands, which may be a constant or RulesVariable instance.
     * @param operand
     * @returns
     */
    evalOperand(operand) {
        if (operand == null ||
            typeof operand === 'string' ||
            typeof operand === 'boolean' ||
            typeof operand === 'number' ||
            Array.isArray(operand)) {
            return operand;
        }
        return this.evalVariableCallback(operand);
    }
}
exports.default = RulesConditionalVisitor;
