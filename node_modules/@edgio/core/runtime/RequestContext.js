"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cookie_1 = require("cookie");
const CacheKey_1 = __importDefault(require("./CacheKey"));
const first_1 = __importDefault(require("../utils/first"));
const Phase_1 = __importDefault(require("./Phase"));
const ModRewrite_1 = __importDefault(require("./mods/ModRewrite"));
const ModCache_1 = __importDefault(require("./mods/ModCache"));
const ModAccess_1 = __importDefault(require("./mods/ModAccess"));
const ModSetEnv_1 = __importDefault(require("./mods/ModSetEnv"));
const ModProxyCore_1 = __importDefault(require("./mods/ModProxyCore"));
const ModProxyFeatures_1 = __importDefault(require("./mods/ModProxyFeatures"));
const ModRedirect_1 = __importDefault(require("./mods/ModRedirect"));
const log_1 = __importDefault(require("../log"));
const constants_1 = require("../constants");
const origins_1 = require("../origins");
const Origin_1 = __importDefault(require("./Origin"));
const ModEdgeFunctions_1 = __importDefault(require("./mods/ModEdgeFunctions"));
const interpolate_1 = require("./interpolate");
const LambdaResponse_1 = __importDefault(require("./LambdaResponse"));
const path_1 = __importDefault(require("path"));
const ModTranscode_1 = __importDefault(require("./mods/ModTranscode"));
const ModStream_1 = __importDefault(require("./mods/ModStream"));
const executePlan_1 = __importDefault(require("./executePlan"));
const RulesConditionalVisitor_1 = __importDefault(require("./rules/RulesConditionalVisitor"));
class RequestContext {
    constructor({ request, response, propertyContext, rules, cache, functions, interpolationValues, variables, location, device, stdout, stderr, edgeFunctions, }) {
        this.functions = {};
        this.useCacheFile = false;
        this.bypassCache = false;
        this.bypassCacheByHonor = false;
        this.revalidate = false;
        this.followRedirects = false;
        this.ignoreUnsatisfiableRanges = false;
        this.executingSimulator = false;
        this.originResponseStatus = undefined;
        this.revalidation = null;
        this.revalidateResponse = null;
        this.returnEarly = false;
        /**
         * The stdout writable stream to which the edge functions, if there are such, will write.
         */
        this.stdout = process === null || process === void 0 ? void 0 : process.stdout;
        /**
         * The stderr writable stream to which the edge functions, if there are such, will write.
         */
        this.stderr = process === null || process === void 0 ? void 0 : process.stderr;
        this.request = request;
        this.cacheKey = new CacheKey_1.default(request);
        this.response = response;
        this.propertyContext = propertyContext;
        this.rules = rules;
        this.edgeFunctions = edgeFunctions;
        this.cookies = (0, cookie_1.parse)((0, first_1.default)(request.headers['cookie'] || ''));
        this.variables = variables !== null && variables !== void 0 ? variables : {};
        this.cache = cache;
        this.originalPath = this.request.path;
        this.originalQuery = this.request.query;
        this.originalQueryString = new URL(request.url, 'http://localhost').search;
        this.functions = functions;
        this.interpolationValues = interpolationValues;
        this.stdout = stdout || process.stdout;
        this.stderr = stderr || process.stderr;
        // todo: This is hardcoded value, consider adding an option to override it
        // this is only used in dev mode, we cannot end in execution plan if we are in dev mode
        this.device = device !== null && device !== void 0 ? device : {
            device_os: 'iOS',
            brand_name: 'Apple',
            dual_orientation: 'true',
            html_preferred_dtd: 'html5',
            image_inlining: 'partial',
            is_android: 'false',
            is_app: 'true',
            is_full_desktop: 'false',
            is_html_preferred: 'true',
            is_ios: 'true',
            is_largescreen: 'true',
            is_mobile: 'false',
            is_robot: 'false',
            is_smartphone: 'false',
            is_smarttv: 'false',
            is_tablet: 'false',
            is_touchscreen: 'false',
            is_windows_phone: 'false',
            is_wireless_device: 'false',
            is_wml_preferred: 'false',
            marketing_name: 'iPhone',
            mobile_browser: 'Safari',
            model_name: 'iPhone',
            pointing_method: 'touchscreen',
            preferred_markup: 'html_wi_w3_xhtmlbasic',
            progressive_download: 'true',
            release_date: '2011',
            resolution_height: '1136',
            resolution_width: '640',
            ux_full_desktop: 'false',
            xhtml_support_level: '1',
        };
        // TODO check that these are accurate
        // this is only used in dev mode, we cannot end in execution plan if we are in dev mode
        this.location = location !== null && location !== void 0 ? location : {
            asn: 'Telia Eesti',
            city: 'Tallinn',
            continent: 'Europe',
            dms_code: '',
            country: 'EE',
            latitude: '59.433',
            longitude: '24.7323',
            postal_code: '11911',
            region_code: 'EU',
        };
        const modRewrite = new ModRewrite_1.default(this);
        const modCache = new ModCache_1.default(this);
        const modAccess = new ModAccess_1.default(this);
        const modSetEnv = new ModSetEnv_1.default(this);
        const modProxyCore = new ModProxyCore_1.default(this);
        const modProxyFeatures = new ModProxyFeatures_1.default(this);
        const modRedirect = new ModRedirect_1.default(this);
        const modEdgeFunctions = new ModEdgeFunctions_1.default(this);
        const modTranscode = new ModTranscode_1.default(this);
        const modStream = new ModStream_1.default(this);
        this.revalidatePlan = [
            {
                phase: Phase_1.default.SendRequestContent,
                modules: [modEdgeFunctions, modProxyCore, modSetEnv],
            },
            {
                phase: Phase_1.default.HandleResponseDone,
                modules: [modRedirect, modSetEnv, modStream, modCache],
            },
        ];
        this.simulatorPlan = [
            {
                phase: Phase_1.default.UriRaw,
                modules: [modRewrite],
            },
            {
                phase: Phase_1.default.UriClean,
                modules: [modAccess, modRedirect, modSetEnv, modCache, modProxyFeatures, modStream],
            },
            {
                phase: Phase_1.default.HandleDocRoot,
                modules: [modCache, modTranscode],
            },
            ...this.revalidatePlan,
        ];
        this.writeHeadPlan = [
            {
                phase: Phase_1.default.HandleResponseHeader,
                modules: [modSetEnv, modCache, modTranscode],
            },
        ];
        this.streamPlan = [
            {
                phase: Phase_1.default.StreamResponse,
                modules: [modTranscode, modStream],
            },
        ];
        this.appPlan = [
            {
                phase: Phase_1.default.StreamResponse,
                modules: [modTranscode],
            },
        ];
    }
    /**
     * Executes all phases of the request lifecycle, applying features based on the configured rules.
     */
    async executeSimulator() {
        this.executingSimulator = true;
        // we setup streaming - this can be disabled through response.DisableStreaming in mods as needed
        this.response.setOnStream(async () => await this.executeStreamResponse());
        await (0, executePlan_1.default)(this.simulatorPlan);
        /**
         * We try to stream for cases, where the response wasnt streamed already.
         *
         * We need to do it separately, as we use early returns to stop simulator,
         * which would cause response not to be streamed. For example with set_done.
         *
         * If we wish to avoid this, we should replace EarlyReturn errors with
         * flag, which every mod can decide to act upon or not.
         */
        await (0, executePlan_1.default)(this.streamPlan);
        // we revalidate, but dont block the downstream processing / sending response back - but still save the promise for simpler testing
        this.revalidation = new Promise(resolve => this.executeRevalidate().then(resolve));
    }
    /**
     * Processes the request based on EDGIO_CLOUD_FUNCTIONS_HINT_HEADER, if present.
     *
     * Multiple hints can be provided, separated by comma - where generally last one will be executed.
     * The exception is redirect, which takes precedence over anything else, as non-compute redirect
     * doesn't hit the compute at all, and only returns location in header back downstream.
     *
     * Multiple hints provide us the flexibility to use compute when the rules arent enough,
     * WITHOUT changing the functionality.
     *
     * Example:
     *  curl -H "x-cloud-functions-hint:compute:0" -v http://127.0.0.1:3000/compute
     *
     * @returns true if a hints were handled, otherwise false
     */
    async executeServerless() {
        const hintHeader = this.request.getHeader(constants_1.EDGIO_CLOUD_FUNCTIONS_HINT_HEADER);
        if (!hintHeader) {
            log_1.default.trace('No cloud function hints found.');
            return false;
        }
        // We get the serverless and INVERT THE ORDER, as generally the LAST ONE should be executed.
        // We need to run trim to get rid of extra spaces, which might be added by Sailfish.
        const hintsWithValue = hintHeader
            .split(',')
            .reverse()
            .map(hintWithValue => hintWithValue.trim());
        // We search for redirect hint - when redirect is defined through edge, it will NEVER hit compute,
        // therefore we simulate that behaviour, and redirect takes precedence before anything else, and early exits.
        const redirectHint = hintsWithValue.find(value => value.startsWith(constants_1.EDGIO_CLOUD_FUNCTIONS_HINTS.redirect));
        if (redirectHint) {
            await this.handleHint(redirectHint);
        }
        else {
            // If redirect isnt found, we just execute the last hint, as they overwrite. Note - Hints are in reverse order here.
            const hintToRun = hintsWithValue[0];
            await this.handleHint(hintToRun);
        }
        this.response.clear();
        // We expect user to update response's body - we dont allow him to stream (historically) directly from compute.
        // For streaming from compute, other means should be implemented - eg. something like ComputeStream.
        this.response.body && this.response.write(this.response.body);
        this.response.end();
        // If we arent in simulator, we need to stream the response.
        if (!this.executingSimulator) {
            // We run the response through custom plan, which reencodes the response as needed, streams it.
            // This is not a plan that matches sailfish - we just use it to reuse mods and existing plan executor.
            await (0, executePlan_1.default)(this.streamPlan);
        }
        return true;
    }
    /**
     * Processes the request based on provided hint.
     * @returns true if a hint was handled, otherwise false
     */
    async handleHint(hintWithValue) {
        log_1.default.trace(`Executing cloud function hint: '${hintWithValue}'`);
        const hint = hintWithValue.split(':').shift() || '';
        const value = hintWithValue.split(':').pop() || '';
        if (hint === constants_1.EDGIO_CLOUD_FUNCTIONS_HINTS.app) {
            // IF we're not inside of simulator, we ALWAYS stream. Otherwise, we must respect what simulator already defined.
            // The reason is that 'handleHint' function is invoked DIRECTLY in ModProxyCore/Backend.
            !this.executingSimulator && this.response.setIsStreamable(true);
            // Will get here when behind the edge to skip directly to fetching the response from the internal app server
            // started by the connector.
            await this.executeApp();
            return true;
        }
        // If value exists, we execute serverless function
        if (value !== '') {
            // Will get here when behind the edge to skip directly to running the callback passed to RouteHelper#compute
            await this.executeCompute(value);
            return true;
        }
        log_1.default.trace(`Cloud function hint with name '${hint}' was not found.`);
        return false;
    }
    async executeApp() {
        log_1.default.debug(`skipping to app`);
        this.response.setOnStream(async () => await this.executeStreamResponse());
        const appOrigin = this.propertyContext.getOrigin(origins_1.SERVERLESS_ORIGIN_NAME);
        await new Origin_1.default(appOrigin).fetch(this.request, this.response);
    }
    async executeCompute(functionIndex) {
        const fn = this.functions[functionIndex];
        if (!fn) {
            throw new Error(`Cloud function with index '${functionIndex}' not found.`);
        }
        log_1.default.debug(`[RequestContext] skipping to compute, function #${functionIndex}`);
        await fn(this.request, this.response, this.propertyContext);
    }
    /**
     * Revalidates a cached response, fetching it from the origin and adding it to the cache if possible.
     */
    async executeRevalidate() {
        if (this.revalidate) {
            // we create new, fake response to avoid:
            //    - rewriting during downstream processing (esp. in dev environment, as the response is sent directly back)
            //    - having unwanted data from previous response (response headers are not removed in Backend.fetch)
            // is used only used as a data holder / helper method provider for saving into cache
            this.revalidateResponse = new LambdaResponse_1.default();
            this.useCacheFile = false;
            this.bypassCache = false;
            await (0, executePlan_1.default)(this.revalidatePlan);
            log_1.default.debug(`Revalidated ${this.originalPath}.`);
        }
    }
    /**
     * Function responsible for writing / streaming content back to the user, running relevant mods if needed.
     * We do not care about ending the stream here - that is done after the whole chain processes, in RequestHandler.
     *
     * If called after response has been streamed, does nothing.
     */
    async executeStreamResponse() {
        const response = this.getResponse();
        if (!response.isHeadersStreamed) {
            // we process mods only if this function is called as part of simulator processing
            if (this.executingSimulator) {
                // We need to update the headers through ModSetEnv and ModCache as is done in sailfish.
                await (0, executePlan_1.default)(this.writeHeadPlan);
            }
            else {
                // we know we're just streaming app content here - we need to setup encoding pipes - executing simple single mod plan
                await (0, executePlan_1.default)(this.appPlan);
            }
        }
        await response.stream();
    }
    /**
     * Calls the specified callback for each rule that matches the current state.
     * @param callback
     */
    forEachMatchingRule(callback) {
        new RulesConditionalVisitor_1.default(this.evalVariable.bind(this), {
            onFeaturesVisit: callback,
        }).visit(this.rules);
    }
    /**
     * Calls the specified callback for last matching rule.
     * @param callback return true to confirm the match
     */
    forLastMatchingRule(callback) {
        const conditionalVisitor = new RulesConditionalVisitor_1.default(this.evalVariable.bind(this));
        conditionalVisitor.onFeaturesVisit((features, ruleIndex) => {
            // When callback returns true, we stop the visitor.
            if (callback(features, ruleIndex))
                conditionalVisitor.stop();
        });
        conditionalVisitor.visit(this.rules.slice().reverse());
    }
    /**
     * Evaluates a RulesVariable instance based on the current request and response.
     * @param variable
     * @returns
     */
    evalVariable(variable) {
        if (variable.request) {
            switch (variable.request) {
                case 'client_ip':
                    return this.request.socket.remoteAddress;
                case 'pop_code':
                    return process.env.POP_CODE;
                case 'method':
                    return this.request.method.toUpperCase();
                case 'origin_path':
                    return this.request.path;
                case 'path':
                    return this.originalPath;
                case 'origin_query_string':
                    return this.request.url.split('?')[1];
                case 'querystring':
                    return this.request.url.split('?')[1];
                case 'query':
                    return this.originalQueryString;
                case 'scheme':
                    return this.request.secure ? 'https' : 'http';
                case 'referring_domain': {
                    const referrer = this.request.getHeader('referrer');
                    if (referrer) {
                        const splitReferrer = referrer.split('/');
                        if (splitReferrer.length > 2) {
                            // we get just the domain, as defined in edge docs
                            // https://docs.edgecast.com/cdn/Content/HRE/M/Referring-Domain-Literal.htm
                            return referrer.split('/')[2];
                        }
                    }
                    return '';
                }
                default: {
                    throw new Error(`Unsupported request property "${variable.request}".`);
                }
            }
        }
        else if (variable['request.header']) {
            const header = variable['request.header'];
            return (0, first_1.default)(this.request.getHeader(header));
        }
        else if (variable['request.cookie']) {
            const cookieName = variable['request.cookie'];
            return this.cookies[cookieName];
        }
        else if (variable['request.origin_query']) {
            const param = variable['request.origin_query'];
            return this.request.query && this.request.query[param];
        }
        else if (variable.variable) {
            return this.variables[variable.variable];
        }
        else if (variable['request.path']) {
            const param = variable['request.path'];
            switch (param) {
                case 'filename':
                    return path_1.default.basename(this.request.path);
                case 'extension':
                    return path_1.default.extname(this.request.path);
                case 'directory':
                    return path_1.default.dirname(this.request.path);
            }
        }
        else if (variable.location) {
            return this.location[variable.location];
        }
        else if (variable.random) {
            return Math.floor(Math.random() * (variable['random'] + 1));
        }
        else if (variable.device) {
            return this.device[variable.device];
        }
        else if (variable.response === 'status_code') {
            return this.originResponseStatus;
        }
        else {
            throw new Error(`Unsupported variable "${Object.keys(variable)[0]}".`);
        }
    }
    getRequest() {
        return this.request;
    }
    getResponse() {
        var _a;
        // If revalidateResponse exists, we're in the process of revalidation.
        return (_a = this.revalidateResponse) !== null && _a !== void 0 ? _a : this.response;
    }
    /**
     * Adds/appends a value to a request header
     * @param feature
     * @param forceAppend
     */
    setRequestHeader(feature, forceAppend) {
        return this.setHeader(this.getRequest(), feature, forceAppend);
    }
    /**
     * Adds/appends a value to a response header
     * @param feature
     * @package forceAppend
     */
    setResponseHeader(feature, forceAppend) {
        return this.setHeader(this.getResponse(), feature, forceAppend);
    }
    setHeader(target, feature, allowMultiple) {
        var _a;
        const targetFeature = (0, interpolate_1.interpolateObject)(feature, this);
        for (let [name, value] of Object.entries(targetFeature)) {
            const evaluatedValue = (_a = this.eval(value)) === null || _a === void 0 ? void 0 : _a.toString();
            if (evaluatedValue) {
                let outputHeader = evaluatedValue;
                if (name.startsWith('+')) {
                    name = name.substring(1);
                    const curVal = target.getHeader(name);
                    // right now we append to all header values - cant verify this is correct against sailfish at the moment
                    if (curVal) {
                        outputHeader = Array.isArray(curVal)
                            ? curVal.map(value => value + ',' + evaluatedValue)
                            : curVal + ',' + evaluatedValue;
                    }
                }
                else {
                    const curVal = target.getHeader(name);
                    // array outputs headers in separate entries having the same key
                    if (curVal && allowMultiple) {
                        outputHeader = Array.isArray(curVal)
                            ? [...curVal, evaluatedValue]
                            : [curVal, evaluatedValue];
                    }
                }
                target.setHeader(name, outputHeader);
            }
            else {
                target.removeHeader(name);
            }
        }
    }
    /**
     * Evaluates an operands, which may be a constant or RulesVariable instance.
     * @param operand
     * @returns
     */
    eval(operand) {
        if (operand == null) {
            return operand;
        }
        else if (typeof operand === 'string') {
            return operand;
        }
        else if (typeof operand === 'boolean') {
            return operand;
        }
        else if (typeof operand === 'number') {
            return operand;
        }
        else {
            return this.evalVariable(operand);
        }
    }
    /**
     * Summarizes the context of received request.
     */
    summarize() {
        return `${this.request.method.toUpperCase()} ${this.originalPath}${this.originalQueryString || ''}`;
    }
}
exports.default = RequestContext;
