"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCacheEnabled = void 0;
const lru_cache_1 = __importDefault(require("lru-cache"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const constants_1 = require("../constants");
/**
 * Must have the EDGIO_LOCAL_CACHE environment variable set.
 */
function isCacheEnabled() {
    return process.env[constants_1.EDGIO_ENV_VARIABLES.cache] === 'true';
}
exports.isCacheEnabled = isCacheEnabled;
/**
 * Local simulation of Edgio's edge cache
 */
class Cache {
    constructor() {
        this.cache = new lru_cache_1.default({
            ttl: 1,
            allowStale: true,
            ttlAutopurge: false,
            max: 100000,
        });
        // additional cache serving as a "auto-unlocking" lock, used in order to avoid making unnecessary revalidation requests
        this.revalidationCache = new lru_cache_1.default({
            // time we consider OK for additional request to be made on timeout
            ttl: 500,
            allowStale: false,
            ttlAutopurge: false,
            max: 10000,
        });
    }
    /**
     * Evicts all entries from the cache
     */
    clear() {
        this.cache.clear();
    }
    /**
     * Returns the cached response for the specified key
     * @param key The cache key
     */
    get(key) {
        const keyValue = key.toString();
        const response = this.cache.get(keyValue, { allowStale: true, noDeleteOnStaleGet: true });
        const remainingTtl = this.cache.getRemainingTTL(keyValue);
        const stale = remainingTtl <= 0;
        if (!response) {
            // no response found in the cache
            return undefined;
        }
        const now = Date.now();
        const { serveStaleUntil } = response;
        if (stale && (serveStaleUntil == null || serveStaleUntil < now)) {
            // response is stale and outside of the stale-while-revalidate period
            return undefined;
        }
        return {
            response: (0, lodash_clonedeep_1.default)(response),
            revalidate: stale,
        };
    }
    /**
     * Stores a response in the cache
     * @param cacheKey
     * @param response
     * @param maxAge
     */
    put(cacheKey, response, { ttl, staleWhileRevalidate }) {
        let serveStaleUntil = undefined;
        if (staleWhileRevalidate) {
            serveStaleUntil = new Date().getTime() + ttl * 1000 + staleWhileRevalidate * 1000;
        }
        const cached = convertToCachedResponse(response, ttl, serveStaleUntil);
        this.cache.set(cacheKey.toString(), cached, {
            ttl: ttl * 1000,
        });
    }
    isRevalidating(cacheKey) {
        return !!this.revalidationCache.get(cacheKey.toString());
    }
    setRevalidating(cacheKey, value) {
        this.revalidationCache.set(cacheKey.toString(), value);
    }
    dump() {
        return this.cache.dump();
    }
}
exports.default = Cache;
/**
 * We have to deep clone parts of the
 * @param response HTTP response that we are caching
 */
function convertToCachedResponse(response, ttl, serveStaleUntil) {
    return {
        cachedAt: Date.now(),
        ttl,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        headers: JSON.parse(JSON.stringify(response.getHeaders())),
        chunks: response.encodedChunks,
        serveStaleUntil,
        // @ts-ignore
        someObject: { key: 'value' },
    };
}
