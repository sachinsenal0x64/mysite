/// <reference types="node" />
/// <reference types="node" />
import { Writable } from 'stream';
import Response, { ResponseHeaders } from './Response';
/**
 * Helper class useful for cases when:
 *    - response is not available in traditional sense (eg. lambda environment, fiddle, tests)
 *    - we need to run code that is dependant on having an editable response (cache revalidation)
 */
export default class LambdaResponse implements Response {
    headers: ResponseHeaders;
    statusCode: number;
    statusMessage?: string;
    body?: Buffer | string;
    chunks: any[];
    encodedChunks: any[];
    private onStream;
    private onEnd;
    private onHeaders;
    private onFlush;
    private downstream;
    private encoder?;
    private decoder?;
    private responseStream?;
    private byteLength;
    private maxByteLength;
    private isDirectStream;
    isHeadersStreamed: boolean;
    isEnded: boolean;
    isDownstreamInit: boolean;
    isStreaming: boolean;
    isStreamableCallback: () => boolean;
    constructor(responseStream?: Writable);
    setHeader(name: string, value: unknown): void;
    removeHeader(name: string): void;
    getHeader(name: string): unknown;
    getHeaders(): ResponseHeaders;
    clear(): void;
    isCachable(): boolean;
    write(chunk: string | Buffer): Promise<void>;
    end(): Promise<void>;
    setEncoder(value: Writable): void;
    setDecoder(value: Writable): void;
    setDirectStream(value: boolean): void;
    stream(): void;
    waitForFlush(): Promise<boolean | void>;
    initDownstream(): void;
    setIsStreamable(callback: (() => boolean) | boolean): (() => boolean) | undefined;
    isStreamable(): boolean;
    setOnStream(callback: () => void): void;
    setOnEnd(callback: () => void): void;
    setOnHeaders(callback: () => void): void;
    getData(): {
        body: string | Buffer | undefined;
        statusCode: number;
        statusMessage: string | undefined;
        headers: ResponseHeaders;
    };
}
