"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractValuesFromObject = exports.extractInterpolationValues = exports.interpolateObject = void 0;
const constants_1 = require("../constants");
const decodeUnreservedURIChars_1 = __importDefault(require("../utils/decodeUnreservedURIChars"));
const path_1 = __importDefault(require("path"));
const qs_1 = __importDefault(require("qs"));
const EvaluatorGroup_1 = require("./evaluators/EvaluatorGroup");
const evaluators_1 = require("./evaluators");
/**
 * Replaces variables in the provided value with attributes of the request.
 *
 * For example, %{scheme}://www.example.com/products/%{arg_id} would become
 * https://www.example.com/products/1 for a request to https://www.example.com/products?id=1
 *
 * For more, see https://gitlab.com/limelight-networks/edgecast/mirrors/sailfish/-/blob/master/ecdoc/core-httpvars.rst
 *
 * @param value The value to interpolate
 * @param context The requestContext whose attributes should be used
 * @param values The object with extracted values
 * @returns
 */
const interpolate = (value, context, values = (0, exports.extractInterpolationValues)(context)) => {
    const expressionEvaluator = new EvaluatorGroup_1.EvaluatorGroup([
        evaluators_1.assignOnNullEvaluator,
        evaluators_1.assignOnNotNullEvaluator,
        evaluators_1.removeLeadingEvaluator,
        evaluators_1.removeTrailingEvaluator,
        evaluators_1.substringEvaluator,
        evaluators_1.findReplaceEvaluator,
        evaluators_1.toLowercaseEvaluator,
        evaluators_1.toUppercaseEvaluator,
        evaluators_1.simpleEvaluator,
    ]);
    const matches = value.matchAll(/%{(.*?)}/g);
    for (const match of matches) {
        const [expressionFull, expression] = match;
        const result = expressionEvaluator.execute(expression, values);
        if (typeof result !== 'string')
            continue;
        value = value.replace(expressionFull, result);
    }
    return value;
};
exports.default = interpolate;
/**
 * Replaces all values for all keys in an object with interpolated value
 *
 * @param target Object whos keys will be itterated and values changed with interpolate function call
 * @param context
 */
const interpolateObject = (target, context) => {
    // We want to preserve assigned variables inside the object scope
    const values = (0, exports.extractInterpolationValues)(context);
    const newObject = {};
    Object.entries(target).forEach(p => {
        const [key, value] = p;
        newObject[key] = value !== undefined ? interpolate(value, context, values) : value;
    });
    return newObject;
};
exports.interpolateObject = interpolateObject;
const defaultInterpolationValues = {
    is_origin_shield: 'N/A',
    is_subrequest: 'N/A',
    physical_path: 'N/A',
    physical_rel_path: 'N/A',
    physical_doc_root: 'N/A',
    referring_domain: 'N/A',
    virt_dst_country: 'N/A',
    virt_dst_continent: 'N/A',
    virt_dst_asnum: 'N/A',
    virt_dst_port: 'N/A',
    geo_country: 'N/A',
    geo_city: 'N/A',
    geo_latitude: 'N/A',
    geo_longitude: 'N/A',
    geo_postal_code: 'N/A',
    virt_ssl_protocol: 'N/A',
    virt_ssl_cipher: 'N/A',
    virt_ssl_client_ciphers: 'N/A',
    virt_ssl_client_cipher_codes: 'N/A',
    virt_ssl_client_tlsext_ids: 'N/A',
    virt_http_version: 'N/A',
    wurfl_vcap_is_smartphone: 'N/A',
    wurfl_cap_is_tablet: 'N/A',
    wurfl_vcap_is_full_desktop: 'N/A',
    wurfl_vcap_is_ios: 'N/A',
    wurfl_vcap_is_android: 'N/A',
    wurfl_vcap_is_robot: 'N/A',
    wurfl_cap_mobile_browser: 'N/A',
};
const extractInterpolationValues = (context) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    // Please check this page to see how mappings to Sailfish is resolved
    // see https://gitlab.com/limelight-networks/edgecast/mirrors/sailfish/-/blob/master/ecdoc/core-httpvars.rst
    const { cookies, interpolationValues } = context;
    const request = context.getRequest();
    const response = context.getResponse();
    const host = (_a = request.getHeader('host')) !== null && _a !== void 0 ? _a : '';
    const fullUrl = new URL(`${request.protocol}://${host}${request.url}`);
    const values = {
        ...defaultInterpolationValues,
        ...interpolationValues,
    };
    values.host = host;
    values.is_args = fullUrl.search !== '' ? '?' : '';
    values.is_amp = fullUrl.search !== '' ? '&' : '';
    values.query_string = fullUrl.search.substring(1);
    values.request_protocol = `HTTP/${request.httpVersion}`;
    values.request_method = request.method.toUpperCase();
    values.request_uri = request.url;
    values.request_header = (_c = (_b = request.rawHeaders) === null || _b === void 0 ? void 0 : _b.join(', ')) !== null && _c !== void 0 ? _c : ''; // What separator to use?
    values.request = `${values['request_method']} ${values['request_uri']} ${values['request_protocol']}`;
    values.path = request.path;
    values.normalized_path = (0, decodeUnreservedURIChars_1.default)(path_1.default.normalize(values['path']));
    values.normalized_query = fullUrl.searchParams.toString();
    values.normalized_uri = `${values.normalized_path}?${values.normalized_query}`;
    values.scheme = request.secure ? 'https' : 'http';
    values.server_name = host;
    values.server_port = request.port;
    values.server_socket_port = request.port; // not sure about this one
    values.status = (_e = (_d = response.statusCode) === null || _d === void 0 ? void 0 : _d.toString()) !== null && _e !== void 0 ? _e : ''; // is this right, can we have empty status code
    values.http_status = values.status;
    values.cache_status = (_f = response.getHeader(constants_1.HTTP_HEADERS.xEdgeCachingStatus)) !== null && _f !== void 0 ? _f : ''; // should we translate this to something
    values.virt_dst_addr = ((_g = (request.getHeader('x-forwarded-for') || request.socket.remoteAddress)) !== null && _g !== void 0 ? _g : '');
    // We need to parse query params from the URL without the decoder to
    // obtain raw not decoded version of them
    const undecodedQuery = qs_1.default.parse(fullUrl.search, {
        ignoreQueryPrefix: true,
        // We need to convert all arg names to lowercase to ensure
        // that all duplicates will be as one array in final object
        decoder: (value, defaultEncoder, charset, type) => type === 'key' ? value.toLowerCase() : value,
    });
    // Extract all values from provided objects with provided prefix
    (0, exports.extractValuesFromObject)('http_', (_h = request.getHeaders()) !== null && _h !== void 0 ? _h : {}, values);
    (0, exports.extractValuesFromObject)('resp_', (_j = response.getHeaders()) !== null && _j !== void 0 ? _j : {}, values);
    (0, exports.extractValuesFromObject)('arg_', undecodedQuery !== null && undecodedQuery !== void 0 ? undecodedQuery : {}, values);
    (0, exports.extractValuesFromObject)('cookie_', cookies !== null && cookies !== void 0 ? cookies : {}, values);
    return values;
};
exports.extractInterpolationValues = extractInterpolationValues;
/**
 * Extracts values from source object to destination object with provided key prefix.
 * This function ensures correct appending of existing
 * and new values which can either be string or string[].
 * It also ensures that all keys are converted to lower case.
 *
 * @param prefix prefix to be added in front of all dest keys
 * @param srcObj source object
 * @param destObj destination object
 * @example usage: extractValuesFromObject('http_', request.getHeaders(), values)
 */
const extractValuesFromObject = (prefix, srcObj, destObj) => {
    Object.keys(srcObj).forEach(srcKey => {
        // Convert all keys to lower case to ensure consistency
        // while merging values from multiple objects with same keys
        const destKey = `${prefix}${srcKey}`.toLowerCase();
        // Normalize type to array when values are string or array of strings.
        // This happens when we have multiple headers or query params with same name.
        const srcValues = !Array.isArray(srcObj[srcKey])
            ? [srcObj[srcKey]]
            : srcObj[srcKey];
        const destValues = destObj[destKey] ? [[destObj[destKey]]] : [];
        // Join existing and new values with comma and space
        destObj[destKey] = [...destValues, ...srcValues].join(', ');
    });
};
exports.extractValuesFromObject = extractValuesFromObject;
