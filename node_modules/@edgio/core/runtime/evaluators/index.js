"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleEvaluator = exports.toUppercaseEvaluator = exports.toLowercaseEvaluator = exports.findReplaceEvaluator = exports.substringEvaluator = exports.removeTrailingEvaluator = exports.removeLeadingEvaluator = exports.assignOnNotNullEvaluator = exports.assignOnNullEvaluator = exports.normalizeKey = void 0;
const Evaluator_1 = require("./Evaluator");
const toEdgeRegex_1 = require("../../utils/toEdgeRegex");
const regexUtils_1 = require("../../utils/regexUtils");
/**
 * Normalizes key to ensure consistency with Sailfish interpolation.
 * @param key
 * @example usage: normalizeKey('http_x-ForWarded-for') => 'http_x_forwarded_for'
 */
const normalizeKey = (key) => {
    // Convert all keys to lower case to ensure consistency.
    // This is needed because Sailfish interpolation is case-insensitive.
    key = key.toLowerCase();
    // Replace all dashes in header keys with underscores.
    // This is needed because Sailfish headers interpolation works with both dashes and underscores (even mixed)
    // but this is not the case with query params or cookies.
    // @example "${http_x-forwarded-for}" => "1.1.1.1"
    // @example "${http_x_forwarded_for}" => "1.1.1.1"
    // @example "${http_x-forwarded_for}" => "1.1.1.1"
    if (key.startsWith('http_') || key.startsWith('resp_')) {
        return key.replace(/-/g, '_');
    }
    return key;
};
exports.normalizeKey = normalizeKey;
/**
 * If the value of varname is unset or empty string,
 * string is assigned to varname. The value of varname is then substituted.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:=stringToAssign} OR %{varname=stringToAssign}
 * Example:
 * Values: { emptyVarname: "" }
 * Expression: "%{varname:=newValue}" => "newValue"
 * Expression: "%{emptyVarname:=newValue}" => "newValue"
 * Expression: "%{varname=newValue}" => "newValue"
 * Expression: "%{emptyVarname=newValue}" => ""
 */
exports.assignOnNullEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, colon, newValue] = params.matched;
    // test for unset varname and non-empty string when format with colon is used
    if (normalizedKey in params.values && (!colon || params.values[normalizedKey].length > 0))
        return params.values[normalizedKey];
    params.values[normalizedKey] = newValue;
    return newValue;
}, /^([A-Za-z0-9_-]+)(:?)=(.*)$/, exports.normalizeKey);
/**
 * If the value of varname is unset or empty string, nothing is substituted,
 * otherwise string is assigned to varname.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:+stringToAssign} OR %{varname+stringToAssign}
 * Example:
 * Values: { varname: "something", emptyVarname: "" }
 * Expression: "%{varname:+newValue}" => "newValue"
 * Expression: "%{emptyVarname:+newValue}" => ""
 * Expression: "%{varname+newValue}" => "newValue"
 * Expression: "%{emptyVarname+newValue}" => "newValue"
 */
exports.assignOnNotNullEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, colon, newValue] = params.matched;
    // test for not unset varname or empty string when format with colon is used
    if (!(normalizedKey in params.values) || (colon && params.values[normalizedKey].length === 0))
        return '';
    params.values[normalizedKey] = newValue;
    return newValue;
}, /^([A-Za-z0-9_-]+)(:?)\+(.*)$/, exports.normalizeKey);
/**
 * If the pattern matches the beginning of the value of varname, then
 * the result is the value of varname with the matching pattern deleted.
 *
 * Format: %{varname#pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname#thing}" => "some"
 */
exports.removeLeadingEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, pattern] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    return params.values[normalizedKey].replace(new RegExp(`^${pattern}`), '');
}, /^([A-Za-z0-9_-]+)#(.+)$/, exports.normalizeKey);
/**
 * If the pattern matches a trailing portion of the value of varname, then
 * the result is the the value of varname with the matching pattern deleted.
 *
 * Format: %{varname%pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname%some}" => "thing"
 */
exports.removeTrailingEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, pattern] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    return params.values[normalizedKey].replace(new RegExp(`${pattern}$`), '');
}, /^([A-Za-z0-9_-]+)%(.+)$/, exports.normalizeKey);
/**
 * Expands to up to length characters of varname starting at the character
 * specified by offset. If length is omitted, expands to the substring of varname
 * starting at the character specified by offset. length and offset are numberic constants.
 *
 * If offset is a number less than zero, the value is used as an offset from
 * the end of the value of varname. If length evaluates to a number less than zero,
 * it is interpreted as an offset from the end of the value of varname rather than a
 * number of characters, and the expansion is the characters between the two offsets.
 *
 * Format: %{varname:offset:length}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname:1:4}" => "omet"
 */
exports.substringEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, offsetString, lengthString] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    const valueLength = params.values[normalizedKey].length;
    const offset = parseInt(offsetString);
    // Use length of the value if length param is not specified
    const length = !lengthString ? valueLength : parseInt(lengthString);
    // When offset is negative number but length positive, transform offset to positive index from the end of string
    const startIndex = offset < 0 && length >= 0 ? valueLength + offset : offset;
    // When startIndex is negative, assume that the provided length is index
    const endIndex = (startIndex < 0 ? 0 : startIndex) + length;
    return params.values[normalizedKey].slice(startIndex, endIndex);
}, /^([A-Za-z0-9_-]+):(-?[0-9]+):(-?[0-9]*)$/, exports.normalizeKey);
/**
 * Find and replace values using regular expressions. The match of pattern against its value is replaced with string.
 * If pattern begins with '/', all matches of pattern are replaced with string otherwise only the first match is replaced.
 * If pattern begins with '/=', only replaceString is returned with substituted matched values.
 * Doesn't support L and U flags ($U1, $L1) in regex substitution.
 *
 * Format: %{varname/searchPattern/replaceString} OR %{varname//searchPattern/replaceString} OR %{varname/=searchPattern/replaceString}
 * Example:
 * Values: { varname: "something something" }
 * Expression: "%{varname/meth/NEW}" => "soNEWing something"
 * Expression: "%{varname//meth/NEW}" => "soNEWing soNEWing"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$2 $1}" => "thing some"
 *
 * TODO: Add support for L and U flags in regex substitution â†“
 * Expression: "%{varname/^(.+)$/$U1}" => "SOMETHING SOMETHING"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$U2 $L1}" => "THING some"
 */
exports.findReplaceEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, delimiter, searchAndReplaceValue] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    // We must find first unescaped character.
    // We can't use lookbehind in regex itself, as its not supported in safari / non-v8 browsers.
    const splitIndex = [...searchAndReplaceValue].findIndex((val, index) => val === '/' && (searchAndReplaceValue === null || searchAndReplaceValue === void 0 ? void 0 : searchAndReplaceValue[index - 1]) !== '\\');
    const searchValue = searchAndReplaceValue.substring(0, splitIndex);
    const replaceValue = searchAndReplaceValue.substring(splitIndex + 1); // we skip around the slash
    // construct regex from edge regex to preserve /i flag
    const patternRegex = (0, toEdgeRegex_1.fromEdgeRegex)(searchValue);
    // performs only substitution without replacement in source string
    if (delimiter === '/=')
        return (0, regexUtils_1.substituteParams)(patternRegex, params.values[normalizedKey], replaceValue);
    return params.values[normalizedKey].replace(new RegExp(patternRegex.source, 
    // add global flag based on used format
    `${patternRegex.flags}${delimiter === '//' ? 'g' : ''}`), replaceValue);
}, /^([A-Za-z0-9_-]+)(\/\/?=?)(.+)$/, exports.normalizeKey);
/**
 * Converts matching group of variable's value to lowercase.
 * If ',' format is used, only the first match is converted.
 * All matches are converted when ',,' format is used.
 * If no pattern is provided the whole string is converted to lowercase.
 *
 * Format: %{varname,pattern} OR %{varname,,pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname,}" => "this is a mix of lower-upper case."
 * Expression: "%{varname,is}" => "This Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname,,is}" => "This is A mIx Of LoWer-Upper cAse."
 */
exports.toLowercaseEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, delimiter, pattern] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    const patternRegex = new RegExp(`(${!pattern ? '(.*)' : pattern})`, `i${delimiter === ',,' ? 'g' : ''}`);
    return params.values[normalizedKey].replace(patternRegex, match => match.toLowerCase());
}, /^([A-Za-z0-9_-]+)(,,?)(.*)$/, exports.normalizeKey);
/**
 * Converts matching group of variable's value to uppercase.
 * If '^' format is used, only the first match is converted.
 * All matches are converted when '^^' format is used.
 * If no pattern is provided the whole string is converted to uppercase.
 *
 * Format: %{varname^pattern} OR %{varname^^pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname^}" => "THIS IS A MIX OF LOWER-UPPER CASE."
 * Expression: "%{varname^is}" => "ThIS Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname^^is}" => "ThIS IS A mIx Of LoWer-Upper cAse."
 */
exports.toUppercaseEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey, delimiter, pattern] = params.matched;
    if (!(normalizedKey in params.values))
        return undefined;
    const patternRegex = new RegExp(`(${!pattern ? '(.*)' : pattern})`, `i${delimiter === '^^' ? 'g' : ''}`);
    return params.values[normalizedKey].replace(patternRegex, match => match.toUpperCase());
}, /^([A-Za-z0-9_-]+)(\^\^?)(.*)$/, exports.normalizeKey);
/**
 * Performs simple interpolation when variables are replaced by values.
 * This Evaluator should be placed to the end of EvaluatorGroup
 * because it returns empty string when certain variables starting with http|resp|arg|cookie don't exist.
 *
 * Format: %{varname}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname}" => "something"
 * Expression: "%{arg_undefined_varname}" => ""
 * Expression: "%{undefined_varname}" => undefined => "%{undefined_varname}"
 */
exports.simpleEvaluator = new Evaluator_1.Evaluator(params => {
    const [normalizedKey] = params.matched;
    if (normalizedKey in params.values)
        return params.values[normalizedKey];
    return /(http|resp|arg|cookie)_[A-Za-z0-9_-]+/g.test(normalizedKey) ? '' : undefined;
}, /(.+)/, exports.normalizeKey);
