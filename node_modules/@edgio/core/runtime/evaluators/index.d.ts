import { Evaluator } from './Evaluator';
/**
 * Normalizes key to ensure consistency with Sailfish interpolation.
 * @param key
 * @example usage: normalizeKey('http_x-ForWarded-for') => 'http_x_forwarded_for'
 */
export declare const normalizeKey: (key: string) => string;
/**
 * If the value of varname is unset or empty string,
 * string is assigned to varname. The value of varname is then substituted.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:=stringToAssign} OR %{varname=stringToAssign}
 * Example:
 * Values: { emptyVarname: "" }
 * Expression: "%{varname:=newValue}" => "newValue"
 * Expression: "%{emptyVarname:=newValue}" => "newValue"
 * Expression: "%{varname=newValue}" => "newValue"
 * Expression: "%{emptyVarname=newValue}" => ""
 */
export declare const assignOnNullEvaluator: Evaluator;
/**
 * If the value of varname is unset or empty string, nothing is substituted,
 * otherwise string is assigned to varname.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:+stringToAssign} OR %{varname+stringToAssign}
 * Example:
 * Values: { varname: "something", emptyVarname: "" }
 * Expression: "%{varname:+newValue}" => "newValue"
 * Expression: "%{emptyVarname:+newValue}" => ""
 * Expression: "%{varname+newValue}" => "newValue"
 * Expression: "%{emptyVarname+newValue}" => "newValue"
 */
export declare const assignOnNotNullEvaluator: Evaluator;
/**
 * If the pattern matches the beginning of the value of varname, then
 * the result is the value of varname with the matching pattern deleted.
 *
 * Format: %{varname#pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname#thing}" => "some"
 */
export declare const removeLeadingEvaluator: Evaluator;
/**
 * If the pattern matches a trailing portion of the value of varname, then
 * the result is the the value of varname with the matching pattern deleted.
 *
 * Format: %{varname%pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname%some}" => "thing"
 */
export declare const removeTrailingEvaluator: Evaluator;
/**
 * Expands to up to length characters of varname starting at the character
 * specified by offset. If length is omitted, expands to the substring of varname
 * starting at the character specified by offset. length and offset are numberic constants.
 *
 * If offset is a number less than zero, the value is used as an offset from
 * the end of the value of varname. If length evaluates to a number less than zero,
 * it is interpreted as an offset from the end of the value of varname rather than a
 * number of characters, and the expansion is the characters between the two offsets.
 *
 * Format: %{varname:offset:length}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname:1:4}" => "omet"
 */
export declare const substringEvaluator: Evaluator;
/**
 * Find and replace values using regular expressions. The match of pattern against its value is replaced with string.
 * If pattern begins with '/', all matches of pattern are replaced with string otherwise only the first match is replaced.
 * If pattern begins with '/=', only replaceString is returned with substituted matched values.
 * Doesn't support L and U flags ($U1, $L1) in regex substitution.
 *
 * Format: %{varname/searchPattern/replaceString} OR %{varname//searchPattern/replaceString} OR %{varname/=searchPattern/replaceString}
 * Example:
 * Values: { varname: "something something" }
 * Expression: "%{varname/meth/NEW}" => "soNEWing something"
 * Expression: "%{varname//meth/NEW}" => "soNEWing soNEWing"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$2 $1}" => "thing some"
 *
 * TODO: Add support for L and U flags in regex substitution â†“
 * Expression: "%{varname/^(.+)$/$U1}" => "SOMETHING SOMETHING"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$U2 $L1}" => "THING some"
 */
export declare const findReplaceEvaluator: Evaluator;
/**
 * Converts matching group of variable's value to lowercase.
 * If ',' format is used, only the first match is converted.
 * All matches are converted when ',,' format is used.
 * If no pattern is provided the whole string is converted to lowercase.
 *
 * Format: %{varname,pattern} OR %{varname,,pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname,}" => "this is a mix of lower-upper case."
 * Expression: "%{varname,is}" => "This Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname,,is}" => "This is A mIx Of LoWer-Upper cAse."
 */
export declare const toLowercaseEvaluator: Evaluator;
/**
 * Converts matching group of variable's value to uppercase.
 * If '^' format is used, only the first match is converted.
 * All matches are converted when '^^' format is used.
 * If no pattern is provided the whole string is converted to uppercase.
 *
 * Format: %{varname^pattern} OR %{varname^^pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname^}" => "THIS IS A MIX OF LOWER-UPPER CASE."
 * Expression: "%{varname^is}" => "ThIS Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname^^is}" => "ThIS IS A mIx Of LoWer-Upper cAse."
 */
export declare const toUppercaseEvaluator: Evaluator;
/**
 * Performs simple interpolation when variables are replaced by values.
 * This Evaluator should be placed to the end of EvaluatorGroup
 * because it returns empty string when certain variables starting with http|resp|arg|cookie don't exist.
 *
 * Format: %{varname}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname}" => "something"
 * Expression: "%{arg_undefined_varname}" => ""
 * Expression: "%{undefined_varname}" => undefined => "%{undefined_varname}"
 */
export declare const simpleEvaluator: Evaluator;
