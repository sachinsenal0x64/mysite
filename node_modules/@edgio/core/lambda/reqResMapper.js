"use strict";
/**
 * This file is modified version of: https://github.com/danielcondemarin/serverless-next.js/blob/master/packages/next-aws-lambda/lib/compatLayer.js
 *
 * Mods:
 * - getHeader were only able to read lower case headers, but it was able to set upper case headers as well with writeHead,
 *   so all headers are converted to lowercase now.
 *
 * - Gzippes the response on response end if matches the content-type
 *
 * - Removed variable for base64 support since we always return base64 from the lambdas.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const qs_1 = require("qs");
const uuid_1 = require("uuid");
const LambdaResponse_1 = __importDefault(require("../runtime/LambdaResponse"));
const LambdaRequest_1 = __importDefault(require("../runtime/LambdaRequest"));
/**
 * Gets the version of @edgio/core.  For this to work in testing an entry needed
 * to be added to moduleNameMapper in the jest config specifically for package.json
 *
 * Notes:
 * - In this module there are multiple places that need to read Edgio version.
 * But elegantly and correctly offering a single function to read Edgio version is hard
 * because these different places are transpiled, bundled and invoked in different
 * contexts. For example, if we try to replace this with reading version from
 * DeploymentBuilder then bundling fails.
 *
 * @return {String}
 */
function getEdgioVersion() {
    return process.env[constants_1.EDGIO_ENV_VARIABLES.versionOverride] || require('../../package.json').version;
}
exports.default = (event, invocation) => {
    var _a;
    let responsePromise;
    const req = new LambdaRequest_1.default({
        url: {
            pathname: event.path,
            search: normalizeLambdaQuery(event),
        },
        method: event.httpMethod,
        headers: event.multiValueHeaders,
        body: Buffer.from((_a = event.body) !== null && _a !== void 0 ? _a : '', event.isBase64Encoded ? 'base64' : undefined),
    });
    const res = new LambdaResponse_1.default();
    // If the downstream has sent us request ID we use it, otherwise we generate a new one.
    // We have to repeat this code here *and* in Router *and* in XBP *and* in edge because
    // each one of these components may be the first to receive the request:
    // - Router when using `edgio run`
    // - Handler when using `edgio run --production`
    // - XBP when making request to cloud
    // - Edge when making request to edge
    let newRequestId;
    if (!req.headers[constants_1.HTTP_HEADERS.xRequestId]) {
        newRequestId = (0, uuid_1.v4)();
        req.headers[constants_1.HTTP_HEADERS.xRequestId] = newRequestId;
    }
    const onResEnd = (resolve) => {
        var _a, _b;
        // If this component has generated the new request ID then it is also responsible for sending it downstream.
        newRequestId && res.setHeader(constants_1.HTTP_HEADERS.xRequestId, newRequestId);
        // this also avoids updating/encoding the original's body
        const responseData = res.getData();
        // We always respond with base64 so that we can serve non-text assets like images.
        responseData.body = (_b = (_a = responseData.body) === null || _a === void 0 ? void 0 : _a.toString('base64')) !== null && _b !== void 0 ? _b : '';
        responseData.isBase64Encoded = true;
        responseData.multiValueHeaders = res.headers;
        invocation.stop();
        logStatusCode(responseData);
        logExecutionTime(responseData, invocation);
        logComponentVersion(responseData, getEdgioVersion(), invocation.lambda.id);
        fixApiGatewayMultipleHeaders(responseData);
        resolve(responseData);
    };
    responsePromise = new Promise(resolve => res.setOnEnd(() => onResEnd(resolve)));
    function fixApiGatewayMultipleHeaders(responseData) {
        for (const key of Object.keys(responseData.multiValueHeaders)) {
            if (!Array.isArray(responseData.multiValueHeaders[key])) {
                responseData.multiValueHeaders[key] = [responseData.multiValueHeaders[key]];
            }
        }
    }
    return { req, res, responsePromise };
};
/**
 * Adds an `x-edg-status` header to the response based on the status code.
 *
 * Notes:
 * - If the `x-edg-status` already exists then the status is prefixed to upstream value.
 *
 * @param response The response event
 * @private
 */
function logStatusCode(response) {
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.xEdgeStatus, `w=${response.statusCode}`);
}
/**
 * Adds an `x-edg-t` header to the response based on the current time.
 *
 * Notes:
 * - If the `x-edg-t` already exists then the execution time is prefixed to upstream value.
 * - `wt` stands for "worker time", the duration of the current execution
 * - `wc` stands for "worker count", the number of times the lambda has been invoked,
 *   with the first invocation having the count of *1* (same as `pc` counter in XBP)
 * - `wg` stands for "worker age", the number of milliseconds since the lambda instances was spawned
 *   (`wa` already stands for request transformation time)
 * - `wl` stands for "worker lifetime", the total lifetime duration
 *
 * @param response The response event
 * @param startTime The start time of the request
 * @private
 */
function logExecutionTime(response, invocation) {
    const lambda = invocation.lambda;
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.xEdgeT, `wt=${invocation.duration},wc=${lambda.invocationCounter},wg=${lambda.age},wl=${lambda.lifetimeDuration}`);
}
/**
 * Adds an `x-edg-components` header to the response based on the current time.
 *
 * Notes:
 * - If the `x-edg-components` already exists then the version is prefixed to upstream value.
 * - `w` stands for "worker" and has the Edgio version of the worker
 * - `wi` stands for "worker id"
 *
 * @param response The response event
 * @param version The Edgio version of the package
 * @private
 */
function logComponentVersion(response, version, lambdaId) {
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.xEdgeComponents, `w=${version},wi=${lambdaId}`);
}
/**
 * Sets the response header to a new value by prefixing it with the given value or,
 * if it doesn't exist, by setting it to the given value,
 *
 * @param response The response event
 * @param headerName The name of the header to prefix or set
 * @param prefixValue The value of the prefix without trailing comma
 * @private
 */
function prefixResponseHeader(response, headerName, prefixValue) {
    const headerValue = response.multiValueHeaders[headerName];
    if (headerValue) {
        if (Array.isArray(headerValue)) {
            headerValue[0] = `${prefixValue},${headerValue[0]}`;
        }
        else {
            response.multiValueHeaders[headerName] = `${prefixValue},${headerValue}`;
        }
    }
    else {
        response.multiValueHeaders[headerName] = `${prefixValue}`;
    }
}
/**
 * Normalizes query to not have arrays if only one value of certain key exists
 */
function normalizeLambdaQuery(event) {
    let query;
    if (event.multiValueQueryStringParameters &&
        Object.keys(event.multiValueQueryStringParameters).length) {
        Object.keys(event.multiValueQueryStringParameters).forEach(key => {
            // keep backwards compatibility so that arrays with a single value are
            // converted to just be that value:
            const curVal = event.multiValueQueryStringParameters[key];
            if (Array.isArray(curVal) && curVal.length === 1) {
                event.multiValueQueryStringParameters[key] = curVal[0];
            }
        });
        // We disable the indices here, otherwise we would return 'a[0]=b&a[1]=c&a[2]=d' instead of correct 'a=b&a=c&a=d'
        query = (0, qs_1.stringify)(event.multiValueQueryStringParameters, {
            indices: false,
        });
    }
    return query ? '?' + query : '';
}
