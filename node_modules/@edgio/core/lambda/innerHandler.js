"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore file */
const constants_1 = require("../constants");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const paths_1 = require("../deploy/paths");
const timing_1 = require("../timing");
const reqResMapper_1 = __importDefault(require("./reqResMapper"));
const stdStreamsWrapper_1 = __importStar(require("./stdStreamsWrapper"));
const getBodyLoggingData_1 = __importDefault(require("./getBodyLoggingData"));
const lambdaInstance_1 = require("./lambdaInstance");
const RequestHandler_1 = __importDefault(require("../runtime/RequestHandler"));
const origins_1 = require("../origins");
// We're running in .edgio/lambda/app directory by default in production mode.
// This is the directory where all user's JS code is located.
process.chdir(paths_1.JS_APP_DIR_NAME);
// We set the NODE_PATH to the current working directory by default,
// so that imported node_modules from the user's code are resolved from the current working directory
// and not from the location of prod.js file.
process.env.NODE_PATH = ((_a = process.env) === null || _a === void 0 ? void 0 : _a.NODE_PATH) || process.cwd();
const requestHandler = new RequestHandler_1.default((0, paths_1.getJsInternalPath)(), (0, origins_1.getEdgioOrigins)());
/**
 * This is the user lambda entry point
 * @param event A lambda event
 * @param instance The lambda instance
 */
async function innerHandler(event, instance) {
    // We always create a new lambda invocations, for all jobs so that we can accurately
    // identify cold starts.
    const invocation = new lambdaInstance_1.LambdaInvocation(instance);
    invocation.start();
    const driLogger = (0, stdStreamsWrapper_1.deepRequestInspectionLogger)(instance);
    await ensureAppStarted(3001);
    // Deployment actions: only for internal usage and is not exposed
    switch (event.action) {
        case 'getEdgeConfig':
            return new RequestHandler_1.default((0, paths_1.getJsInternalPath)(), (0, origins_1.getEdgioOrigins)(true)).createEdgeConfig();
        case 'getPreloadConfig':
            return withLogging(() => requestHandler.createPreloadConfig());
    }
    let req, res, responsePromise;
    try {
        const reqResResult = (0, reqResMapper_1.default)(event, invocation);
        req = reqResResult.req;
        res = reqResResult.res;
        responsePromise = reqResResult.responsePromise;
    }
    catch (e) {
        return withLogging(() => {
            console.log('Failed to parse the event to get request and response data:', e.message, e.stack);
            return {
                body: (Buffer.from('{"error":"Failed to parse the event to get request and response data"}')),
                isBase64Encoded: true,
                statusCode: 530,
                statusMessage: 'Internal Edgio Error',
                multiValueHeaders: {},
            };
        });
    }
    // Handle web requests.
    return await withLogging(async () => {
        const headers = req.headers || {};
        driLogger.logDownstreamRequestInfo({
            method: req.method,
            path: req.url,
            host: headers['host'],
            headers: headers,
            // We keep the protocol format same as the internal Node format on protocol fields.
            protocol: `${headers[constants_1.HTTP_HEADERS.xEdgeProtocol] || headers[constants_1.HTTP_HEADERS.x0Protocol] || 'https'}:`,
            ...(0, getBodyLoggingData_1.default)(req.rawBody, req.headers),
        });
        try {
            await ensureAppStarted(3001);
        }
        catch (error) {
            console.error(error);
            throw error;
        }
        (0, timing_1.withTimings)(() => {
            return requestHandler.handle(req, res);
        })();
        return responsePromise.then((result) => {
            const headers = res.headers || {};
            driLogger.logDownstreamResponseInfo({
                statusCode: res.statusCode,
                statusMessage: res.statusMessage,
                headers,
                ...(0, getBodyLoggingData_1.default)(result.body, res.headers),
            });
            return result;
        });
    }, req, instance);
}
exports.default = innerHandler;
async function startApp(port) {
    var _a;
    var _b;
    const modulePath = (0, path_1.join)((0, paths_1.getJsInternalPath)(), (0, paths_1.pathForBackend)(constants_1.BACKENDS.js));
    if ((0, fs_extra_1.existsSync)(modulePath)) {
        // We need to use import() with file:// protocol because,
        // the stdlib path functions on Windows systems are returning paths with the disk drive letter (C:\)
        // which is not supported by the Node.js import() function and throws an ERR_UNSUPPORTED_ESM_URL_SCHEME error.
        let prod = await (_a = `file://${modulePath}`, Promise.resolve().then(() => __importStar(require(_a))));
        // find the default export
        prod = ((_b = prod === null || prod === void 0 ? void 0 : prod.default) === null || _b === void 0 ? void 0 : _b.default) || (prod === null || prod === void 0 ? void 0 : prod.default) || prod;
        // backup original working directory
        const originalWorkingDir = process.cwd();
        // load the prod entry point from the framework integration package
        await prod(port);
        // set back original working directory as customers can change working path in their custom prod.js file
        process.chdir(originalWorkingDir);
    }
}
/**
 * Starts the user's SSR app if it hasn't already been started
 */
let appStartedPromise;
async function ensureAppStarted(port) {
    if (!appStartedPromise) {
        appStartedPromise = startApp(port);
    }
    return appStartedPromise;
}
// TODO: We need to implement a way to clearly split logs between:
//       1) user code logs that needs to be JSON, flagged with { awsTag: 'userLogs' }
//         and sent to STDOUT to be picked up by Cloudwatch and our Log Streamer
//       2) our internal wrapper exception logs that needs to be forwarded and handled
//         by XBP
//
//  1) is correctly implemented by stdStreamsWrapper, *but* we need to make sure that user code errors
//     cannot be logged to stdoud past `stdStreamsWrapper.disable()` otherwise they would not appear in Log Streamer
//
//  2) https://moovweb.atlassian.net/browse/PC-1766, exception logging and shipping in XBP needs
//     to be reviewed:
//       - some exceptions are escaping (some unhandled promise rejection for example)
//       - XBP is logging all access logs, but should only log exception traces (which should trigger alert)
/**
 * Starts collecting stdout
 * @param req The web request, if we're serving one
 */
function startLogging(req, lambdaInstance) {
    if (process.env.EDGIO_LOCAL !== 'true' || process.env.EDGIO_LOCAL_CONSOLE_WRAP === 'true') {
        // don't enable logging when running in local production mode because it makes debug output harder to read
        stdStreamsWrapper_1.default.enable({
            // for legacy reasons, we also support x-0-client-ip
            clientIp: req && (req.headers[constants_1.HTTP_HEADERS.xEdgeClientIp] || req.headers[constants_1.HTTP_HEADERS.x0ClientIp]),
            requestId: req && req.headers[constants_1.HTTP_HEADERS.xRequestId],
            wi: lambdaInstance === null || lambdaInstance === void 0 ? void 0 : lambdaInstance.id,
        });
    }
}
/**
 * Stops collecting stdout
 */
function stopLogging() {
    stdStreamsWrapper_1.default.disable();
}
// this allows to call deploy action with streaming enabled. This is meant for internal functions such as getPreloadConfig
// that is called after a deployment being successful. We don't need to wrap the edgeConfig call since it will never be available for the user
// since it runs before the deployment has finished and user has no way to access those logs.
async function withLogging(action, req, lambdaInstance) {
    try {
        startLogging(req, lambdaInstance);
        return await action();
    }
    finally {
        stopLogging();
    }
}
