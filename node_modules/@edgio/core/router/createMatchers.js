"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMatchers = void 0;
const RouteCriteria_1 = require("./RouteCriteria");
const toCondition_1 = require("./converters/toCondition");
/**
 * Creates the matching conditions for EdgeControl's `if` property.
 * @param criteria
 * @returns
 */
function createMatchers(criteria) {
    var _a;
    const ecCriteria = criteria;
    if (ecCriteria.edgeControlCriteria) {
        // Native EdgeControl syntax detected - returning as is.
        // Used to support if statement criteria fallbacks.
        return ecCriteria.edgeControlCriteria;
    }
    const edgeJsCriteria = criteria;
    // created by usage of 'and', 'or' utility functions
    if (edgeJsCriteria instanceof RouteCriteria_1.AndOperator || edgeJsCriteria instanceof RouteCriteria_1.OrOperator) {
        // we filter null values, as it means no matchers were created
        return {
            [edgeJsCriteria.operator]: edgeJsCriteria.values
                .map(edgeJsCriteria => createMatchers(edgeJsCriteria))
                .filter(matchers => matchers),
        };
    }
    const matchers = [];
    const add = (property, value) => {
        const condition = (0, toCondition_1.toCondition)(property, value);
        matchers.push(condition);
    };
    if (edgeJsCriteria.path) {
        add({ request: 'path' }, edgeJsCriteria.path);
    }
    if (edgeJsCriteria.scheme) {
        add({ request: 'scheme' }, edgeJsCriteria.scheme);
    }
    if (edgeJsCriteria.method) {
        add({ request: 'method' }, typeof edgeJsCriteria.method === 'string'
            ? edgeJsCriteria.method.toUpperCase()
            : edgeJsCriteria.method // sailfish requires uppercase method names
        );
    }
    if (edgeJsCriteria.headers) {
        Object.entries(edgeJsCriteria.headers).forEach(([name, value]) => {
            add({ 'request.header': name.toLowerCase() }, value);
        });
    }
    if (edgeJsCriteria.query) {
        Object.entries(edgeJsCriteria.query).forEach(([name, value]) => {
            // if query param, we let it pass through if the value is at least length 1, as only the existence matters
            add({ 'request.origin_query': name }, typeof value === 'string' && value.startsWith(':') ? new RegExp('.+') : value);
        });
    }
    if (edgeJsCriteria.cookies) {
        Object.entries(edgeJsCriteria.cookies).forEach(([name, value]) => {
            add({ 'request.cookie': name }, value);
        });
    }
    if (edgeJsCriteria.device) {
        Object.entries(edgeJsCriteria.device).forEach(([name, value]) => {
            add({ device: name }, value);
        });
    }
    if (edgeJsCriteria.location) {
        Object.entries(edgeJsCriteria.location).forEach(([name, value]) => {
            add({ location: name }, value);
        });
    }
    if (edgeJsCriteria.variable) {
        Object.entries(edgeJsCriteria.variable).forEach(([name, value]) => {
            add({ variable: name }, value);
        });
    }
    if (edgeJsCriteria.client_ip) {
        add({ request: 'client_ip' }, edgeJsCriteria.client_ip);
    }
    if (edgeJsCriteria['referring-domain']) {
        add({ request: 'referring_domain' }, edgeJsCriteria['referring-domain']);
    }
    if ((_a = edgeJsCriteria.response) === null || _a === void 0 ? void 0 : _a.status_code) {
        add({ response: 'status_code' }, edgeJsCriteria.response.status_code);
    }
    if (matchers.length === 0) {
        return null;
    }
    // when we have only one matcher, we don't need to wrap it in an array
    // we need to extract it from the array, otherwise wrap it into the "and" operator
    return (matchers.length === 1 ? matchers[0] : { and: matchers });
}
exports.createMatchers = createMatchers;
