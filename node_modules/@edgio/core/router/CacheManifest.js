"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheManifest = void 0;
const constants_1 = require("../constants");
const fromTimeUnitAbbrev_1 = require("./converters/fromTimeUnitAbbrev");
const RulesConditionalVisitor_1 = __importDefault(require("../runtime/rules/RulesConditionalVisitor"));
const deepMerge_1 = __importDefault(require("../utils/deepMerge"));
/**
 * This class represents the CacheManifest structure,
 * and provides helper methods.
 * @private
 */
class CacheManifest {
    constructor() {
        /**
         * The array of edge-control rules.
         */
        this.rules = [];
    }
    /**
     * Creates new instance from the object.
     */
    static from(obj) {
        return Object.assign(new CacheManifest(), obj);
    }
    /**
     * Returns true if provided URL should be prefetched.
     */
    shouldPrefetch(url) {
        let matchedFeatures = {};
        new RulesConditionalVisitor_1.default(this.getEvalVariableCallback(url), {
            onFeaturesVisit: features => {
                var _a;
                // We exclude the rule's features with ignore comment,
                // to provide the same experience in local simulation as on the Edge.
                if ((_a = features === null || features === void 0 ? void 0 : features.comment) === null || _a === void 0 ? void 0 : _a.includes(constants_1.EDGIO_CACHE_MANIFEST_RULE_IGNORE_COMMENT)) {
                    return;
                }
                matchedFeatures = (0, deepMerge_1.default)(matchedFeatures, features, 3);
            },
        }).visit(this.rules);
        return this.isCacheable(matchedFeatures);
    }
    /**
     * Returns the callback function which provides
     * the values for the rule conditions in browser environment.
     * We can match only against the values we can extract from the URL.
     */
    getEvalVariableCallback(url) {
        return (variable) => {
            var _a;
            if (variable['request']) {
                const param = variable['request'];
                if (param === 'method')
                    return 'GET';
                if (param === 'origin_path')
                    return url.pathname;
                if (param === 'path')
                    return url.pathname;
                if (param === 'origin_query_string')
                    return url.search.split('?')[1];
                if (param === 'query')
                    return url.search.split('?')[1];
                if (param === 'querystring')
                    return url.search.split('?')[1];
                // URL returns the protocol with colon at the end, e.g. "https:". We need to remove it.
                if (param === 'scheme')
                    return url.protocol.replace(':', '').toUpperCase();
            }
            if (variable['request.origin_query']) {
                return url.searchParams.get(variable['request.origin_query']) || undefined;
            }
            if (variable['request.path']) {
                const param = variable['request.path'];
                if (param === 'filename')
                    return url.pathname.split('/').pop();
                if (param === 'directory')
                    return (_a = url.pathname.match(/(.*)[/\\]/)) === null || _a === void 0 ? void 0 : _a[1];
                if (param === 'extension') {
                    const extension = url.pathname.split('.').pop();
                    return extension ? `.${extension}` : undefined;
                }
            }
            return undefined;
        };
    }
    /**
     * Returns true if provided Features allow to cache the URL.
     */
    isCacheable(features) {
        const { caching } = features;
        // NOTE: It would make sense to add !caching?.bypass_client_cache into the condition too
        // but all cache configs on Layer0 had cache.browser.maxAgeSeconds set to 0
        // when serviceWorkerSeconds option was set.
        // The cache.browser.maxAgeSeconds option is on v7 transformed by RouteHelper to caching.bypass_client_cache:true
        // and this would turn off the prefetching completely for those routes
        // even though it was enabled by service_worker_max_age feature.
        return Boolean((caching === null || caching === void 0 ? void 0 : caching.max_age) !== undefined &&
            (caching === null || caching === void 0 ? void 0 : caching.service_worker_max_age) &&
            (0, fromTimeUnitAbbrev_1.fromTimeUnitAbbrev)(caching.service_worker_max_age) > 0 &&
            !(caching === null || caching === void 0 ? void 0 : caching.bypass_cache));
    }
    /**
     * Returns the content of /__edgio__/cache-manifest.js
     * with serialized CacheManifest.
     */
    serialize() {
        return `self.${constants_1.EDGIO_CACHE_MANIFEST_JS_VAR_NAME}=${JSON.stringify(this)}`;
    }
}
exports.CacheManifest = CacheManifest;
