"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRule = exports.toThen = exports.toRule = void 0;
const createMatchers_1 = require("../createMatchers");
const toRule = (criteria, ...featuresOrRouters) => {
    const matchers = (0, createMatchers_1.createMatchers)(criteria);
    const then = (0, exports.toThen)(featuresOrRouters);
    // when there are no matchers for rule, we must return only feature as rule, as empty criteria is invalid and fails deployment
    if (!matchers) {
        return then;
    }
    const rule = {
        if: [matchers, then],
    };
    return rule;
};
exports.toRule = toRule;
const toThen = (featuresOrRouters = []) => {
    var _a;
    const outputRules = [];
    featuresOrRouters.forEach((featureOrRouter) => {
        const value = featureOrRouter;
        value.rules
            ? outputRules.push(...value.rules)
            : Array.isArray(value)
                ? outputRules.push(...value)
                : outputRules.push(value);
    });
    if ((_a = outputRules[0]) === null || _a === void 0 ? void 0 : _a.if) {
        // Rule array must ALWAYS start with feature - console parses that feature as a root feature of the rule.
        // Otherwise, they wouldnt be able to discern between whats root feature, and whats nested feature - it is what it is.
        return [{}, ...outputRules];
    }
    else if (outputRules.length === 1) {
        // If rule array has only 1 feature, we dont use the array -> feature will therefore not be a nested rule on console side.
        return outputRules[0];
    }
    return outputRules;
};
exports.toThen = toThen;
const isRule = (value) => !!value.if;
exports.isRule = isRule;
