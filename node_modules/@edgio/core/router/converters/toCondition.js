"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCondition = void 0;
const exact_1 = require("../../router/exact");
const toEdgeRegex_1 = __importDefault(require("../../utils/toEdgeRegex"));
const toPathRegexp_1 = __importDefault(require("../../utils/toPathRegexp"));
const RouteCriteria_1 = require("../RouteCriteria");
const toCondition = (property, value) => {
    if ((0, RouteCriteria_1.isNegation)(value)) {
        if (typeof value.not === 'string') {
            if (property.request === 'path' && (0, toPathRegexp_1.default)(value.not)) {
                return { ['!=']: [property, value.not] };
            }
            // everything that isnt a path is matched exactly without the need for exact modifier
            return { ['!==']: [property, value.not] };
        }
        else if (value.not instanceof RegExp) {
            return { ['!~']: [property, (0, toEdgeRegex_1.default)(value.not)] };
        }
        else if (value.not instanceof exact_1.ExactPath) {
            return { ['!==']: [property, value.not.value] };
        }
        else if (Array.isArray(value.not)) {
            return { not_in: [property, value.not] };
        }
    }
    else {
        if (typeof value === 'string') {
            if (property.request === 'path' && (0, toPathRegexp_1.default)(value)) {
                return { ['==']: [property, value] };
            }
            // everything that isnt a path is matched exactly without the need for exact modifier
            return { ['===']: [property, value] };
        }
        else if (value instanceof RegExp) {
            return { ['=~']: [property, (0, toEdgeRegex_1.default)(value)] };
        }
        else if (value instanceof exact_1.ExactPath) {
            return { ['===']: [property, value.value] };
        }
        else if (Array.isArray(value)) {
            return { in: [property, value] };
        }
    }
    // todo: check if this is the correct error to throw, we shouldn't allow nulls/undefineds
    // so this should be handled with ts or with runtime checks on sailfish schema during build
    throw new Error(`Invalid type for match condition: ${typeof value}`);
};
exports.toCondition = toCondition;
