"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const constants_1 = require("../constants");
const source_1 = require("../source");
const utils_1 = require("../utils");
const requireInternal_1 = __importDefault(require("../utils/requireInternal"));
const toRule_1 = require("./converters/toRule");
const toFeature_1 = require("./converters/toFeature");
const PreloadRequests_1 = __importDefault(require("./PreloadRequests"));
const exact_1 = require("../router/exact");
const environment_1 = require("../environment");
const slash_1 = __importDefault(require("slash"));
const paths_1 = require("../deploy/paths");
/**
 * The router allows to define EdgeJS rules and their associated features
 * in convenient way as a chainable javascript code.
 * Please pay attention to the following notes when using Router to avoid unexpected behavior.
 *
 * **Router evaluation**
 *
 * The defined EdgeJS rules are transformed to equivalent EdgeControl rules for the Edge
 * only once during the build of Router when it's evaluated in Edgio's serverless cloud.
 * Therefore, any other runtime modifications of the Router are not supported even though they are valid javascript code.
 *
 * Example of incorrect usages:
 * ```js
 *  import { Router } = from '@edgio/core/router'
 *
 *  const router = new Router()
 *    // This will not work!
 *    // Router cannot be modified during runtime from the compute function.
 *    .get('/products/:category/:id', ({ compute }) => {
 *      compute(async (req, res) => {
 *        if(req.path.startsWith('/product/books')){
 *          router.static('products/books')
 *        }
 *      })
 *    })
 *    // This will not work as expected!
 *    // The following code will add two independent rules, one for '/products/:category/:id' and second for '/products/books/:id',
 *    // because the called get() methods don't know about nested structure. We strongly recommend to avoid this code pattern.
 *    .get('/products/:category/:id', ({}) => {
 *      router.get('/products/books/:id', {
 *        origin: {
 *          set_origin: "api"
 *        }
 *      })
 *    })
 *
 *  export default router
 * ```
 */
class Router {
    constructor(options = {}) {
        this.rules = [];
        this.routerOptions = {};
        // We need to keep functions in object, for cases where one would initialize a nested router BEFORE the main one.
        // That would cause the indices to be invalid, and wrong functions to be invoked.
        //
        // In order to avoid confusion, and a lot of changes anywhere functions are exported (breaking to existing projects),
        // the 'functions' property remains an instance variable / isnt static.
        this.functions = {};
        this.preloadRequests = new PreloadRequests_1.default();
        /**
         * Variable that is true only if router is inside of 'if' statement.
         *
         * NOTE: we could allow user to 'else' and 'elseif' before previous 'if' calls,
         * as in many cases, it would be valid - bool was added to avoid having to handle invalid cases.
         *
         * Invalid cases :
         *   - previous conditional with already existing 'else'
         *   - features-only rule, when createMatchers returns empty criteria
         *
         * Also, it just seems wrong to allow calling something like .get().elseif()
         */
        this.isIfActive = false;
        this.routerOptions = options;
    }
    addStaticAssetManifestEntry(path, data) {
        if (Router._staticAssetManifest[path] === undefined) {
            Router._staticAssetManifest[path] = data;
        }
        else {
            // We need to make sure that we don't have duplicates in the array.
            Router._staticAssetManifest[path] = Array.from(new Set([...Router._staticAssetManifest[path], ...data]));
        }
    }
    /**
     * Returns the static asset manifest from this router file.
     * NOTE: This method is needed because we're dynamically loading
     * another Router class from a bundled routes.js file,
     * which doesn't share a same class static variables.
     */
    getStaticAssetManifest() {
        return Router._staticAssetManifest;
    }
    /**
     * Loads and returns a router from a file that exports it with `module.exports` or `export default`.
     * @param routerPath A path to routes.js,
     */
    static load(routerPath) {
        const routerModule = (0, utils_1.nonWebpackRequire)(routerPath);
        return (routerModule.default || routerModule);
    }
    /**
     * Defines a route that matches all requests.
     * @param features Features to apply on all requests.
     * @returns A self reference, suitable for chaining
     */
    always(features, options) {
        return this.matchInternal({}, features, options);
    }
    /**
     * Defines a route that matches GET requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route.
     * @returns A self reference, suitable for chaining
     */
    get(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.get, criteria, features, options);
    }
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    put(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.put, criteria, features, options);
    }
    /**
     * Defines a route that matches PATCH requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    patch(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.patch, criteria, features, options);
    }
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    post(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.post, criteria, features, options);
    }
    /**
     * Defines a route that matches HEAD requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    head(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.head, criteria, features, options);
    }
    /**
     * Defines a route that matches DELETE requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    delete(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.delete, criteria, features, options);
    }
    /**
     * Defines a route that matches OPTIONS requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    options(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.options, criteria, features, options);
    }
    /**
     * Defines a route.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    match(criteria, features, options) {
        if (typeof criteria === 'string' ||
            criteria instanceof RegExp ||
            criteria instanceof exact_1.ExactPath) {
            return this.matchInternal({ path: criteria }, features, options);
        }
        else {
            return this.matchInternal(criteria, features, options);
        }
    }
    /**
     * Registers a rule that supports advanced if/then/else logic.
     * @param criteria
     * @returns A self reference, suitable for chaining
     */
    conditional(criteria) {
        this.rules.push(criteria);
        return this;
    }
    /**
     * Adds an if condition
     * @param criteria A criteria object, with ability to create advanced criteria through 'and' and 'or' methods.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    if(criteria, featureOrRouter, ...featuresOrRouters) {
        if (Object.keys(criteria).length === 0) {
            throw new Error("If statement mustn't have empty criteria.");
        }
        this.isIfActive = true;
        this.rules.push((0, toRule_1.toRule)(criteria, ...this.createConditionFeatures(criteria, featureOrRouter, featuresOrRouters)));
        this.addNestedFunctions(featureOrRouter, featuresOrRouters);
        return this;
    }
    /**
     * Adds an elseif condition - requires either 'if' or 'elseif' functions to be called previously.
     * @param criteria A criteria object, with ability to create advanced criteria through 'and' and 'or' methods.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    elseif(criteria, featureOrRouter, ...featuresOrRouters) {
        if (Object.keys(criteria).length === 0) {
            throw new Error("Elseif statement mustn't have empty criteria.");
        }
        if (!this.isIfActive) {
            throw new Error("Call of 'elseif' must follow either 'if', or 'elseif' calls. If you are re-using the parent router, please create a new instance.");
        }
        const lastRule = this.rules[this.rules.length - 1];
        const rule = (0, toRule_1.toRule)(criteria, ...this.createConditionFeatures(criteria, featureOrRouter, featuresOrRouters));
        lastRule.if.push(...(rule.if ? rule.if : [rule]));
        this.addNestedFunctions(featureOrRouter, featuresOrRouters);
        return this;
    }
    /**
     * Adds an else condition - requires either 'if' or 'elseif' functions to be called previously.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    else(featureOrRouter, ...featuresOrRouters) {
        if (!this.isIfActive) {
            throw new Error("Call of 'else' must follow either 'if', or 'elseif' calls. If you are re-using the parent router, please create a new instance.");
        }
        const lastRule = this.rules[this.rules.length - 1];
        lastRule.if.push((0, toRule_1.toThen)(this.createConditionFeatures({}, featureOrRouter, featuresOrRouters)));
        this.addNestedFunctions(featureOrRouter, featuresOrRouters);
        this.isIfActive = false;
        return this;
    }
    /**
     * Searches through features for possible routers, adds all of their nested functions into this router.
     * @private
     */
    addNestedFunctions(featureOrRouter, featuresOrRouters = []) {
        ;
        [featureOrRouter, ...featuresOrRouters].forEach((featureOrRouter) => {
            // We know its a router if it has functions.
            if (featureOrRouter === null || featureOrRouter === void 0 ? void 0 : featureOrRouter.functions) {
                // We merge the functions - as the index is global, none of them will overlap.
                // We dont create a new object, to keep the original reference.
                Object.entries(featureOrRouter.functions).forEach(([key, value]) => (this.functions[key] = value));
            }
        });
    }
    /**
     * Registers a plugin that adds group of rules into the router.
     * This method should be always called before any other methods that add rules.
     * **Example**
     *
     * ```js
     *  import { Router } = from '@edgio/core/router'
     *  import { nextRoutes } from '@edgio/next'
     *
     * export default new Router()
     *   // NextRoutes automatically adds rules for all Next.js pages and their assets.
     *   // This should be called before any custom rules are added.
     *   .use(nextRoutes)
     *   .get('/custom-rule', {
     *      origin: {
     *        set_origin: "api"
     *      }
     *   })
     * ```
     * @param plugin
     */
    use(plugin) {
        plugin.onRegister(this);
        return this;
    }
    // We normalize all feature creators into features
    createConditionFeatures(criteria, featureOrRouter, featuresOrRouters = []) {
        return [featureOrRouter, ...featuresOrRouters].map(featureOrRouter => typeof featureOrRouter === 'function'
            ? (0, toFeature_1.toFeature)(criteria, featureOrRouter, this)
            : featureOrRouter);
    }
    /**
     * Internal normalized method for adding a route.
     * @param criteria
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    matchInternal(criteria, featuresParam, options) {
        // convert to rule and add it internally
        const features = (0, toFeature_1.toFeature)(criteria, featuresParam, this);
        const rule = (0, toRule_1.toRule)(criteria, features);
        this.rules.push(rule);
        // We must deactivate conditions for cases where they wouldnt be closed with 'else'.
        // All other places either call matchInternal, or all irrelevant, as they dont create any rules.
        this.isIfActive = false;
        return this;
    }
    /**
     * Adds a route that matches the specific HTTP method and additional criteria.
     * @param method An HTTP method
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    matchMethod(method, criteria, features, options) {
        if (typeof criteria === 'string' ||
            criteria instanceof RegExp ||
            criteria instanceof exact_1.ExactPath) {
            return this.match({
                method,
                path: criteria,
            }, features);
        }
        if (criteria === null || criteria === void 0 ? void 0 : criteria.method) {
            throw new Error(`Invalid criteria property method passed to call to Router#${method}. Specifying a method in the criteria is redundant.`);
        }
        return this.match({ ...criteria, method }, features, options);
    }
    /**
     * Adds routes for all files in a directory tree.
     * @private
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param features A features that will be used to handle the matched files.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    dir(sourcePath, features, options = {}) {
        const createInMatcher = (files) => {
            // Don't create any rule if there are no files
            if (!files || files.length === 0)
                return;
            const paths = files
                .flatMap(file => { var _a; return ((_a = options === null || options === void 0 ? void 0 : options.paths) === null || _a === void 0 ? void 0 : _a.call(options, file)) || [`/${file}`]; })
                .flatMap(path => {
                if (!path.endsWith('/index.html'))
                    return [path];
                // Add additional paths for index.html files
                return Array.from(new Set([
                    // Add path with trailing slash
                    // Example: /folder/ for /folder/index.html
                    path.toString().replace(/\/index.html$/, '/'),
                    // Add path without trailing slash
                    // Example: /folder for /folder/index.html
                    path.toString().replace(/\/index.html$/, ''),
                ])).filter(path => path.length > 0);
            });
            this.match({ path: paths }, features);
        };
        if ((0, environment_1.isCloud)()) {
            const files = this.staticAssetsForPath(sourcePath);
            createInMatcher(files);
        }
        else {
            const files = Router.collectFiles(sourcePath, options);
            this.addStaticAssetManifestEntry((0, slash_1.default)(sourcePath), files);
            createInMatcher(files);
        }
        return this;
    }
    /**
     * Adds routes for all static assets in a directory tree.
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath, options = {}) {
        const features = (helper) => {
            helper.serveStatic(`${sourcePath}/:path*`, {
                rewritePathSource: options === null || options === void 0 ? void 0 : options.rewritePathSource,
            });
            if (options === null || options === void 0 ? void 0 : options.handler)
                options.handler(helper);
        };
        return this.dir(sourcePath, features, options);
    }
    /**
     * Since the files are now on S3, we can no longer crawl the file system to
     * determine the routes, so we use the manifest file.
     * We also prevent webpack from trying to bundle the manifest, which will fail.
     */
    staticAssetsForPath(path) {
        return (0, utils_1.nonWebpackRequire)((0, paths_1.getStaticAssetManifestPath)())[path];
    }
    /**
     * Registers Edgio Cloud Function. Returns the index of the function being registered so that it can be called
     * at runtime based on the `x-edg-fn` request header.
     * @private
     * @param fn The Edgio Cloud Function to store
     * @returns the index of the function being registered
     */
    addFunction(fn) {
        // We use the global index in order to make sure we link function in the nested routers properly.
        // Alternativelly, we could either create a hash of the function, or use UUID - both of those would look bad in the UI.
        // We dont expect the global state to be an issue apart from potential unit test confusion.
        // But even for unit tests, its only an issue if testing against exact indices, the execution should be ok no matter what.
        this.functions[Router.functionIndex] = fn;
        return Router.functionIndex++;
    }
    /**
     * Adds preload config for router
     *
     * ```js
     *  new Router().prerender(
     *    async () => [{ path: '/foo', headers: { foo: 'bar' } }],
     *    [{ path: '/bar' }]
     *  )
     * ```
     *
     * @param preloadOptions
     * @private
     */
    prerender(...preloadOptions) {
        this.preloadRequests.push(...preloadOptions);
        return this;
    }
    /**
     * Disables crawling of permalinks by setting the `x-robots-tag: noindex` response header
     * for hosts matching edgio.link or edgio-perma.link.
     *
     * ```js
     *  new Router().noIndexPermalink()
     * ```
     *   @deprecated Deprecated. Indexing permalinks is automatically disabled. Use `indexPermalink?: boolean` on Router Options to enable them.
     * * @returns {Router} A self-reference, suitable for chaining.
     */
    noIndexPermalink() {
        // The functionality of this function is automatically taken over
        // packages/core/src/router/addBuildInRoutes.ts
        return this;
    }
    static collectFiles(sourcePath, options) {
        var _a;
        const directory = (0, path_1.join)((0, source_1.getSourceDir)(), sourcePath);
        const ignore = typeof options.ignore === 'string' ? [options.ignore] : (_a = options.ignore) !== null && _a !== void 0 ? _a : [];
        // glob is large and we don't need it in production so we use nonWebpackRequire
        let files = (0, requireInternal_1.default)('globby').sync(options.glob || '**/*', {
            cwd: directory,
            onlyFiles: true,
            ignore,
        });
        if (options.sort) {
            files = options.sort(files);
        }
        return files;
    }
    /**
     * Adds a route that matches all requests that result in an error.
     *
     * Example:
     *
     * ```js
     *  new Router()
     *    .catch(/^(4|5)\d{2}$/, {
     *      // retry all 4xx and 5xx errors using the legacy origin
     *      retry: {
     *        origin: "legacy",
     *      },
     *    });
     * ```
     *
     * @param error A regular expression, string or number that matches the status code returned by the origin
     * @param features Features to apply when a request matches the route
     * @returns A self-reference, suitable for chaining.
     */
    catch(error, features) {
        let errorRegex;
        if (error instanceof RegExp) {
            errorRegex = error;
        }
        else {
            errorRegex = new RegExp(`^${error.toString()}$`);
        }
        return this.matchInternal({ response: { status_code: errorRegex } }, features);
    }
}
exports.default = Router;
// We keep a static global function index in order to support nested routers.
Router.functionIndex = 0;
/**
 * The contents to be written to static-asset-manifest.json, which is used to recreate
 * the paths for router.static(dir) when generating the rules for EdgeControl.
 * This is a static variable, so it can be shared across all instances of Router
 * and works with nested rules too.
 * @private
 */
Router._staticAssetManifest = {};
