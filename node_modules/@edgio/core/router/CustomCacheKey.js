"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Allows you to split or normalize the cache space for a given route. Common use cases include:
 *
 * - serving multiple variants of the same URL based on a currency and/or language cookie.
 * - caching different responses based on device type
 * - ignoring all but a specific set of query parameters when looking up a response from the cache.
 *
 * **Example**
 *
 * ```js
 *  import { Router, CustomCacheKey } from '@edgio/core/router'
 *
 *  new Router()
 *    .match('/some-path', ({ cache }) => {
 *      cache({
 *        key: new CustomCacheKey()
 *          .excludeAllQueryParametersExcept('color', 'size')
 *          .addCookie('currency')
 *          .addDevice()
 *        edge: {
 *          maxAgeSeconds: 60 * 60
 *        }
 *      })
 *    })
 * ```
 */
class CustomCacheKey {
    constructor() {
        this.excludeAllQueryParametersFlag = false;
        this.excludeQueryParametersFlag = [];
        this.excludeAllQueryParametersExceptFlag = [];
        this.headersFlag = [];
        this.cookiesFlag = [];
        this.removeMethodFlag = false;
        this.isBotFlag = false;
        this.vendorFlag = false;
        this.deviceFlag = false;
        this.browserFlag = false;
    }
    /**
     * Excludes the entire query string from the cache key.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeAllQueryParameters() {
        this.excludeAllQueryParametersFlag = true;
        return this;
    }
    /**
     * Excludes the provided query parameters from the cache key.  All other parameters
     * will still be part of the cache key. We also refer to this as "blacklisting" query parameters.
     * @param names The names of the query parameters to blacklist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeQueryParameters(...names) {
        this.excludeQueryParametersFlag = [...this.excludeQueryParametersFlag, ...names];
        return this;
    }
    /**
     * Excludes all query parameters except those provided from the cache key.  We also refer to
     * this as "whitelisting" query parameters.  We recommend using this method over `excludeQueryParameters`
     * as it's difficult to know all of the query parameters your application might receive and unexpected
     * query parameters can lead to significantly lower cache hit rates.
     * @param names The names of the query parameters to whitelist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeAllQueryParametersExcept(...names) {
        this.excludeAllQueryParametersExceptFlag = [
            ...this.excludeAllQueryParametersExceptFlag,
            ...names,
        ];
        return this;
    }
    /**
     * Adds a request header to the cache key.
     * This will have no effect on service worker cache.
     * @param name The name of the request header
     * @param createGroups A function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addHeader(name) {
        this.headersFlag = [...this.headersFlag, name];
        return this;
    }
    /**
     * Adds a cookie to the cache key.
     * This will have no effect on service worker cache.
     * @param name The name of the cookie
     * @param createGroups An function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addCookie(name) {
        this.cookiesFlag = [...this.cookiesFlag, name];
        return this;
    }
    /**
     * Removes the HTTP method from the cache key.
     * @return A self-reference, suitable for chaining.
     */
    removeMethod() {
        this.removeMethodFlag = true;
        return this;
    }
    /**
     * This method is not supported, and will throw an error if called.
     */
    removeBody() {
        throw new Error('Not supported');
    }
    /**
     * Specifies that requests should be cached on a per-device basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addDevice() {
        this.deviceFlag = true;
        return this;
    }
    /**
     * Specifies that requests should be cached on a per-vendor basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addVendor() {
        this.vendorFlag = true;
        return this;
    }
    /**
     * Specifies that requests should be cached differently for bots.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addIsBot() {
        this.isBotFlag = true;
        return this;
    }
    /**
     * Specifies that requests should be cached on a per-browser basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addBrowser() {
        this.browserFlag = true;
        return this;
    }
    applyCaching(features) {
        if (features.caching === undefined) {
            features.caching = {};
        }
        const { caching } = features;
        const shouldOverwriteCache = this.excludeQueryParametersFlag.length > 0 ||
            this.excludeAllQueryParametersExceptFlag.length > 0 ||
            this.excludeAllQueryParametersFlag ||
            this.headersFlag.length > 0 ||
            this.cookiesFlag.length > 0 ||
            this.isBotFlag ||
            this.vendorFlag ||
            this.deviceFlag ||
            this.browserFlag;
        if (shouldOverwriteCache && caching.cache_key === undefined) {
            caching.cache_key = {};
        }
        if (this.excludeAllQueryParametersFlag) {
            caching.cache_key.exclude_all_query_params = true;
        }
        // Note: we cast every array to `any` because the type definitions for Sailfish type
        // for arrays are defined as [string, ...string[]] which means that at least one element
        // must be present. As we are using the `length` property to check if the array is empty
        // we know that the array is not empty, but the type definitions don't know that.
        if (this.excludeQueryParametersFlag.length > 0) {
            caching.cache_key.include_all_query_params_except = this.excludeQueryParametersFlag;
        }
        if (this.excludeAllQueryParametersExceptFlag.length > 0) {
            caching.cache_key.include_query_params = this.excludeAllQueryParametersExceptFlag;
        }
        if (this.headersFlag.length > 0) {
            caching.cache_key.include_headers = this.headersFlag;
        }
        if (this.cookiesFlag.length > 0) {
            caching.cache_key.include_cookies = this.cookiesFlag;
        }
        let expressions = [];
        if (this.deviceFlag) {
            expressions = [
                ...expressions,
                `/device:smartphone_%{wurfl_vcap_is_smartphone}_tablet_%{wurfl_cap_is_tablet}_desktop_%{wurfl_vcap_is_full_desktop}`,
            ];
        }
        if (this.isBotFlag) {
            expressions = [...expressions, `/bot:%{wurfl_vcap_is_robot}`];
        }
        if (this.vendorFlag) {
            expressions = [
                ...expressions,
                `/vendor:ios_%{wurfl_vcap_is_ios}_adndroid_%{wurfl_vcap_is_android}`,
            ];
        }
        if (this.browserFlag) {
            expressions = [...expressions, `/browser:%{wurfl_cap_mobile_browser}`];
        }
        if (expressions.length > 0) {
            caching.cache_key.include_expressions = expressions;
        }
        if (this.removeMethodFlag) {
            caching.enable_caching_for_methods = undefined;
        }
    }
}
exports.default = CustomCacheKey;
