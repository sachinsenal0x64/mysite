import { StaticOptions } from './StaticOptions';
import { Features, Matches, Rules } from '../types';
import RouteCriteria, { ConditionCriteria, PathMatchValue } from './RouteCriteria';
import { FeatureCreator } from './RouteHelper';
import Response from '../runtime/Response';
import Request from '../runtime/Request';
import PropertyContext from '../runtime/PropertyContext';
import { DirOptions } from './DirOptions';
import PreloadRequests from './PreloadRequests';
import { PreloadOption } from './Preload';
export type FeaturesParam = FeatureCreator | Features;
export type ConditionFeaturesParam = FeaturesParam | Router | Rules[];
/**
 * Edgio Cloud Function that is executed in Edgio's serverless cloud
 * to compute the response for a request.
 */
export type ComputeFn = (req: Request, res: Response, propertyContext: PropertyContext) => Promise<void> | void;
/**
 * Options for configuring the router.
 */
export interface RouterOptions {
    /**
     * If `true`, the router will not add the `x-robots-tag: noindex nofollow` header to
     * requests for hosts matching Edgio's default URLs. e.g. my-site-default.layer0-limelight.link
     */
    indexPermalink?: boolean;
    /**
     * The optional path to the edge functions init script singleton.
     */
    edge_function_init_script?: string;
}
/**
 * Options for defining a route.
 */
export interface RouteOptions {
    /**
     * Adds the label for static routes
     */
    label?: string;
}
/**
 * A plugin that can be registered with a router. This is used by Edgio as plugin mechanism to
 * implement custom connectors like `@edgio/next` and `@edgio/react`.
 */
export interface RouterPlugin {
    onRegister: (router: Router) => void;
}
/**
 * The router allows to define EdgeJS rules and their associated features
 * in convenient way as a chainable javascript code.
 * Please pay attention to the following notes when using Router to avoid unexpected behavior.
 *
 * **Router evaluation**
 *
 * The defined EdgeJS rules are transformed to equivalent EdgeControl rules for the Edge
 * only once during the build of Router when it's evaluated in Edgio's serverless cloud.
 * Therefore, any other runtime modifications of the Router are not supported even though they are valid javascript code.
 *
 * Example of incorrect usages:
 * ```js
 *  import { Router } = from '@edgio/core/router'
 *
 *  const router = new Router()
 *    // This will not work!
 *    // Router cannot be modified during runtime from the compute function.
 *    .get('/products/:category/:id', ({ compute }) => {
 *      compute(async (req, res) => {
 *        if(req.path.startsWith('/product/books')){
 *          router.static('products/books')
 *        }
 *      })
 *    })
 *    // This will not work as expected!
 *    // The following code will add two independent rules, one for '/products/:category/:id' and second for '/products/books/:id',
 *    // because the called get() methods don't know about nested structure. We strongly recommend to avoid this code pattern.
 *    .get('/products/:category/:id', ({}) => {
 *      router.get('/products/books/:id', {
 *        origin: {
 *          set_origin: "api"
 *        }
 *      })
 *    })
 *
 *  export default router
 * ```
 */
export default class Router {
    rules: Rules[];
    routerOptions: RouterOptions;
    static functionIndex: number;
    readonly functions: {
        [index: string]: ComputeFn;
    };
    readonly preloadRequests: PreloadRequests;
    /**
     * Variable that is true only if router is inside of 'if' statement.
     *
     * NOTE: we could allow user to 'else' and 'elseif' before previous 'if' calls,
     * as in many cases, it would be valid - bool was added to avoid having to handle invalid cases.
     *
     * Invalid cases :
     *   - previous conditional with already existing 'else'
     *   - features-only rule, when createMatchers returns empty criteria
     *
     * Also, it just seems wrong to allow calling something like .get().elseif()
     */
    isIfActive: boolean;
    /**
     * The contents to be written to static-asset-manifest.json, which is used to recreate
     * the paths for router.static(dir) when generating the rules for EdgeControl.
     * This is a static variable, so it can be shared across all instances of Router
     * and works with nested rules too.
     * @private
     */
    static _staticAssetManifest: {
        [key: string]: string[];
    };
    constructor(options?: RouterOptions);
    private addStaticAssetManifestEntry;
    /**
     * Returns the static asset manifest from this router file.
     * NOTE: This method is needed because we're dynamically loading
     * another Router class from a bundled routes.js file,
     * which doesn't share a same class static variables.
     */
    getStaticAssetManifest(): {
        [key: string]: string[];
    };
    /**
     * Loads and returns a router from a file that exports it with `module.exports` or `export default`.
     * @param routerPath A path to routes.js,
     */
    static load(routerPath: string): Router;
    /**
     * Defines a route that matches all requests.
     * @param features Features to apply on all requests.
     * @returns A self reference, suitable for chaining
     */
    always(features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches GET requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route.
     * @returns A self reference, suitable for chaining
     */
    get(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    put(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches PATCH requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    patch(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    post(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches HEAD requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    head(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches DELETE requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    delete(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route that matches OPTIONS requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    options(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Defines a route.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    match(criteria: RouteCriteria | PathMatchValue, features: FeaturesParam, options?: RouteOptions): this;
    /**
     * Registers a rule that supports advanced if/then/else logic.
     * @param criteria
     * @returns A self reference, suitable for chaining
     */
    conditional(criteria: Matches): this;
    /**
     * Adds an if condition
     * @param criteria A criteria object, with ability to create advanced criteria through 'and' and 'or' methods.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    if(criteria: ConditionCriteria, featureOrRouter: ConditionFeaturesParam, ...featuresOrRouters: ConditionFeaturesParam[]): this;
    /**
     * Adds an elseif condition - requires either 'if' or 'elseif' functions to be called previously.
     * @param criteria A criteria object, with ability to create advanced criteria through 'and' and 'or' methods.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    elseif(criteria: ConditionCriteria, featureOrRouter: ConditionFeaturesParam, ...featuresOrRouters: ConditionFeaturesParam[]): this;
    /**
     * Adds an else condition - requires either 'if' or 'elseif' functions to be called previously.
     * @param featuresOrRouter features to be applied, or router to be nested.
     * @param featuresOrRouters additional features to be applied, or routers to be nested.
     * @returns A self reference, suitable for chaining
     */
    else(featureOrRouter: ConditionFeaturesParam, ...featuresOrRouters: ConditionFeaturesParam[]): this;
    /**
     * Searches through features for possible routers, adds all of their nested functions into this router.
     * @private
     */
    addNestedFunctions(featureOrRouter: ConditionFeaturesParam, featuresOrRouters?: ConditionFeaturesParam[]): void;
    /**
     * Registers a plugin that adds group of rules into the router.
     * This method should be always called before any other methods that add rules.
     * **Example**
     *
     * ```js
     *  import { Router } = from '@edgio/core/router'
     *  import { nextRoutes } from '@edgio/next'
     *
     * export default new Router()
     *   // NextRoutes automatically adds rules for all Next.js pages and their assets.
     *   // This should be called before any custom rules are added.
     *   .use(nextRoutes)
     *   .get('/custom-rule', {
     *      origin: {
     *        set_origin: "api"
     *      }
     *   })
     * ```
     * @param plugin
     */
    use(plugin: RouterPlugin): this;
    private createConditionFeatures;
    /**
     * Internal normalized method for adding a route.
     * @param criteria
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    private matchInternal;
    /**
     * Adds a route that matches the specific HTTP method and additional criteria.
     * @param method An HTTP method
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    private matchMethod;
    /**
     * Adds routes for all files in a directory tree.
     * @private
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param features A features that will be used to handle the matched files.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    dir(sourcePath: string, features: FeaturesParam, options?: DirOptions): this;
    /**
     * Adds routes for all static assets in a directory tree.
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath: string, options?: StaticOptions): this;
    /**
     * Since the files are now on S3, we can no longer crawl the file system to
     * determine the routes, so we use the manifest file.
     * We also prevent webpack from trying to bundle the manifest, which will fail.
     */
    private staticAssetsForPath;
    /**
     * Registers Edgio Cloud Function. Returns the index of the function being registered so that it can be called
     * at runtime based on the `x-edg-fn` request header.
     * @private
     * @param fn The Edgio Cloud Function to store
     * @returns the index of the function being registered
     */
    addFunction(fn: ComputeFn): number;
    /**
     * Adds preload config for router
     *
     * ```js
     *  new Router().prerender(
     *    async () => [{ path: '/foo', headers: { foo: 'bar' } }],
     *    [{ path: '/bar' }]
     *  )
     * ```
     *
     * @param preloadOptions
     * @private
     */
    prerender(...preloadOptions: PreloadOption[]): this;
    /**
     * Disables crawling of permalinks by setting the `x-robots-tag: noindex` response header
     * for hosts matching edgio.link or edgio-perma.link.
     *
     * ```js
     *  new Router().noIndexPermalink()
     * ```
     *   @deprecated Deprecated. Indexing permalinks is automatically disabled. Use `indexPermalink?: boolean` on Router Options to enable them.
     * * @returns {Router} A self-reference, suitable for chaining.
     */
    noIndexPermalink(): this;
    static collectFiles(sourcePath: string, options: DirOptions): string[];
    /**
     * Adds a route that matches all requests that result in an error.
     *
     * Example:
     *
     * ```js
     *  new Router()
     *    .catch(/^(4|5)\d{2}$/, {
     *      // retry all 4xx and 5xx errors using the legacy origin
     *      retry: {
     *        origin: "legacy",
     *      },
     *    });
     * ```
     *
     * @param error A regular expression, string or number that matches the status code returned by the origin
     * @param features Features to apply when a request matches the route
     * @returns A self-reference, suitable for chaining.
     */
    catch(error: RegExp | string | number, features: FeaturesParam): this;
}
