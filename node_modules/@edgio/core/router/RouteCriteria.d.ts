import { Conditionals, RulesVariables } from '../types';
import { ExactPath } from '../router/exact';
/**
 * Criteria for matching against the response.
 * @private
 */
interface RouteCriteriaResponse {
    /**
     * The status code of the origin response.
     */
    status_code: RegExp;
}
export type CriteraBaseValue = string | RegExp;
export interface Negation<NegationType = CriteraBaseValue | PathMatchValue | InOperatorValues> {
    not: NegationType;
}
export type CriteriaValue = CriteraBaseValue | Negation<CriteraBaseValue>;
export type OptionalCriteriaValue = CriteriaValue | null;
export type PathMatchValue = CriteraBaseValue | ExactPath;
export type PathCriteriaValue = PathMatchValue | Negation<PathMatchValue>;
export declare const isNegation: (value?: OptionalCriteriaValue | PathCriteriaValue | InOperatorCriteriaValue) => value is Negation<any>;
export type Location = NonNullable<RulesVariables['location']>;
export type Device = NonNullable<RulesVariables['device']>;
export type Variable = NonNullable<RulesVariables['variable']>;
/**
 * This is a generic array of values when we want to match multiple values
 * againts one of the criteria values. Matching multiple values for a criteria will
 * use simple string (or number in edge cases) comparison, so if multiple matching
 * is needed with advanced matching, then use CriteriaValue and create nested rules.
 *
 * @example
 * match({ path: ['/foo', '/bar'] }, features)
 *
 * will match againts the /foo and /bar paths on { request: 'path' } criteria.
 * match is done with in operator, so it is same as doing ifs with or between them.
 **/
export type InOperatorValues<ItemType = string> = ItemType[];
export type InOperatorCriteriaValue<ItemType = string> = InOperatorValues<ItemType> | Negation<InOperatorValues<ItemType>>;
declare class CriteriaOperator {
    values: ConditionCriteria[];
    constructor(values: ConditionCriteria[]);
}
export declare class AndOperator extends CriteriaOperator {
    operator: string;
}
export declare class OrOperator extends CriteriaOperator {
    operator: string;
}
/**
 * Criteria for matching a request.
 *
 * It can either be RouteCriteria (+ related helper functions) for simple use:
 * https://docs.edg.io/guides/v7/performance/cdn_as_code/route_criteria#simple-path-matching
 *
 * Or a more complex EdgeControlCriteria (JSON logic), usable for obscure criteria that arent supported by EdgeJSCriteria:
 * https://docs.edg.io/guides/v7/performance/cdn_as_code/conditional_routes#complex-criteria
 */
export type ConditionCriteria = EdgeControlCriteria | RouteCriteria | AndOperator | OrOperator;
/**
 * Creates an AND operator for router's condition functions
 */
export declare function and(...criterias: RouteCriteria[]): AndOperator;
/**
 * Creates an OR operator for router's condition functions
 */
export declare function or(...criterias: RouteCriteria[]): OrOperator;
/**
 * Creates negation for router's condition
 */
export declare function not(value: CriteraBaseValue | PathMatchValue | InOperatorValues): Negation;
export interface EdgeControlCriteria {
    /**
     * Allows to define custom JSON logic for matching obscure criteria.
     * See https://docs.edg.io/guides/v7/performance/cdn_as_code/route_criteria#types-of-operators-and-conditionals for reference.
     */
    edgeControlCriteria: Boolean | Conditionals;
}
export default interface RouteCriteria {
    /**
     * Matches a request based on its protocol / scheme. Unless explicitly specified then `https`
     * is the default. To serve a route on both HTTPS and HTTP you can specify `/https?/`
     * regex. If an HTTP request is not matched against any route, Edgio will
     * automatically issue a redirect to equivalent HTTPS URL.
     */
    scheme?: CriteriaValue | InOperatorCriteriaValue;
    /**
     * Matches a request based on one or more header values. Keys are
     * case-insensitive header names, values are regular expressions to match or null.
     * When value is null then requests are matched for the header not being present.
     */
    headers?: {
        [name: string]: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches a request based on one or more cookie values. Keys are
     * case-sensitive cookie names, values are regular expressions to match or null.
     * When value is null then requests are matched for the cookie not being present.
     */
    cookies?: {
        [name: string]: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches a request based on one or more query parameter values. Keys are
     * case-sensitive names, values are regular expressions to match or null.
     * When value is null then requests are matched for the query parameter not being present.
     */
    query?: {
        [name: string]: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches a request based on the HTTP method. Instead of this, prefer using
     * `get`, `post`, `put`, `delete`, `options`, and `patch` methods.
     */
    method?: CriteriaValue | InOperatorCriteriaValue;
    /**
     * Matches a request based on the path. The same path syntax is used by
     * the simple form of the Router class's `match` method.
     * The path can be an express-style path expression or regular expression.
     * Both express-style path and regular expression need to match the entire path including the leading slash.
     * @example "/products/:id"
     * @example /^\/products\/(.+)$/
     */
    path?: PathCriteriaValue | InOperatorCriteriaValue;
    random?: number | InOperatorCriteriaValue<number>;
    pop_code?: string | InOperatorCriteriaValue;
    /**
     * Matches a request based on the specific location property.
     * See: https://docs.edgecast.com/cdn/index.html#HRE/M/Location-Match-Conditions.htm%3FTocPath%3DContent%2520Delivery%7CRequest%7CCustom%2520Request%2520Handling%2520via%2520Rules%2520Engine%7CMatches%2520and%2520Features%7CMatches%7CLocation%7C_____0
     */
    location?: {
        [name in Location]?: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches a request based on the variable value.
     */
    variable?: {
        [name in Variable]?: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches a request based on the specific device property.
     * See: https://docs.edgecast.com/cdn/index.html#HRE/M/Device-Match_Condtions.htm%3FTocPath%3DContent%2520Delivery%7CRequest%7CCustom%2520Request%2520Handling%2520via%2520Rules%2520Engine%7CMatches%2520and%2520Features%7CMatches%7CDevice%7C_____0
     */
    device?: {
        [name in Device]?: OptionalCriteriaValue | InOperatorCriteriaValue;
    };
    /**
     * Matches properties of the response response.
     */
    response?: RouteCriteriaResponse;
    /**
     * Matches a request based on the client ip variable value(s).
     */
    client_ip?: string | InOperatorCriteriaValue;
    /**
     * Matches a request based on the referring-domain variable value(s).
     */
    'referring-domain'?: string | InOperatorCriteriaValue;
}
export {};
