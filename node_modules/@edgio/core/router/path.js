"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nameParamsToIndex = exports.getBackReferences = exports.mapURL = exports.rewritePath = exports.pathToRegex = void 0;
const path_to_regexp_1 = require("path-to-regexp");
const bindParams_1 = __importDefault(require("../utils/bindParams"));
const toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
const toRegExp_1 = __importDefault(require("../runtime/toRegExp"));
/**
 * Converts an express-style path pattern like /products/:id to a regular expression source string
 * suitable for assignment to Router features.
 * @param path
 * @returns
 */
function pathToRegex(path) {
    let prefix = '';
    const protocolRegex = /^[a-z]+:\/\//i;
    const matches = protocolRegex.exec(path);
    if (matches) {
        prefix = matches[0];
    }
    const pathPart = path.substring(prefix.length);
    // @ts-ignore
    return (0, toEdgeRegex_1.default)((0, path_to_regexp_1.pathToRegexp)(pathPart), prefix);
}
exports.pathToRegex = pathToRegex;
/**
 * Creates a regex rewrite object based on the specified sourcePath and destPath, both
 * of which accept express-style path strings.
 * @param sourcePath
 * @param destPath
 * @param options Additional options that allow to control the rewrite behavior
 * @returns
 */
function rewritePath(sourcePath, destPath, options) {
    const { skipQuery = false, skipSlash = false } = options || {};
    if (sourcePath == null)
        return { destination: destPath };
    // The regex is matched in mod_rewrite against the whole URL instead of path.
    // Options allow us to adjust regex to match URL with optional query at the end as well
    // as optional trailing slash in some cases.
    return {
        source: `${sourcePath}:optionalSlash(\\/?)?:optionalQuery(\\?.*)?`,
        syntax: 'path-to-regexp',
        destination: `${destPath}${skipSlash ? '' : ':optionalSlash'}${skipQuery ? '' : ':optionalQuery'}`,
    };
}
exports.rewritePath = rewritePath;
/**
 * Returns rewritten url based on the specified sourcePath and destPath.
 * The unchanged destination is returned when no sourcePath is provided.
 * The null is returned when url does not match sourcePath.
 * @param url
 * @param source
 * @param destination
 * @param syntax
 * @returns
 */
function mapURL(url, source, destination, syntax) {
    let targetSource;
    let targetDest = destination;
    // return unchanged dest  when no source is provided
    if (!source)
        return targetDest;
    // determine source syntax and convert it to regex
    if (syntax === 'regexp') {
        targetSource = (0, toRegExp_1.default)(source, ''); // no flags used in order to avoid invalid group mapping
    }
    else {
        // path-to-regexp syntax is used by default
        targetSource = (0, path_to_regexp_1.pathToRegexp)(source);
        // we map references onto the destination string, which is expected to be input in path-to-regexp format also
        targetDest = (0, bindParams_1.default)(destination, getBackReferences(source));
    }
    // return null when url does not match source
    if (!url.match(targetSource))
        return null;
    return url.replace(targetSource, targetDest);
}
exports.mapURL = mapURL;
/*
Uncomment when we we support url.path_rewrite
export function mapPath(
  url: string,
  source: string | undefined,
  destination: string,
  syntax?: 'path-to-regexp' | 'regexp'
) {
  let targetSource
  let targetDest = destination
  const parsed = new URL(url, 'http://localhost')

  if (source) {
    if (syntax === 'regexp') {
      targetSource = toRegExp(source, '') // no flags used in order to avoid invalid group mapping
    } else {
      // path-to-regexp syntax is used by default
      targetSource = pathToRegexp(source)
      // we map references onto the destination string, which is expected to be input in path-to-regexp format also
      targetDest = bindParams(destination, getBackReferences(source))
    }
    return `${parsed.pathname.replace(targetSource, targetDest)}${parsed.search}`
  } else {
    return `${targetDest}${parsed.search}`
  }
}
*/
function getBackReferences(path) {
    // In case path is an absolute path
    const absolutePathMatch = path.match(/https?:\/\/[^/]+(.*)/);
    if (absolutePathMatch) {
        path = `/${absolutePathMatch[1]}`;
    }
    // Back reference counting starts from 1
    let backReferenceCounter = 1;
    const references = {};
    (0, path_to_regexp_1.parse)(path).forEach(token => {
        if (typeof token !== 'string') {
            references[token.name] = `$${backReferenceCounter++}`; // double $$ escapes backreferences so "$N" actually gets inserted into the string
        }
    });
    return references;
}
exports.getBackReferences = getBackReferences;
/**
 * Converts named parameters from regex-to-path format to regex substitution format
 * with indexes.
 * @param source
 * @param destination
 * @returns
 */
function nameParamsToIndex(source, destination) {
    const backReferences = getBackReferences(source);
    const matches = [
        ...destination.matchAll(/:(.[a-z_-]+)[+|*]/g),
        ...destination.matchAll(/:(.[a-z_-]+)/g),
    ];
    matches.forEach(match => {
        if (!Object.keys(backReferences).includes(match[1]))
            return;
        const index = Object.keys(backReferences).indexOf(match[1]);
        destination = destination.replace(match[0], `$${index}`);
    });
    return destination;
}
exports.nameParamsToIndex = nameParamsToIndex;
