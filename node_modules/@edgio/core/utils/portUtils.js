"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPortBound = exports.getNearestUnboundPort = void 0;
const net_1 = __importDefault(require("net"));
/**
 * Attempts to find the nearest unbound port
 * @param port
 */
async function getNearestUnboundPort(port) {
    if (port > 65535) {
        return undefined;
    }
    const portBound = await isPortBound(port);
    return portBound ? getNearestUnboundPort(port + 1) : port;
}
exports.getNearestUnboundPort = getNearestUnboundPort;
/**
 * Returns true if the port is in use
 * @param port
 * @param host
 */
async function isPortBound(port, host = '127.0.0.1') {
    return new Promise((resolve, reject) => {
        let client;
        if (port > 65535 || port <= 0) {
            reject(new Error('Invalid port'));
            return;
        }
        if (!net_1.default.isIP(host)) {
            reject(new Error('Invalid host'));
            return;
        }
        const clean = () => {
            if (client) {
                client.removeAllListeners('connect');
                client.removeAllListeners('error');
            }
        };
        const onConnect = () => {
            resolve(true);
            clean();
        };
        const onError = (error) => {
            if (error.code !== 'ECONNREFUSED') {
                reject(error);
                return;
            }
            resolve(false);
            clean();
        };
        client = new net_1.default.Socket();
        client.once('connect', onConnect);
        client.once('error', onError);
        client.connect({ port: port, host: host }, () => { });
    });
}
exports.isPortBound = isPortBound;
