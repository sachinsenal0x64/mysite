"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prefetchWhenVisible_1 = __importDefault(require("./prefetchWhenVisible"));
const observerDefaults = {
    disabled: false,
    attributes: false,
};
let observer;
/**
 * Watches the DOM for all current and future links whose href matches one of the
 * specified URL patterns
 * @param {CacheManifest} cacheManifest
 * @param {RegExp[]} prefetchPatterns Additional patterns of links which should be prefetched
 * @param {ObserveOptionsConfig} observerOpts Configuration for how the DOM is observed for node changes
 */
function watchLinks(cacheManifest, prefetchPatterns, observerOpts) {
    /* istanbul ignore next */
    if (typeof MutationObserver === 'undefined')
        return;
    observerOpts = { ...observerDefaults, ...observerOpts };
    if (!observer) {
        observer = new MutationObserver(mutationsList => {
            for (let mutation of mutationsList) {
                filterByHref(mutation.addedNodes, cacheManifest, prefetchPatterns).forEach(prefetchWhenVisible_1.default);
            }
        });
        if (!observerOpts.disabled) {
            observer.observe(document.body, {
                attributes: observerOpts.attributes,
                childList: true,
                subtree: true,
            });
        }
    }
    filterByHref(document.querySelectorAll('a'), cacheManifest, prefetchPatterns).forEach(prefetchWhenVisible_1.default);
}
exports.default = watchLinks;
/**
 * Returns all nodes in the node list whose href matches at least one of the specified patterns.
 * @param {NodeList} nodes A node list to filter
 * @param {CacheManifest} cacheManifest Contains the list of route patterns to check
 * @param {RegExp[]} prefetchPatterns Additional patterns of links which should be watched
 */
function filterByHref(nodes, cacheManifest, prefetchPatterns) {
    const results = new Set();
    const isMatchingLink = (el) => {
        const href = el.getAttribute('href');
        // Prefetch only <a> tags with a href attribute
        if (!href || el.tagName.toLowerCase() !== 'a') {
            return false;
        }
        const hrefUrl = new URL(href, window.location.href);
        // Prefetch only links which are pointing to same domain
        if (hrefUrl.hostname !== window.location.hostname) {
            return false;
        }
        // Prefetch links that match one of the specified regexp patterns
        if (prefetchPatterns.some(pattern => pattern.test(hrefUrl.pathname))) {
            return true;
        }
        // Prefetch links that match any rule with valid max_age and service_worker_max_age features.
        return cacheManifest.shouldPrefetch(hrefUrl);
    };
    Array.from(nodes).forEach(n => {
        if (n.nodeType === Node.ELEMENT_NODE) {
            const el = n;
            const links = [el, ...Array.from(el.querySelectorAll('a'))];
            links.filter(isMatchingLink).forEach(link => results.add(link));
        }
    });
    return results;
}
