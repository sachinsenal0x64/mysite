"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefetch = exports.configure = void 0;
const waitForServiceWorker_1 = __importDefault(require("./waitForServiceWorker"));
const constants_1 = require("@edgio/core/constants");
const getHostName_1 = __importDefault(require("./getHostName"));
// According to Fastly, 2^13 (8192) is the max number of bytes allowed for a URL:
const MAX_URL_BYTES = 2 ** 13;
const prefetched = new Set();
const defaults = {
    includeCacheMisses: false,
    cacheHost: undefined,
    forcePrefetchRatio: 0,
};
let options = defaults;
/**
 * Configures prefetching options
 * @param opts
 */
function configure(opts) {
    options = { ...defaults, ...opts };
}
exports.configure = configure;
/**
 * Prefetches and caches the specified URL.
 *
 * **Example**
 *
 * ```js
 * import { prefetch } from '@edgio/prefetch/window
 *
 * // Prefetches the URL with default PrefetchConfiguration
 * prefetch('/some/url')
 *
 * // Prefetches the URL as fetch with custom PrefetchConfiguration
 * prefetch('/some/url', "fetch", {
 *     // Overrides the default Prefetch TTL or serviceWorkerSeconds value defined in routes.js
 *     // for this specific prefetch call
 *     maxAgeSeconds: 300, // 5 minutes
 *
 *     // Overrides the default forcePrefetchRatio value from install() function
 *     includeCacheMisses: true
 * });
 * ```
 * @param {String} url The URL to prefetch
 * @param {String} as Value to use for the "as" attribute of the <link> tag
 * @param {PrefetchConfiguration} config Options to use for the prefetch
 */
async function prefetch(url, as = 'fetch', config = {
    cors: 'anonymous',
    includeCacheMisses: options.includeCacheMisses,
    forcePrefetchRatio: options.forcePrefetchRatio,
}) {
    var _a, _b, _c, _d, _e;
    // In case service-worker was not registered by our install() function,
    // this function will add eventListener manually
    // @ts-ignore
    if (!window.swEventListenerAdded) {
        // Dynamic import is required to avoid circular dependency
        ;
        (await Promise.resolve().then(() => __importStar(require('./listenForSwMessages')))).default();
    }
    if (typeof url === 'undefined') {
        console.error(`prefetch() called with an undefined url`);
        return;
    }
    // Set values from global config if any of config options is missing
    // Set default value if global config value is undefined
    config.cors = (_a = config.cors) !== null && _a !== void 0 ? _a : 'anonymous';
    config.includeCacheMisses = (_c = (_b = config.includeCacheMisses) !== null && _b !== void 0 ? _b : options.includeCacheMisses) !== null && _c !== void 0 ? _c : false;
    config.forcePrefetchRatio = (_e = (_d = config.forcePrefetchRatio) !== null && _d !== void 0 ? _d : options.forcePrefetchRatio) !== null && _e !== void 0 ? _e : 0;
    // @ts-ignore
    if (config.headers) {
        console.warn('The prefetch `headers` configuration option has been removed as it is not compatible with the service-worker prefetch mechanism. Please set headers in your routes.js file with `setRequestHeader` if required.');
    }
    const cacheUrl = modifyUrl(url, config);
    if (typeof TextEncoder !== 'undefined' &&
        new TextEncoder().encode(cacheUrl).length > MAX_URL_BYTES) {
        console.warn(`URL is too many characters to prefetch and cache: ${cacheUrl}`);
        return;
    }
    // The cached responses can expire in meantime before user scroll to the bottom of the page.
    // That's why we're triggering new prefetch requests here by removing and adding prefetch link element to HTML DOM even for the URLs,
    // which were already prefetched. The cached responses will be served from the browser's cache storage anyway.
    //
    // This approach is faster than accessing the CacheStorage with thousands of responses just to check if the response is stale.
    // The impact to the performance with HTML DOM changes is minimal. We tested that with 1k prefetch calls.
    if (prefetched.has(cacheUrl)) {
        let prefetchLink = document.querySelector(`link[href='${cacheUrl}']`);
        prefetchLink === null || prefetchLink === void 0 ? void 0 : prefetchLink.remove();
    }
    prefetched.add(cacheUrl);
    await (0, waitForServiceWorker_1.default)();
    const link = document.createElement('link');
    const { relList } = link;
    link.setAttribute('href', cacheUrl);
    if (config.cors) {
        link.setAttribute('crossorigin', config.cors);
    }
    link.setAttribute('rel', relList.supports('preload') && /* istanbul ignore next */ !relList.supports('prefetch')
        ? /* istanbul ignore next */ 'preload'
        : 'prefetch' // Safari does not support prefetch so we use preload instead
    );
    link.setAttribute('as', as);
    document.head.append(link);
}
exports.prefetch = prefetch;
function modifyUrl(url, config) {
    const { body, method, maxAgeSeconds } = config;
    const parsed = new URL(url, window.origin);
    if (parsed.hostname === (0, getHostName_1.default)()) {
        // If we are prefetching from Edgio sidecar, rewrite the URL to use the sidecar's domain name
        if (options.cacheHost) {
            const cacheHostUrl = new URL(`https://${options.cacheHost}`);
            parsed.hostname = cacheHostUrl.hostname;
            parsed.protocol = cacheHostUrl.protocol;
            parsed.port = cacheHostUrl.port;
        }
        appendSearchParam(parsed, constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM, '1');
        maybeAddThrottleParam(parsed, config);
    }
    if (body) {
        appendSearchParam(parsed, constants_1.POST_BODY_QUERY_PARAM, body);
    }
    if (method) {
        appendSearchParam(parsed, constants_1.METHOD_QUERY_PARAM, method);
    }
    if (maxAgeSeconds && maxAgeSeconds > 0) {
        appendSearchParam(parsed, constants_1.PREFETCH_TTL_PARAM, maxAgeSeconds.toString());
    }
    return parsed.toString();
}
function appendSearchParam(url, name, value) {
    const separator = url.search.length ? '&' : '?';
    url.search += `${separator}${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
}
/**
 * Adds the query param that indicates to the service worker that a request may be throttled
 * @param url
 * @param config
 */
function maybeAddThrottleParam(url, config) {
    if (!config.includeCacheMisses && shouldAcceptThrottling(config)) {
        appendSearchParam(url, constants_1.THROTTLED_QUERY_PARAM, '1');
    }
}
/**
 * Returns true if the next prefetch request should only be served from the edge cache.
 * This is done by comparing a random number between 0 and 1 to options.forcePrefetchRatio
 */
function shouldAcceptThrottling(config) {
    return !config.forcePrefetchRatio || Math.random() > config.forcePrefetchRatio;
}
