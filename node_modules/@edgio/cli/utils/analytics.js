"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocalProjectInfo = exports.enableAnalytics = exports.disableAnalytics = exports.analyticsInfoMessage = exports.Analytics = void 0;
var _getEdgioConfig = _interopRequireDefault(require("./getEdgioConfig"));
var _detectFramework = _interopRequireDefault(require("../frameworks/detectFramework"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const {
  EOL
} = require('os');
const Mixpanel = require('mixpanel');
const {
  getAnalyticsEnabled,
  setAnalyticsEnabled
} = require('./config');
const crypto = require('crypto');
const hashSHA256 = inputString => {
  const hash = crypto.createHash('sha256');
  hash.update(inputString);
  return hash.digest('hex');
};

/**
 * This function can get us information such as
 *  - Used connector
 *  - Used framework
 *  - Used frameworkVersion
 *  We are getting those values in our code anyway, but it's rooted deeply in our code
 *  for the purpose of the analytics we need get this info at the start of our program.
 * @returns {Promise<{connector}|{framework: string, frameworkVersion: unknown, connector}|{}>}
 */
const getLocalProjectInfo = async () => {
  let analysis = {};
  try {
    const {
      connector
    } = (0, _getEdgioConfig.default)();
    const frameworkFromPackageJSON = await (0, _detectFramework.default)(true);
    if (frameworkFromPackageJSON) {
      return {
        connector,
        framework: frameworkFromPackageJSON.package,
        frameworkVersion: frameworkFromPackageJSON.version.version
      };
    } else {
      return {
        connector
      };
    }
  } catch (_e) {
    // We don't care if we fail, this is just analytics
  }
  return analysis;
};
exports.getLocalProjectInfo = getLocalProjectInfo;
const commandToDisableAnalytics = `${_constants.MAIN_COMMAND} config set-analytics false`;
const analyticsInfoMessage = `${_constants.PRODUCT_NAME} CLI is optionally collecting usage and error reporting information to help improve our products. All personal data is omitted.` + ` If you wish to disable the analytics, you can do so with command:${EOL}${commandToDisableAnalytics}${EOL}Or you can disable them using ENV variable ${_constants.ENV_DISABLE_ANALYTICS}${EOL}`;
exports.analyticsInfoMessage = analyticsInfoMessage;
const enableAnalytics = () => {
  setAnalyticsEnabled(true);
};
exports.enableAnalytics = enableAnalytics;
const disableAnalytics = () => {
  setAnalyticsEnabled(false);
};

/**
 * Disabled analytics:
 * If analytics are disabled, the instance of analytics doesn't have
 * clientID setup. All the functions which are called on this class
 * will do nothing in that case.
 *
 * Source CLI:
 * All the events and personas setup in the MixPanel have property "source"
 * set to "cli" as we are mixing events from console too.
 */
exports.disableAnalytics = disableAnalytics;
class Analytics {
  /**
   * Creates analytics
   * @param {string} mixpanelToken
   */
  constructor(mixpanelToken) {
    _defineProperty(this, "mixpanelToken", undefined);
    _defineProperty(this, "clientID", undefined);
    this.mixpanelToken = mixpanelToken;
    this.version = _constants.CLI_VERSION;
    // We want to set person only once
    this.personSet = false;
  }
  setClientId(id) {
    if (!getAnalyticsEnabled() || process.env[_constants.ENV_DISABLE_ANALYTICS] || id === undefined) return;
    if (!this.mixpanel) this.mixpanel = Mixpanel.init(this.mixpanelToken);
    this.clientID = hashSHA256(id);
  }
  async setPerson() {
    // These values can be set only once per user
    this.mixpanel.people.set_once(this.clientID, {
      'First seen on version': this.version,
      'First seen on CLI package': _constants.CLI_PACKAGE_NAME,
      source: 'cli',
      $created: new Date().toISOString()
    });
    this.mixpanel.people.set(this.clientID, {
      'Last Version Used': this.version,
      'Last seen on CLI package': _constants.CLI_PACKAGE_NAME
    });
  }

  /**
   * Getting email requires API call based on API key. We would set this only
   * when we already have the email from different actions. There is no need
   * to slow other commands with API call. All users usually logs in sooner or
   * later
   * @param {string} email
   */
  async setEmail(email) {
    // Create alias for email, this allows us to track the same user across
    // different computers (clientIDs)
    this.mixpanel.alias(email, this.clientID);
    this.mixpanel.people.set(this.clientID, {
      $email: email
    });
  }

  /**
   * When analytics are disabled this command doesn't do anything as
   * clientID is not setup.
   * @param {string} eventName All events have automatically added cli_ prefix
   * @param {Object} [properties]
   */
  async trackEvent(eventName, properties) {
    if (!this.clientID) return;

    // We want to do this only once
    if (!this.personSet) {
      await this.setPerson();
      this.personSet = true;
    }
    this.mixpanel.track(`cli_${eventName}`, _objectSpread(_objectSpread({}, properties), {
      distinct_id: this.clientID,
      version: this.version,
      packageName: _constants.CLI_PACKAGE_NAME,
      $os: process.platform,
      ci: process.env.CI || false,
      source: 'cli'
    }));
  }
}
exports.Analytics = Analytics;