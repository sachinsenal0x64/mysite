"use strict";

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const setProperty = require('../../utils/config/setProperty');
const useDeployOptions = require('../../utils/useDeployOptions');
const {
  readFileSync,
  writeFileSync
} = require('fs');
const {
  handler: deployHandler
} = require('../deploy');
const getEdgioConfigFilePath = require('../../utils/getEdgioConfigFilePath');
exports.command = 'set-backend <backend>';
exports.describe = 'Sets the specified backend configuration options';
exports.builder = _objectSpread({
  domainOrIp: {
    type: 'string',
    alias: 'd',
    describe: 'The domain name or IP Address of the backend server.'
  },
  hostHeader: {
    type: 'string',
    alias: 'h',
    describe: 'The host header to be sent to the backend server.'
  },
  deploy: {
    type: 'boolean',
    describe: 'Include this flag to deploy your property after applying the configuration changes.'
  }
}, useDeployOptions());
exports.handler = async yargs => {
  const {
    context: {
      logger
    },
    backend,
    domainOrIp,
    hostHeader
  } = yargs;
  try {
    console.log(`> Updating '${backend}' backend...`);
    const after = new RegExp(`${backend}: {`);
    const configPath = getEdgioConfigFilePath();
    if (!configPath) {
      throw new Error("No edgio.config.js found. Please ensure you are in your app's root directory.");
    }
    let source = readFileSync(configPath, 'utf8');
    if (domainOrIp) {
      source = setProperty(source, 'domainOrIp', domainOrIp, {
        after
      });
    }
    if (hostHeader) {
      source = setProperty(source, 'hostHeader', hostHeader, {
        after
      });
    }
    writeFileSync(configPath, source, 'utf8');
    console.log(`> Backend '${yargs.backend}' has been updated.`);
  } catch (e) {
    logger.error(`> An error occurred while attempting to update the backend config:`);
    console.log(e.message);
    process.exit(1);
  }
  if (yargs.deploy) {
    await deployHandler(yargs);
  }
};