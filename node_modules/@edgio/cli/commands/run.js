"use strict";

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const {
  join
} = require('path');
const {
  existsSync
} = require('fs');
const chalk = require('chalk');
const logo = require('../utils/logo');
const runDeploymentArchive = require('../utils/runDeploymentArchive');
const runWithServerless = require('../utils/runWithServerless');
const clearPorts = require('../utils/clearPorts');
const getEntryPoint = require('../utils/getEntryPoint');
const {
  isMonorepo,
  locateAppToRunCmd
} = require('../utils/monorepo');
const serveStaticAssets = require('../serverless/serveStaticAssets');
const serveImageOptimizer = require('../serverless/serveImageOptimizer');
const {
  getLocalProjectInfo
} = require('../utils/analytics');
const edgeFunctionCachingNotice = chalk.green('\n> Note: CLI does not not support caching for edge function fetch() calls');
exports.command = 'run [archive]';
exports.describe = 'Runs your project locally, simulating Edgio cloud environment. When no arguments are provided, this command is the same as edgio dev.';
exports.builder = yargs => yargs.option('production', {
  type: 'boolean',
  alias: 'p',
  describe: 'Runs your app in production mode, with caching enabled, emulating Edgio serverless runtime environment. You must first run edgio build to create a production build of your app.'
}).option('cache', {
  type: 'boolean',
  alias: 'c',
  describe: 'Enables caching in development mode. Caching is enabled by default in production mode.'
}).positional('archive', {
  describe: 'The path to a deployment archive (zip) file downloaded from Edgio Developer Console'
});
exports.handler = async ({
  context,
  production,
  archive,
  cache
}) => {
  const {
    PORTS,
    EDGIO_ENV_VARIABLES
  } = require('../constants');
  const {
    assetPort,
    imageOptimizerPort
  } = PORTS;
  process.env[EDGIO_ENV_VARIABLES.local] = 'true';
  process.env.LOG_LEVEL = process.env.LOG_LEVEL || 'INFO';
  const {
    analytics
  } = context;
  let promiseTrackedRunning;
  const promiseTrackedRun = analytics.trackEvent('run', {
    production,
    archive,
    cache
  });
  await clearPorts();
  if (isMonorepo()) {
    await locateAppToRunCmd('run');
  }
  const edgioDir = join(process.cwd(), '.edgio');
  const assetsDir = join(edgioDir, 's3');
  const permanentAssetsDir = join(edgioDir, 's3-permanent');
  const staticAssetDirs = [assetsDir, permanentAssetsDir];
  if (!production) {
    staticAssetDirs.unshift(process.cwd());
  }
  const {
    logger
  } = context;
  if (production) {
    cache = true;
  }
  await serveStaticAssets(staticAssetDirs, assetPort);
  serveImageOptimizer(imageOptimizerPort);
  logger.info('');
  if (archive) {
    logger.info(`> Running deployed app locally using ${logo}...`);
    await runDeploymentArchive(archive);
  } else if (production) {
    if (!existsSync(edgioDir)) {
      logger.error(`\nEdgio production build not found. Please run ${chalk.green('edgio build')} before running ${chalk.green('edgio run --production')}.\n`);
      process.exit(1);
    }
    logger.info(`> Running ${logo} in production mode...${edgeFunctionCachingNotice}`);
    if (analytics.enabledAnalytics) {
      // Don't run project info when we don't have analytics
      const projectInfo = await getLocalProjectInfo();
      promiseTrackedRunning = analytics.trackEvent('running', _objectSpread(_objectSpread({}, {
        type: 'prod'
      }), projectInfo));
    }

    // Edgio automatically sets this as an environment variable on the Lambda in the cloud
    process.env.NODE_ENV = 'production';
    await runWithServerless(edgioDir);
  } else {
    logger.info(`> Starting ${logo} in development mode with caching ${cache ? chalk.green('enabled') : chalk.red('disabled')}...${cache ? edgeFunctionCachingNotice : ''}`);
    if (analytics.enabledAnalytics) {
      // Don't run project info when we don't have analytics
      const projectInfo = await getLocalProjectInfo();
      promiseTrackedRunning = analytics.trackEvent('running', _objectSpread(_objectSpread({}, {
        type: 'dev'
      }), projectInfo));
    }
    if (cache) {
      process.env[EDGIO_ENV_VARIABLES.cache] = 'true';
    }
    const dev = await getEntryPoint('dev');
    dev();
  }
  await promiseTrackedRun;
  await promiseTrackedRunning;
};