"use strict";

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const path = require('path');
const fse = require('fs-extra');
const {
  compact,
  get,
  isEmpty,
  find,
  uniq
} = require('lodash');
const {
  EOL
} = require('os');
const sleep = require('../utils/sleep');
const packageProject = require('../utils/packageProject');
const git = require('../utils/git');
const EdgioPackageJson = require('../utils/EdgioPackageJson');
const getCoreEdgioVersion = require('../utils/getCoreEdgioVersion');
const buildProject = require('../utils/build');
const {
  readEdgioVersion: readEdgioVersion
} = require('../utils/edgio');
const authenticate = require('../prompts/authenticate');
const detectFramework = require('../frameworks/detectFramework');
const {
  DeployError,
  ValidationError,
  EdgioCLIError,
  EdgioBuildError
} = require('../utils/errors');
const stdStreamsObserver = require('../utils/stdStreamsObserver');
const announceSuccessfulDeployment = require('../utils/announceSuccessfulDeployment');
const announceFailedDeployment = require('../utils/announceFailedDeployment');
const announceCanceledDeployment = require('../utils/announceCanceledDeployment');
const {
  isMonorepo,
  locateAppToRunCmd
} = require('../utils/monorepo');
const buildCommand = require('./build');
const getRouterInfo = require('../utils/getRouterInfo');
const writeDeploymentManifest = require('../utils/writeDeploymentManifest');
const {
  yesNoQuestion
} = require('../utils/prompts');
const getEdgioConfig = require('../utils/getEdgioConfig');
const Validator = require('../utils/validator');
const {
  getLocalProjectInfo
} = require('../utils/analytics');
const versionMismatchWarning = require('../prompts/versionMismatchWarning');
const deprecatedCommandWarning = require('../prompts/deprecatedCommandWarning');
const {
  getCloudRuntime
} = require('../utils/getCloudRuntime');
exports.command = 'deploy [organization]';
exports.describe = 'Deploys your project to Edgio';
exports.builder = _objectSpread(_objectSpread({}, buildCommand.builder), {}, {
  skipFramework: _objectSpread(_objectSpread({}, buildCommand.builder.skipFramework), {}, {
    alias: 'sf'
  }),
  property: {
    alias: 'p',
    type: 'string',
    describe: 'Slug of the property to deploy to, using package.json name property by default.'
  },
  'skip-build': {
    type: 'boolean',
    describe: 'Skips rebuilding your app and deploys the previous build instead.'
  },
  path: {
    type: 'string',
    describe: "Path to your property's root directory. Uses current directory by default.",
    default: '.'
  },
  organization: {
    type: 'string',
    alias: 'o',
    describe: 'The name of the organization under which the property will be deployed. The property will be deployed to your private space if omitted.'
  },
  branch: {
    type: 'string',
    alias: 'b',
    describe: 'The name of the source control branch. This is automatically set when using Git.'
  },
  environment: {
    type: 'string',
    alias: 'e',
    describe: 'Environment to deploy to. Uses default environment if omitted.'
  },
  'commit-url': {
    type: 'string',
    describe: `Custom commit url. Automatically works for github, bitbucket and gitlab. Git SHA is appended at the end of the provided url.${EOL}` + 'Example: https://github.com/jlord/sheetsee.js/commit/'
  },
  'disable-organization-check': {
    type: 'boolean',
    describe: 'Skips the check to see if the property is being deployed to a personal organization and also exists on a shared organization.',
    default: false
  },
  // @deprecated legacy params
  // Remove this command in v8 EDGSITES-171
  site: {
    type: 'string',
    alias: 's',
    deprecated: "Use '--property' instead. Will be deprecated in next major version."
  },
  team: {
    type: 'string',
    alias: 't',
    deprecated: "Use '--organization' instead. Will be deprecated in next major version."
  },
  'disable-team-check': {
    type: 'boolean',
    deprecated: "Use '--disable-organization-check' instead. Will be deprecated in next major version."
  },
  'purge-cache-on-deploy': {
    type: 'boolean',
    describe: 'Clear cache after site deploy.'
  }
});

// Per https://nodejs.org/api/process.html#process_signal_events we chose
// the following signals to be handled:
const HANDLED_PROCESS_SIGNAL_EVENTS = ['SIGTERM', 'SIGINT', 'SIGHUP', 'SIGBREAK'];
class DeployCommand {
  constructor(yargs) {
    _defineProperty(this, "_wrappedRun", async () => {
      var _this$_context$curren, _this$_context$curren2, _this$_context$curren3, _this$_context$curren4, _this$_context$curren5, _this$_context$curren6, _this$_context$curren7;
      let {
        path: givenPath,
        organization: organizationSlug,
        property: propertyParam,
        branch,
        environment,
        skipBuild,
        commitUrl: customCommitUrl,
        // @deprecated legacy params
        team: teamSlugParam,
        site: siteSlugParam
      } = this._yargs;
      const {
        logger
      } = this._context;
      const framework = await detectFramework();

      // Remove this command in v8 EDGSITES-171
      if (siteSlugParam) {
        deprecatedCommandWarning(this._context, 'site', 'property');
      }
      // Remove this command in v8 EDGSITES-171
      if (teamSlugParam) {
        deprecatedCommandWarning(this._context, 'team', 'organization');
      }
      propertyParam = propertyParam || siteSlugParam;
      organizationSlug = organizationSlug || teamSlugParam;
      versionMismatchWarning(this._context);
      this._context.setLoginAction('deploy');
      await authenticate(this._context);
      if (isMonorepo()) {
        await locateAppToRunCmd('deploy');
      }
      const absolutePath = path.resolve(process.cwd(), givenPath);

      // Check that package.json is existing or fail the deployment
      const packageJson = EdgioPackageJson.loadPackageJson(givenPath);
      const coreEdgioVersion = getCoreEdgioVersion();
      if (isEmpty(coreEdgioVersion)) {
        throw new DeployError('@edgio/core module has not been installed, please run "edgio init".');
      }
      const config = getConfig(logger);
      const validator = new Validator(logger, {
        exitOnError: true
      });

      // Get the token's property slug when property specific deploy token is used
      const deployTokenPropertySlug = ((_this$_context$curren = this._context.currentActor) === null || _this$_context$curren === void 0 ? void 0 : (_this$_context$curren2 = _this$_context$curren.deployToken) === null || _this$_context$curren2 === void 0 ? void 0 : (_this$_context$curren3 = _this$_context$curren2.property) === null || _this$_context$curren3 === void 0 ? void 0 : _this$_context$curren3.slug) ?? null;
      const deployTokenOrganizationSlug = ((_this$_context$curren4 = this._context.currentActor) === null || _this$_context$curren4 === void 0 ? void 0 : (_this$_context$curren5 = _this$_context$curren4.deployToken) === null || _this$_context$curren5 === void 0 ? void 0 : (_this$_context$curren6 = _this$_context$curren5.property) === null || _this$_context$curren6 === void 0 ? void 0 : (_this$_context$curren7 = _this$_context$curren6.organization) === null || _this$_context$curren7 === void 0 ? void 0 : _this$_context$curren7.slug) ?? null;

      // If --property is provided, override default $npm_package_name
      // If no property is provided, use other names in this order:
      const propertySlug = validator.validatePropertyName(propertyParam || deployTokenPropertySlug || config.name || packageJson.name);
      const branchName = branch || (await git.currentBranch(absolutePath));
      const isDirtyCommit = await git.isDirty();
      const commitUrl = isDirtyCommit ? undefined : await git.commitUrl(absolutePath, customCommitUrl);
      let purgeCacheOnDeploy;
      if (typeof this._yargs.purgeCacheOnDeploy !== 'undefined') {
        purgeCacheOnDeploy = this._yargs.purgeCacheOnDeploy;
      } else {
        purgeCacheOnDeploy = typeof config.purgeCacheOnDeploy === 'undefined' ? null : config.purgeCacheOnDeploy;
      }
      organizationSlug = organizationSlug || deployTokenOrganizationSlug || config.organization || config.team || (await this.checkIfPropertyExistsOnAnotherOrganization(propertySlug));
      const cloudRuntime = getCloudRuntime(config, logger);
      await logger.title('📋 Deploying to:');
      logger.info([`> Organization: ${organizationSlug || 'Private space'}`, `> Property: ${propertySlug}`, branchName && `> Branch: ${branchName}`, `> Environment: ${environment || 'default'}`, `> Edgio version: ${coreEdgioVersion}`, `> Cloud runtime: ${cloudRuntime}`, `> Purge cache on deploy: ${purgeCacheOnDeploy !== null ? purgeCacheOnDeploy : 'default'}`, commitUrl && `> Commit URL: ${commitUrl}`].filter(Boolean) // Removes falsy values
      .join(EOL));

      // Throw an error when property's token doesn't belong to specified property via --property param.
      // Only warning from API is shown when property's name is retrieved from edgio.config.js
      if (propertyParam && deployTokenPropertySlug && propertyParam !== deployTokenPropertySlug) {
        logger.error(`Error: Property with name "${propertyParam}" can't be deployed with this token. The token allows access to oroperty "${deployTokenPropertySlug}" only. ${EOL}Please specify the correct property name via --property param or use another token.`);
        process.exit(1);
      }
      const {
        build: {
          id: buildId,
          number: buildNumber
        },
        s3SelfSignedProjectPost,
        cliMessages,
        environmentVariables
      } = await this._context.api.createBuild({
        propertySlug,
        organizationSlug,
        environment,
        edgioVersion: coreEdgioVersion,
        cloudRuntime,
        branch: branchName,
        framework: get(framework, 'key'),
        commitUrl,
        purgeCacheOnDeploy
      });
      logger.info(`> Deployment #${buildNumber}`);
      // Capture the build ID immediately so that we can fail the build on any errors.
      this._buildId = buildId;

      // copy environment variables from console into process.env so code can access them at build time
      for (let {
        key,
        value
      } of environmentVariables) {
        if (value != null) {
          process.env[key] = value;
        }
      }
      if (cliMessages) {
        for (let {
          message,
          _level
        } of cliMessages) {
          logger.warn(message);
        }
      }
      let buildStep = async () => {
        if (!skipBuild) {
          const streamsObserver = stdStreamsObserver([process.stdout, process.stderr]);
          try {
            await buildProject(this._yargs);
          } catch (e) {
            if (e.type === 'FrameworkBuildError') {
              throw new DeployError(e.message, {
                addToLeDeployerLogs: streamsObserver.getOutput()
              });
            } else {
              throw new DeployError('Project build failed', {
                errorDetails: e.stack || e.message,
                addToLeDeployerLogs: streamsObserver.getOutput()
              });
            }
          } finally {
            streamsObserver.detach();
          }

          // Push Build output when framework build was success
          await this._context.api.updateBuild(this._buildId, {}, [{
            message: `Build output\n${streamsObserver.getOutput()}`
          }]);
        }
      };
      const zippingStep = async () => {
        // Check that Edgio versions match unless we are overriding the versions for platform development.
        if (isEmpty(process.env.EDGIO_VERSION_OVERRIDE)) {
          const builtEdgioVersion = await readEdgioVersion(absolutePath);
          if (coreEdgioVersion !== builtEdgioVersion) {
            throw new DeployError(`Please rebuild with Edgio v${coreEdgioVersion}`);
          }
        }

        // Puts projectRoot/.Edgio folder into zip
        const projectZipFile = await packageProject(absolutePath, this._yargs);
        return {
          projectZipFile
        };
      };
      const uploadingStep = ({
        projectZipFile,
        s3SelfSignedProjectPost
      }) => logger.step('📡️ Uploading...', async () => {
        const routerInfo = await getRouterInfo(absolutePath);
        const zipFileStream = fse.createReadStream(projectZipFile);
        await this._context.api.presignedUploadToS3(s3SelfSignedProjectPost, zipFileStream);
        await this._context.api.updateBuild(buildId, {
          status: 'uploaded',
          routerInfo
        });
        await fse.remove(projectZipFile);
      });
      const deployingStep = () => logger.step('⌛ Deploying...', async () => {
        // Now that we have finished with uploading and we are just waiting we should
        // not fail the builds if CLI fails or is interrupted.
        this._deregisterProcessSignalHandlers();
        await this._streamLogsUntilStatus(['completed']);
      });

      // Run the steps with as much parallelism as possible
      // Packaging step requires the build
      const {
        projectZipFile
      } = await buildStep().then(zippingStep);
      await uploadingStep({
        s3SelfSignedProjectPost,
        projectZipFile
      });
      await deployingStep();
      const build = await this.getBuild({
        refresh: true
      });
      logger.info(EOL + announceSuccessfulDeployment(build) + EOL);
      writeDeploymentManifest(absolutePath, build);
    });
    _defineProperty(this, "_streamLogsUntilStatus", async statuses => {
      const {
        logger
      } = this._context;

      // TODO: use subscriptions?
      const LOG_PULL_DELAY = 5000;
      let build;
      while (!build || !statuses.includes(build.status)) {
        await sleep(LOG_PULL_DELAY);
        build = await this.getBuild({
          refresh: true
        });
        const logs = compact(build.logs.split('\n'));
        const newLogs = logs.slice(this._displayedLogsCount || 0);
        newLogs.forEach(newLog => logger.debug(newLog));
        this._displayedLogsCount = logs.length;
        if (build.status === 'failed') {
          throw new EdgioBuildError(build);
        }
      }
      return build;
    });
    this._yargs = yargs;
    this._buildId = null;
    this._context = this._yargs.context;
  }

  /**
   * Performs the deploy command. It correctly fails the build (if it has been started)
   * on any error.
   */
  async run() {
    // Register all the signal events for handling before starting the run.
    this._registerProcessSignalHandlers();
    try {
      await this._wrappedRun();
    } catch (e) {
      await this._failBuild(e);
      throw e;
    } finally {
      this._deregisterProcessSignalHandlers();
    }
  }

  /**
   * Handler for all the process signal that we handle during the process.
   *
   * @param {String} signal ID of the signal that was raised
   */
  _processSignalHandler(signal) {
    const error = new EdgioCLIError(`${signal} raised`);
    this._cancelBuild(error).then(() => {
      process.exit(1);
    });
  }

  /**
   * Registers process signal handlers.
   *
   * Notes:
   * - Deregistering requires the exact same binding as registering
   * as process.on doesn't return a handler that we could use.
   * This is why all the handlers are exactly the same.
   */
  _registerProcessSignalHandlers() {
    HANDLED_PROCESS_SIGNAL_EVENTS.forEach(signal => {
      process.on(signal, this._processSignalHandler.bind(this));
    });
  }

  /**
   * Deregisters process signal handlers.
   *
   * Notes:
   * - The deregistering is idempotent and we call it from multiple places.
   */
  _deregisterProcessSignalHandlers() {
    HANDLED_PROCESS_SIGNAL_EVENTS.forEach(signal => {
      process.listeners(signal).map(handler => process.off(signal, handler));
    });
  }
  async _failEdgioBuild(e) {
    // EdgioBuildError are already originating from a failed build on Edgio so we don't need
    // to push that information back to LeDeployer. It would also result in duplicated logs
    if (e instanceof EdgioBuildError) {
      return;
    }
    try {
      let message = `Build failed with error: ${e.message}`;
      if (e.errorDetails) {
        message += `\n${e.errorDetails}`;
      }
      if (e.addToLeDeployerLogs) {
        message += `\n${e.addToLeDeployerLogs}`;
      }
      if (e.stack && !e.isUserError) {
        // An error that occurred in the normal user workflow:
        // (failed sign-in, organization slug not found, javascript build failure, etc...)
        // in which case we don't want to display a stack trace but just a specific error message and details
        message += e.stack;
      }
      await this._context.api.updateBuild(this._buildId, {
        status: 'failed'
      }, [{
        level: 'error',
        message
      }]);
    } catch (e) {
      console.error(`Update build failed: ${e.message}`);
    }
  }
  async _cancelBuild(e) {
    if (!this._buildId) return;
    try {
      let message = `Build canceled with error: ${e.message}`;
      await this._context.api.updateBuild(this._buildId, {
        status: 'canceled'
      }, [{
        level: 'warn',
        message
      }]);
    } catch (e) {
      console.error(`Update build failed: ${e.message}`);
    }
    const build = await this.getBuild();
    await this._context.logger.info(EOL + announceCanceledDeployment(build.consoleUrl) + EOL);
  }
  async _failBuild(e) {
    if (!this._buildId) {
      return;
    }
    const build = await this.getBuild();

    // When build is already uploaded, CLI should not be able to fail the build on errors.
    if (['initializing', 'initialized', 'uploading'].includes(build.status)) {
      await this._failEdgioBuild(e);
      this._context.logger.info(EOL + announceFailedDeployment(build.consoleUrl) + EOL);
    }
  }
  async getBuild({
    refresh = false
  } = {}) {
    if (!this._buildId) return;
    if (this._build && !refresh) {
      return this._build;
    }
    this._build = await this._context.api.getBuild(this._buildId);
    return this._build;
  }
  async checkIfPropertyExistsOnAnotherOrganization(propertySlug) {
    const {
      organization: organizationSlugParam,
      disableOrganizationCheck,
      // @deprecated legacy params
      team: teamSlugParam,
      disableTeamCheck
    } = this._yargs;
    const {
      logger,
      api,
      nonInteractive
    } = this._context;

    /**
     * Below we check to see which property the user is deploying to
     * and if deploying to a personal space, check to see if the
     * same property exists on other organizations the user belongs to. If
     * the property exists on another organization, prompt the user to confirm
     * if they are wanting to continue deploying to their private
     * space or if they intended to deploy to a shared organization.
     */
    const localOrganizationSlug = organizationSlugParam || teamSlugParam;
    // skip this check if:
    // - deploy token was specified
    // - organization was specified
    // - --disable-organization-check=true
    if (nonInteractive || localOrganizationSlug || disableOrganizationCheck || disableTeamCheck) {
      return localOrganizationSlug;
    }
    const [organizationData, personalOrganization] = await Promise.all([api.getOrganizationsPropertiesEnvs(), api.getPersonalOrganization()]);
    const {
      slug: personalOrganizationSlug
    } = personalOrganization;

    // filter personal organization from available organizations
    const organizations = organizationData.nodes.filter(organization => organization.slug !== personalOrganizationSlug);

    // look for property name in other organizations and record each matching organization
    const propertyInOrganizations = [];
    find(organizations, organization => find(organization.properties.nodes, property => {
      if (property.slug === propertySlug) {
        propertyInOrganizations.push(organization.slug);
      }
    }));

    // dedup organizations (shouldn't be possible) and confirm if the user
    // would like to change which organization to deploy to
    for (let organization of uniq(propertyInOrganizations)) {
      const confirmed = await yesNoQuestion(logger.highlight('yellow', `WARNING: A property named '${propertySlug}' is also deployed to organization '${organization}'. ` + `Are you sure you want to deploy this property to your private space?${EOL}`), {
        initial: false
      });
      // new line for readability
      console.log();
      if (confirmed) {
        return localOrganizationSlug;
      } else {
        process.exit(0);
      }
    }
  }
}
const validate = yargs => {
  const commitUrl = yargs.commitUrl;
  if (commitUrl && !/(http|https):\/\//.test(commitUrl)) {
    throw new ValidationError('Invalid commit url protocol');
  }
};
exports.handler = async yargs => {
  validate(yargs);
  const {
    context
  } = yargs;
  let analyticsParams = {};
  for (const key in exports.builder) {
    analyticsParams[key] = yargs[key];
  }
  delete analyticsParams['commit-url'];
  const projectInfo = await getLocalProjectInfo();
  analyticsParams = _objectSpread(_objectSpread({}, analyticsParams), projectInfo);
  const promiseTracked = context.analytics.trackEvent('deploy', analyticsParams);
  const command = new DeployCommand(yargs);
  await command.run();
  await promiseTracked;
};

/**
 * Returns the contents of edgio.config.js, or, if not present, exits with
 * an error message.
 * @returns
 */
function getConfig(logger) {
  const config = getEdgioConfig();
  if (!config) {
    logger.error(`Error: edgio.config.js not found. Please run "edg init" to initialize your Edgio project.\n`);
    process.exit(1);
  }
  return config;
}